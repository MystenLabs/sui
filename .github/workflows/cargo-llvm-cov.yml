name: Code Coverage
on:
  schedule:
    - cron: '0 9 * * *' # UTC timing is every day at 1am PST
  workflow_dispatch:
    inputs:
      sui_repo_ref:
        description: "Branch / commit to test"
        type: string
        required: false
        default: ''

env:
  CARGO_TERM_COLOR: always
  # Disable incremental compilation.
  #
  # Incremental compilation is useful as part of an edit-build-test-edit cycle,
  # as it lets the compiler avoid recompiling code that hasn't changed. However,
  # on CI, we're not making small edits; we're almost always building the entire
  # project from scratch. Thus, incremental compilation on CI actually
  # introduces *additional* overhead to support making future builds
  # faster...but no future builds will ever occur in any given CI environment.
  #
  # See https://matklad.github.io/2021/09/04/fast-rust-builds.html#ci-workflow
  # for details.
  CARGO_INCREMENTAL: 0
  # Allow more retries for network requests in cargo (downloading crates) and
  # rustup (installing toolchains). This should help to reduce flaky CI failures
  # from transient network timeouts or other issues.
  CARGO_NET_RETRY: 10
  RUSTUP_MAX_RETRIES: 10
  # Don't emit giant backtraces in the CI logs.
  RUST_BACKTRACE: short
  # RUSTFLAGS: -D warnings
  RUSTDOCFLAGS: -D warnings

jobs:
  cargo-llvm-cov:
    name: Generate code coverage
    runs-on: [ubuntu-ghcloud]
    timeout-minutes: 240
    env:
      CARGO_TERM_COLOR: always
    steps:
      - name: Install Rust
        run: rustup update stable
        
      - uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # pin@v6.0.2
        with:
            ref: ${{ github.event.inputs.sui_repo_ref || github.ref }}

      - name: Install cargo-llvm-cov
        uses: taiki-e/install-action@cargo-llvm-cov

      - name: Install nextest
        uses: taiki-e/install-action@nextest

      - uses: taiki-e/install-action@protoc
      - name: Add postgres to PATH
        run: echo "/usr/lib/postgresql/14/bin" >> $GITHUB_PATH

      - name: Install Rust toolchain
        run: rustup show active-toolchain || rustup toolchain install

      - name: Set Swap Space
        uses: pierotofy/set-swap-space@fc79b3f67fa8a838184ce84a674ca12238d2c761 # pin@master
        with:
          swap-size-gb: 256
        
      - name: Run code coverage for nextest
        run: RUSTFLAGS="-C debuginfo=0" SUI_SKIP_SIMTESTS=1 cargo llvm-cov --ignore-run-fail --lcov --output-path lcov.info nextest -vv -E '!package(sui-bridge) and !package(sui-bridge-indexer)'

      - name: Upload report to Codecov for nextest
        uses: codecov/codecov-action@671740ac38dd9b0130fbe1cec585b89eea48d3de # pin@v5.5.2
        with:
          files: lcov.info

      - name: Run code coverage for simtest
        run: |
          git clean -fd
          ./scripts/simtest/codecov.sh

      - name: Upload report to Codecov for simtest
        uses: codecov/codecov-action@671740ac38dd9b0130fbe1cec585b89eea48d3de # pin@v5.5.2
        with:
          files: lcov-simtest.info

  notify:
    name: Notify
    needs: [cargo-llvm-cov]
    runs-on: ubuntu-latest
    if: always() # always notify

    steps:
    - uses: technote-space/workflow-conclusion-action@45ce8e0eb155657ab8ccf346ade734257fd196a5 # Pin v4.1.1

    - name: Checkout sui repo
      uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # pin@v6.0.2
      with:
        ref: ${{ github.event.inputs.sui_repo_ref || github.ref }}
    
    - name: Get sui commit
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        export sui_sha=$(git rev-parse HEAD)
        echo "sui_sha=${sui_sha}" >> $GITHUB_ENV

    - name: Get a branch name for a sui commit
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        export sui_branch_name=$(gh api -H 'Accept: application/vnd.github+json' /repos/MystenLabs/sui/commits/${{ env.sui_sha }}/branches-where-head --jq '.[].name' | head -n 1)
        # if the commit is not the head of the branch, get it's base branch 
        [[ -z $sui_branch_name ]] && export sui_branch_name=$(gh api -H 'Accept: application/vnd.github+json' /repos/MystenLabs/sui/commits/${{ env.sui_sha }}/pulls --jq '.[].base.ref' | head -n 1)
        echo "sui_branch_name=${sui_branch_name}" >> $GITHUB_ENV
        echo "sui_branch_name_url=$(echo ${sui_branch_name} | sed 's\/\%2F\g')" >> $GITHUB_ENV

    - name: Get link to logs
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        gh_job_link=$(gh api -X GET 'repos/MystenLabs/sui/actions/runs/${{ github.run_id }}/jobs' --jq '.jobs.[0].html_url')
        echo "gh_job_link=${gh_job_link}" >> $GITHUB_ENV

    - name: Get current oncall from PagerDuty
      run: |
        # Fetch oncall info including user details (for email)
        response=$(curl -s --max-time 30 --request GET \
          --url 'https://api.pagerduty.com/oncalls?schedule_ids[]=PGCQ3YS&include[]=users' \
          --header 'Accept: application/json' \
          --header 'Authorization: Token token=${{ secrets.PAGERDUTY_ACCESS_KEY }}' \
          --header 'Content-Type: application/json')

        oncall_email=$(echo "$response" | jq -r '.oncalls[0].user.email // empty')
        oncall_name=$(echo "$response" | jq -r '.oncalls[0].escalation_policy.summary // empty')

        echo "oncall_email=${oncall_email}" >> "$GITHUB_ENV"
        echo "oncall_name=${oncall_name}" >> "$GITHUB_ENV"

        if [ -z "$oncall_email" ]; then
          echo "::warning::Could not get oncall email from PagerDuty"
        fi

    - name: Get Slack ID for oncall
      run: |
        if [ -z "${{ env.oncall_email }}" ]; then
          echo "::warning::No oncall email available, skipping Slack lookup"
          echo "slack_id=" >> "$GITHUB_ENV"
          exit 0
        fi

        # URL-encode the email for the API call
        encoded_email=$(printf '%s' "${{ env.oncall_email }}" | jq -sRr @uri)

        # Lookup Slack ID from email
        slack_response=$(curl -s --max-time 30 "https://slack.com/api/users.lookupByEmail?email=${encoded_email}" \
          -H "Authorization: Bearer ${{ secrets.SLACK_BOT_TOKEN }}")

        slack_ok=$(echo "$slack_response" | jq -r '.ok')
        slack_id=$(echo "$slack_response" | jq -r '.user.id // empty')

        if [ "$slack_ok" != "true" ]; then
          error=$(echo "$slack_response" | jq -r '.error')
          echo "::warning::Slack lookup failed for ${{ env.oncall_email }}: ${error}"
          echo "slack_id=" >> "$GITHUB_ENV"
          exit 0
        fi

        echo "slack_id=${slack_id}" >> "$GITHUB_ENV"

    - name: Post to slack
      uses: slackapi/slack-github-action@91efab103c0de0a537f72a35f6b8cda0ee76bf0a # pin@v2.1.1
      env:
        SUI_SHA: ${{ env.sui_sha }}
        SUI_BRANCH_NAME: ${{ env.sui_branch_name }}
        SUI_BRANCH_NAME_URL: ${{ env.sui_branch_name_url }}
        GH_JOB_LINK: ${{ env.gh_job_link }}
        SLACK_ID: ${{ env.slack_id }}
        ONCALL_NAME: ${{ env.oncall_name }}
      with:
        method: chat.postMessage
        token: ${{ secrets.SLACK_BOT_TOKEN }}
        payload: |
          channel: "code-coverage"
          text: |
            *${{ github.workflow }}* workflow status: `${{ env.WORKFLOW_CONCLUSION }}`
            Sui commit: <https://github.com/MystenLabs/sui/commit/${{ env.SUI_SHA }}|${{ env.SUI_SHA }}>
            Sui branch: `${{ env.SUI_BRANCH_NAME }}`
            Run: <${{ env.GH_JOB_LINK }}|${{ github.run_id }}>
            <@${{ env.SLACK_ID }}>, current `${{ env.ONCALL_NAME }}` oncall, please look over the code coverage <https://app.codecov.io/github/MystenLabs/sui/tree/${{ env.SUI_BRANCH_NAME_URL }}|report> for the `${{ env.SUI_BRANCH_NAME }}` branch in Sui repo, to manually check if there are coverage regressions.
