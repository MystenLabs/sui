/// BigQueue is an arbitrary sized queue-like data structure.
///
/// Elements in the queue are distributed between a "head" vector, a
/// "tail" vector, and a linked table to hold everything in between.
///
/// Amortized constant time push, pop, and peek are supported and an
/// efficient on-chain layout spreads the cost of dynamic field loads
/// by batching multiple elements into each node in the linked table.
module deepbook::big_queue {
    use std::option::{Self, Option};
    use std::vector;
    use sui::linked_table::{Self, LinkedTable};
    use sui::tx_context::TxContext;

    struct BigQueue<E: store> has store {
        /// Number of elements in the queue.
        length: u64,

        /// Maximum number of elements held in a contiguous array.
        max_slice_size: u64,

        /// Next ID used for allocating sub-slices.
        next_id: u64,

        /// The front of the queue.  This is never `option::none()`
        /// but uses `Option` for indirection, to swap elements in and
        /// out.  Elements in `head` are in reverse insertion order,
        /// so that popping `head` removes elements in insertion
        /// order.
        head: Option<vector<E>>,

        /// The back of the queue.  Like `head`, this is never
        /// `option::none()`.
        tail: Option<vector<E>>,

        /// The middle of the queue, stored in batches of
        /// `max_slice_size`.  The keys to this table are generated by
        /// bumping `next_id` and don't serve a purpose other than as
        /// a way to disambiguate slices.
        ///
        /// When the `tail` is about to exceed the max size, it is
        /// pushed into `spill`, and when `head` is emptied, it is
        /// refilled from `spill`.
        spill: LinkedTable<NodeRef, vector<E>>,
    }

    struct NodeRef has copy, drop, store { id: u64 }

    // === Error Codes ===

    /// BigQueue is not empty.
    const ENotEmpty: u64 = 0;

    /// Attempt to pop an empty queue
    const EOutOfBounds: u64 = 1;

    /// Max Slice Size provided is too small.
    const ESliceTooSmall: u64 = 2;

    /// Max Slice Size provided is too big.
    const ESliceTooBig: u64 = 3;

    /// Internal error while spilling
    const EInternalSpillError: u64 = 4;

    // === Constants ===

    /// `BigQueue` will not store contiguous sequences of elements
    /// bigger than this.
    const MAX_SLICE_SIZE: u64 = 262_144;

    // === Constructors ==

    /// Create a new `BigQueue` that stores at most `max_slice_size`
    /// elements in a contiguous vector.  Fails if `max_slice_size` is
    /// zero or too big.
    public fun new<E: store>(
        max_slice_size: u64,
        ctx: &mut TxContext,
    ): BigQueue<E> {
        assert!(0 < max_slice_size, ESliceTooSmall);
        assert!(max_slice_size <= MAX_SLICE_SIZE, ESliceTooBig);

        BigQueue {
            length: 0,
            max_slice_size,

            next_id: 0,

            head: option::some(vector[]),
            tail: option::some(vector[]),

            spill: linked_table::new(ctx),
        }
    }

    // === Destructors ===

    /// Destroy `self` as long as it is empty, even if its elements
    /// are not droppable.  Fails if `self` is not empty.
    public fun destroy_empty<E: store>(self: BigQueue<E>) {
        let BigQueue {
            length,
            max_slice_size: _,

            next_id: _,

            head,
            tail,
            spill,
        } = self;

        assert!(length == 0, ENotEmpty);

        let head = option::destroy_some(head);
        let tail = option::destroy_some(tail);

        vector::destroy_empty(head);
        vector::destroy_empty(tail);
        linked_table::destroy_empty(spill);
    }

    /// Destroy `self`, even if it contains elements, as long as they
    /// are droppable.
    public fun drop<E: store + drop>(self: BigQueue<E>) {
        let BigQueue {
            length: _,
            max_slice_size: _,

            next_id: _,

            head: _,
            tail: _,
            spill,
        } = self;

        linked_table::drop(spill);
    }

    // === Accessors ===

    /// Whether `self` contains no elements.
    public fun is_empty<E: store>(self: &BigQueue<E>): bool {
        self.length == 0
    }

    /// The number of elements contained in `self`.
    public fun length<E: store>(self: &BigQueue<E>): u64 {
        self.length
    }

    /// Access the first element of the queue without popping it.
    /// Fails if the queue is empty.
    public fun peek_front<E: store>(self: &BigQueue<E>): &E {
        nth(self, 0)
    }

    /// Mutably access the first element of the queue without popping
    /// it.  Fails if the queue is empty.
    public fun peek_front_mut<E: store>(self: &mut BigQueue<E>): &mut E {
        nth_mut(self, 0)
    }

    /// Access the element that is `ix` elements away from the head of
    /// the queue.  Fails if `ix` is beyond the end of the queue.
    public fun nth<E: store>(self: &BigQueue<E>, ix: u64): &E {
        assert!(ix < self.length, EOutOfBounds);

        let head = option::borrow(&self.head);
        let head_len = vector::length(head);
        if (ix < head_len) {
            return vector::borrow(head, head_len - 1 - ix)
        } else {
            ix = ix - head_len;
        };

        let spill_len = linked_table::length(&self.spill) * self.max_slice_size;
        if (ix < spill_len) {
            let front = option::borrow(linked_table::front(&self.spill)).id;
            let s_ref = NodeRef { id: front + ix / self.max_slice_size };
            let slice = linked_table::borrow(&self.spill, s_ref);
            return vector::borrow(slice, ix % self.max_slice_size)
        } else {
            ix = ix - spill_len;
        };

        let tail = option::borrow(&self.tail);
        vector::borrow(tail, ix)
    }

    /// Mutably access the element that is `ix` elements away from the
    /// head of the queue.  Fails if `ix` is beyond the end of the
    /// queue.
    public fun nth_mut<E: store>(self: &mut BigQueue<E>, ix: u64): &mut E {
        assert!(ix < self.length, EOutOfBounds);

        let head = option::borrow_mut(&mut self.head);
        let head_len = vector::length(head);
        if (ix < head_len) {
            return vector::borrow_mut(head, head_len - 1 - ix)
        } else {
            ix = ix - head_len;
        };

        let spill_len = linked_table::length(&self.spill) * self.max_slice_size;
        if (ix < spill_len) {
            let front = option::borrow(linked_table::front(&self.spill)).id;
            let s_ref = NodeRef { id: front + ix / self.max_slice_size };
            let slice = linked_table::borrow_mut(&mut self.spill, s_ref);
            return vector::borrow_mut(slice, ix % self.max_slice_size)
        } else {
            ix = ix - spill_len;
        };

        let tail = option::borrow_mut(&mut self.tail);
        vector::borrow_mut(tail, ix)
    }

    // === Mutators ===

    /// Remove the first element in the queue, `self`, and return it.
    /// Fails if the queue is empty.
    public fun pop_front<E: store>(self: &mut BigQueue<E>): E {
        assert!(self.length > 0, EOutOfBounds);
        ensure_head(self);

        self.length = self.length - 1;
        // the head vector is reversed, i.e. back-to-front.
        vector::pop_back(option::borrow_mut(&mut self.head))
    }

    /// Add `v` as a new element to the end of the queue, `self`.
    public fun push_back<E: store>(self: &mut BigQueue<E>, v: E) {
        ensure_tail(self);

        self.length = self.length + 1;
        let tail = option::borrow_mut(&mut self.tail);
        vector::push_back(tail, v);
    }

    // === Private Helpers ===

    /// Makes sure there is an element in the head, assuming the queue
    /// is non-empty.
    fun ensure_head<E: store>(self: &mut BigQueue<E>) {
        if (!vector::is_empty(option::borrow(&self.head))) {
            return
        };

        let next = if (linked_table::is_empty(&self.spill)) {
            // SAFETY: Previous checks imply the tail is non-empty.
            // Take directly from there to avoid a potentially
            // non-maximal sized slice entering the spill.
            take_tail(self)
        } else {
            let (_, next) = linked_table::pop_front(&mut self.spill);
            next
        };

        vector::reverse(&mut next);
        let empty = option::swap(&mut self.head, next);
        vector::destroy_empty(empty);
    }

    /// Makes sure there is space in the tail to accept an element.
    fun ensure_tail<E: store>(self: &mut BigQueue<E>) {
        if (vector::length(option::borrow(&self.tail)) < self.max_slice_size) {
            return
        };

        let tail = take_tail(self);
        let id = self.next_id;
        self.next_id = self.next_id + 1;

        linked_table::push_back(
            &mut self.spill,
            NodeRef { id },
            tail,
        );
    }

    /// Take (and return) the current tail, replacing it with an empty
    /// one.  Fails if the current tail is empty.
    fun take_tail<E: store>(self: &mut BigQueue<E>): vector<E>  {
        let tail = option::swap(&mut self.tail, vector[]);
        assert!(!vector::is_empty(&tail), EInternalSpillError);
        tail
    }

    // === Tests ===

    #[test_only] use sui::tx_context;

    #[test]
    fun test_destroy_empty() {
        let c = tx_context::dummy();
        let q = new<u64>(4, &mut c);

        destroy_empty(q);
    }

    #[test]
    #[expected_failure(abort_code = ENotEmpty)]
    fun test_destroy_non_empty() {
        let c = tx_context::dummy();
        let q = new(4, &mut c);

        push_back(&mut q, 42);
        destroy_empty(q);
    }

    #[test]
    #[expected_failure(abort_code = ESliceTooSmall)]
    fun test_empty_slice() {
        let c = tx_context::dummy();
        let _q = new<u64>(0, &mut c);
        abort 1337
    }

    #[test]
    #[expected_failure(abort_code = ESliceTooBig)]
    fun test_huge_slice() {
        let c = tx_context::dummy();
        let _q = new<u64>(MAX_SLICE_SIZE + 1, &mut c);
        abort 1337
    }

    #[test]
    #[expected_failure(abort_code = EOutOfBounds)]
    fun test_pop_empty() {
        let c = tx_context::dummy();
        let q = new<u64>(4, &mut c);
        let _ = pop_front(&mut q);
        abort 1337
    }

    #[test]
    fun test_one_slice() {
        let c = tx_context::dummy();
        let q = new(4, &mut c);

        push_back(&mut q, 42);
        push_back(&mut q, 43);
        push_back(&mut q, 44);
        push_back(&mut q, 45);

        assert!(pop_front(&mut q) == 42, 0);
        assert!(pop_front(&mut q) == 43, 0);
        assert!(pop_front(&mut q) == 44, 0);
        assert!(pop_front(&mut q) == 45, 0);

        drop(q);
    }

    #[test]
    fun test_via_spill() {
        let c = tx_context::dummy();
        let q = new(4, &mut c);

        push_back(&mut q, 42);
        push_back(&mut q, 43);
        push_back(&mut q, 44);
        push_back(&mut q, 45);

        // This causes a spill
        push_back(&mut q, 46);

        assert!(pop_front(&mut q) == 42, 0);
        assert!(pop_front(&mut q) == 43, 0);
        assert!(pop_front(&mut q) == 44, 0);
        assert!(pop_front(&mut q) == 45, 0);
        assert!(pop_front(&mut q) == 46, 0);

        drop(q);
    }

    #[test]
    fun test_spill_bubble() {
        let c = tx_context::dummy();
        let q = new(4, &mut c);

        push_back(&mut q, 42);
        push_back(&mut q, 43);
        push_back(&mut q, 44);
        push_back(&mut q, 45);

        // This pulls the tail through to the head.
        assert!(pop_front(&mut q) == 42, 0);
        assert!(pop_front(&mut q) == 43, 0);
        assert!(pop_front(&mut q) == 44, 0);

        // Put something else into the tail, so now there's an element
        // in the head and the tail.
        push_back(&mut q, 46);

        assert!(pop_front(&mut q) == 45, 0);
        assert!(pop_front(&mut q) == 46, 0);

        drop(q);
    }

    #[test]
    fun test_steady_state() {
        let c = tx_context::dummy();
        let q = new(4, &mut c);

        push_back(&mut q, 42);
        push_back(&mut q, 43);
        assert!(pop_front(&mut q) == 42, 0);
        push_back(&mut q, 44);
        assert!(pop_front(&mut q) == 43, 0);
        push_back(&mut q, 45);
        assert!(pop_front(&mut q) == 44, 0);
        push_back(&mut q, 46);
        assert!(pop_front(&mut q) == 45, 0);
        push_back(&mut q, 47);
        assert!(pop_front(&mut q) == 46, 0);
        push_back(&mut q, 48);
        assert!(pop_front(&mut q) == 47, 0);
        push_back(&mut q, 49);
        assert!(pop_front(&mut q) == 48, 0);
        assert!(pop_front(&mut q) == 49, 0);

        drop(q);
    }

    #[test]
    fun test_peek_head() {
        let c = tx_context::dummy();
        let q = new(4, &mut c);

        push_back(&mut q, 42);
        push_back(&mut q, 43);

        assert!(pop_front(&mut q) == 42, 0);

        // Next element has now made it into head, brought along with
        // the first element.
        assert!(*peek_front(&q) == 43, 0);

        *peek_front_mut(&mut q) = 53;
        assert!(pop_front(&mut q) == 53, 0);

        drop(q)
    }

    #[test]
    fun test_peek_spill() {
        let c = tx_context::dummy();
        let q = new(4, &mut c);

        push_back(&mut q, 42);
        push_back(&mut q, 43);
        push_back(&mut q, 44);
        push_back(&mut q, 45);

        // This causes a spill
        push_back(&mut q, 46);

        assert!(*peek_front(&q) == 42, 0);

        *peek_front_mut(&mut q) = 52;
        assert!(pop_front(&mut q) == 52, 0);

        drop(q)
    }

    #[test]
    fun test_peek_tail() {
        let c = tx_context::dummy();
        let q = new(4, &mut c);

        push_back(&mut q, 42);
        assert!(*peek_front(&q) == 42, 0);

        *peek_front_mut(&mut q) = 52;
        assert!(pop_front(&mut q) == 52, 0);

        drop(q)
    }

    #[test]
    fun test_nth() {
        let c = tx_context::dummy();
        let q = new(4, &mut c);

        push_back(&mut q, 42);
        push_back(&mut q, 43);

        assert!(*nth(&q, 0) == 42, 0);
        assert!(*nth(&q, 1) == 43, 0);
        *nth_mut(&mut q, 1) = 53;

        // Moves tail to head.
        assert!(pop_front(&mut q) == 42, 0);

        push_back(&mut q, 44);
        push_back(&mut q, 45);
        push_back(&mut q, 46);
        push_back(&mut q, 47);

        // This causes a spill
        push_back(&mut q, 48);

        assert!(*nth(&q, 0) == 53, 0);
        assert!(*nth(&q, 1) == 44, 0);
        assert!(*nth(&q, 2) == 45, 0);
        assert!(*nth(&q, 5) == 48, 0);

        *nth_mut(&mut q, 2) = 55;
        *nth_mut(&mut q, 5) = 58;

        assert!(pop_front(&mut q) == 53, 0);
        assert!(pop_front(&mut q) == 44, 0);
        assert!(pop_front(&mut q) == 55, 0);
        assert!(pop_front(&mut q) == 46, 0);
        assert!(pop_front(&mut q) == 47, 0);
        assert!(pop_front(&mut q) == 58, 0);

        drop(q);
    }

    #[test]
    #[expected_failure(abort_code = EOutOfBounds)]
    fun test_nth_empty() {
        let c = tx_context::dummy();
        let q = new<u64>(4, &mut c);
        nth(&q, 0);

        abort 1337
    }

    #[test]
    #[expected_failure(abort_code = EOutOfBounds)]
    fun test_nth_popped() {
        let c = tx_context::dummy();
        let q = new(4, &mut c);

        push_back(&mut q, 42);
        push_back(&mut q, 43);

        assert!(pop_front(&mut q) == 42, 0);
        nth(&q, 1);

        abort 1337
    }
}
