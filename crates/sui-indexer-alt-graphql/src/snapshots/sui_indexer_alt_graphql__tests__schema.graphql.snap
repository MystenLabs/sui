---
source: crates/sui-indexer-alt-graphql/src/lib.rs
expression: sdl
---
type Query {
	"""
	Configuration for this RPC service.
	"""
	serviceConfig: ServiceConfig!
	"""
	Test query that always succeeds
	"""
	hello: String!
	"""
	Test query that always fails
	"""
	boom: String!
	"""
	Test query that fails with an internal error
	"""
	uhOh: String!
	"""
	Test query that times out
	"""
	tickTock: String!
	"""
	Test query that can be used to test simulate nesting.
	"""
	dot: Query!
}

type ServiceConfig {
	"""
	Maximum time in milliseconds spent waiting for a response from fullnode after issuing a transaction to execute. Note that the transaction may still succeed even in the case of a timeout. Transactions are idempotent, so a transaction that times out should be re-submitted until the network returns a definite response (success or failure, not timeout).
	"""
	mutationTimeoutMs: Int!
	"""
	Maximum time in milliseconds that will be spent to serve one query request.
	"""
	queryTimeoutMs: Int!
	"""
	Maximum depth of a GraphQL query that can be accepted by this service.
	"""
	maxQueryDepth: Int!
	"""
	The maximum number of nodes (field names) the service will accept in a single query.
	"""
	maxQueryNodes: Int!
	"""
	Maximum number of estimated output nodes in a GraphQL response.
	
	The estimate is an upperbound of how many nodes there would be in the output assuming every requested field is present, paginated requests return full page sizes, and multi-get queries find all requested keys. Below is a worked example query:
	
	```graphql
	|  0: query {                            # 514 = total
	|  1:   checkpoint {                     # 1
	|  2:     sequenceNumber                 # 1
	|  3:   }
	|  4:
	|  5:   multiGetObjects([$a, $b, $c]) {  # 1 (* 3)
	|  6:     address                        # 3
	|  7:     digest                         # 3
	|  8:   }
	|  9:
	| 10:   # default page size is 20
	| 11:   transactions {                   # 1 (* 20)
	| 12:     pageInfo {                     # 1
	| 13:       hasNextPage                  # 1
	| 14:       endCursor                    # 1
	| 15:     }
	| 16:
	| 17:     nodes                          # 1
	| 18:     {                              # 20
	| 19:       digest                       # 20
	| 20:       effects {                    # 20
	| 21:         objectChanges(first: 10) { # 20 (* 10)
	| 22:           nodes                    # 20
	| 23:           {                        # 200
	| 24:             address                # 200
	| 25:           }
	| 26:         }
	| 27:       }
	| 28:     }
	| 29:   }
	| 30: }
	```
	"""
	maxOutputNodes: Int!
	"""
	Maximum size in bytes allowed for the `txBytes` and `signatures` parameters of an `executeTransaction` or `simulateTransaction` field, or the `bytes` and `signature` parameters of a `verifyZkLoginSignature` field.
	
	This is cumulative across all matching fields in a single GraphQL request.
	"""
	maxTransactionPayloadSize: Int!
	"""
	Maximum size in bytes of a single GraphQL request, excluding the elements covered by `maxTransactionPayloadSize`.
	"""
	maxQueryPayloadSize: Int!
	"""
	Returns the number of elements a paginated connection will return if a page size is not supplied.
	
	Accepts `type` and `field` arguments which identify the connection that is being queried. If the field in question is paginated, its default page size is returned. If it does not exist or is not paginated, `null` is returned.
	"""
	defaultPageSize(type: String!, field: String!): Int
	"""
	Returns the maximum number of elements that can be requested from a paginated connection. A request to fetch more elements will result in an error.
	
	Accepts `type` and `field` arguments which identify the connection that is being queried. If the field in question is paginated, its max page size is returned. If it does not exist or is not paginated, `null` is returned.
	"""
	maxPageSize(type: String!, field: String!): Int
}


directive @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
directive @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
schema {
	query: Query
}
