// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

syntax = "proto3";

package sui.rpc.v2alpha;

import "google/protobuf/field_mask.proto";
import "sui/rpc/v2beta/executed_transaction.proto";
import "sui/rpc/v2beta/transaction.proto";

service LiveDataService {
  rpc ListDynamicFields(ListDynamicFieldsRequest) returns (ListDynamicFieldsResponse);
  rpc ListOwnedObjects(ListOwnedObjectsRequest) returns (ListOwnedObjectsResponse);
  rpc GetCoinInfo(GetCoinInfoRequest) returns (GetCoinInfoResponse);
  // get balance? list balance?

  rpc SimulateTransaction(SimulateTransactionRequest) returns (SimulateTransactionResponse);
  rpc ResolveTransaction(ResolveTransactionRequest) returns (ResolveTransactionResponse);
  // ViewFunction?
}

// Request message for `NodeService.GetCoinInfo`.
message GetCoinInfoRequest {
  // The coin type to request information about
  optional string coin_type = 1;
}

// Response message for `NodeService.GetCoinInfo`.
message GetCoinInfoResponse {
  // Required. The coin type.
  optional string coin_type = 1;

  // This field will be populated with information about this coin
  // type's `0x2::coin::CoinMetadata` if it exists and has not been wrapped.
  optional CoinMetadata metadata = 2;

  // This field will be populated with information about this coin
  // type's `0x2::coin::TreasuryCap` if it exists and has not been wrapped.
  optional CoinTreasury treasury = 3;

  // TODO add support for tracking RegulatedCoinMetadata
  // If this coin type is a regulated coin, this field will be
  // populated with information about its `0x2::coin::RegulatedCoinMetadata`
  // object.
  // optional RegulatedCoinMetadata regulated_metadata = 4;
}

// Metadata for a coin type
message CoinMetadata {
  // ObjectId of the `0x2::coin::CoinMetadata` object.
  optional string id = 1;
  // Number of decimal places to coin uses.
  optional uint32 decimals = 2;
  // Name for the token
  optional string name = 3;
  // Symbol for the token
  optional string symbol = 4;
  // Description of the token
  optional string description = 5;
  // URL for the token logo
  optional string icon_url = 6;
}

// Information about a coin type's `0x2::coin::TreasuryCap` and its total available supply
message CoinTreasury {
  // ObjectId of the `0x2::coin::TreasuryCap` object.
  optional string id = 1;
  // Total available supply for this coin type.
  optional uint64 total_supply = 2;
}

// Information about a regulated coin, which indicates that it makes use of the transfer deny list.
message RegulatedCoinMetadata {
  // ObjectId of the `0x2::coin::RegulatedCoinMetadata` object.
  optional string id = 1;
  // The ID of the coin's `CoinMetadata` object.
  optional string coin_metadata_object = 2;
  // The ID of the coin's `DenyCap` object.
  optional string deny_cap_object = 3;
}

// Request message for `NodeService.ListDynamicFields`
message ListDynamicFieldsRequest {
  // Required. The `UID` of the parent, which owns the collections of dynamic fields.
  optional string parent = 1;

  // The maximum number of dynamic fields to return. The service may return fewer than this value.
  // If unspecified, at most `50` entries will be returned.
  // The maximum value is `1000`; values above `1000` will be coerced to `1000`.
  optional uint32 page_size = 2;

  // A page token, received from a previous `ListDynamicFields` call.
  // Provide this to retrieve the subsequent page.
  //
  // When paginating, all other parameters provided to `ListDynamicFields` must
  // match the call that provided the page token.
  optional bytes page_token = 3;
}

// Response message for `NodeService.ListDynamicFields`
message ListDynamicFieldsResponse {
  // Page of dynamic fields owned by the specified parent.
  repeated DynamicField dynamic_fields = 1;

  // A token, which can be sent as `page_token` to retrieve the next page.
  // If this field is omitted, there are no subsequent pages.
  optional bytes next_page_token = 2;
}

message DynamicField {
  // Required. ObjectId of this dynamic field's parent.
  optional string parent = 1;

  // Required. ObjectId of this dynamic field.
  optional string field_id = 2;

  // Required. The type of the dynamic field "name"
  optional string name_type = 3;

  // Required. The serialized move value of "name"
  optional bytes name_value = 4;

  // The ObjectId of the child object when a child is a dynamic
  // object field.
  //
  // The presence or absence of this field can be used to determine if a child
  // is a dynamic field or a dynamic child object
  optional string dynamic_object_id = 5;

  //TODO we should have type information on the object
}

message SimulateTransactionRequest {
  optional sui.rpc.v2beta.Transaction transaction = 1;
  optional google.protobuf.FieldMask read_mask = 2;
}

message SimulateTransactionResponse {
  optional sui.rpc.v2beta.ExecutedTransaction transaction = 1;
}

message ResolveTransactionRequest {
  // optional sui.rpc.v2beta.Transaction unresolved_transaction = 1;
  // TODO FIX TYPE
  // Json unresolved transaction type
  optional string unresolved_transaction = 1;
  optional google.protobuf.FieldMask read_mask = 2;
}

message ResolveTransactionResponse {
  optional sui.rpc.v2beta.Transaction transaction = 1;
  optional SimulateTransactionResponse simulation = 2;
}

message ListOwnedObjectsRequest {
  // Required. The address of the account that owns the objects.
  optional string owner = 1;

  // The maximum number of entries return. The service may return fewer than this value.
  // If unspecified, at most `50` entries will be returned.
  // The maximum value is `1000`; values above `1000` will be coerced to `1000`.
  optional uint32 page_size = 2;

  // A page token, received from a previous `ListOwnedObjects` call.
  // Provide this to retrieve the subsequent page.
  //
  // When paginating, all other parameters provided to `ListOwnedObjects` must
  // match the call that provided the page token.
  optional bytes page_token = 3;
}

message ListOwnedObjectsResponse {
  // Page of dynamic fields owned by the specified parent.
  repeated OwnedObject objects = 1;

  // A token, which can be sent as `page_token` to retrieve the next page.
  // If this field is omitted, there are no subsequent pages.
  optional bytes next_page_token = 2;
}

message OwnedObject {
  optional string owner = 1;
  optional string object_id = 2;
  optional uint64 version = 3;
  optional string object_type = 4;
}
