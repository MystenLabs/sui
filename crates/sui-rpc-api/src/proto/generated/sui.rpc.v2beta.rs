// This file is @generated by prost-build.
/// An argument to a programmable transaction command.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Argument {
    #[prost(enumeration = "argument::ArgumentKind", optional, tag = "1")]
    pub kind: ::core::option::Option<i32>,
    /// Index of an input or the result of another command based on `kind`.
    #[prost(uint32, optional, tag = "2")]
    pub index: ::core::option::Option<u32>,
    /// Used to access a nested result when `kind` is `RESULT`.
    #[prost(uint32, optional, tag = "3")]
    pub subresult: ::core::option::Option<u32>,
}
/// Nested message and enum types in `Argument`.
pub mod argument {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ArgumentKind {
        Unknown = 0,
        /// The gas coin.
        Gas = 1,
        /// One of the input objects or primitive values (from
        /// `ProgrammableTransaction` inputs).
        Input = 2,
        /// The result of another command (from `ProgrammableTransaction` commands).
        Result = 3,
    }
    impl ArgumentKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "ARGUMENT_KIND_UNKNOWN",
                Self::Gas => "GAS",
                Self::Input => "INPUT",
                Self::Result => "RESULT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ARGUMENT_KIND_UNKNOWN" => Some(Self::Unknown),
                "GAS" => Some(Self::Gas),
                "INPUT" => Some(Self::Input),
                "RESULT" => Some(Self::Result),
                _ => None,
            }
        }
    }
}
/// The delta, or change, in balance for an address for a particular `Coin` type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BalanceChange {
    /// The account address that is affected by this balance change event.
    #[prost(string, optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    /// The `Coin` type of this balance change event.
    #[prost(string, optional, tag = "2")]
    pub coin_type: ::core::option::Option<::prost::alloc::string::String>,
    /// The amount or change in balance.
    #[prost(string, optional, tag = "3")]
    pub amount: ::core::option::Option<::prost::alloc::string::String>,
}
/// `Bcs` contains an arbitrary type that is serialized using the
/// [BCS](<https://mystenlabs.github.io/sui-rust-sdk/sui_sdk_types/index.html#bcs>)
/// format as well as a name that identifies the type of the serialized value.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bcs {
    /// Name that identifies the type of the serialized value.
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Bytes of a BCS serialized value.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub value: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Checkpoint {
    /// The height of this checkpoint.
    #[prost(uint64, optional, tag = "1")]
    pub sequence_number: ::core::option::Option<u64>,
    /// The digest of this Checkpoint's CheckpointSummary.
    #[prost(string, optional, tag = "2")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The `CheckpointSummary` for this checkpoint.
    #[prost(message, optional, tag = "3")]
    pub summary: ::core::option::Option<CheckpointSummary>,
    /// An aggregated quorum signature from the validator committee that
    /// certified this checkpoint.
    #[prost(message, optional, tag = "4")]
    pub signature: ::core::option::Option<ValidatorAggregatedSignature>,
    /// The `CheckpointContents` for this checkpoint.
    #[prost(message, optional, tag = "5")]
    pub contents: ::core::option::Option<CheckpointContents>,
    /// List of transactions included in this checkpoint.
    #[prost(message, repeated, tag = "6")]
    pub transactions: ::prost::alloc::vec::Vec<ExecutedTransaction>,
}
/// The committed to contents of a checkpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointContents {
    /// This CheckpointContents serialized as BCS.
    #[prost(message, optional, tag = "1")]
    pub bcs: ::core::option::Option<Bcs>,
    /// The digest of this CheckpointContents.
    #[prost(string, optional, tag = "2")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of this CheckpointContents
    #[prost(int32, optional, tag = "3")]
    pub version: ::core::option::Option<i32>,
    /// Set of transactions committed to in this checkpoint.
    #[prost(message, repeated, tag = "4")]
    pub transactions: ::prost::alloc::vec::Vec<CheckpointedTransactionInfo>,
}
/// Transaction information committed to in a checkpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointedTransactionInfo {
    /// Digest of the transaction.
    #[prost(string, optional, tag = "1")]
    pub transaction: ::core::option::Option<::prost::alloc::string::String>,
    /// Digest of the effects.
    #[prost(string, optional, tag = "2")]
    pub effects: ::core::option::Option<::prost::alloc::string::String>,
    /// Set of user signatures that authorized the transaction.
    #[prost(message, repeated, tag = "3")]
    pub signatures: ::prost::alloc::vec::Vec<UserSignature>,
}
/// A header for a checkpoint on the Sui blockchain.
///
/// On the Sui network, checkpoints define the history of the blockchain. They are quite similar to
/// the concept of blocks used by other blockchains like Bitcoin or Ethereum. The Sui blockchain,
/// however, forms checkpoints after transaction execution has already happened to provide a
/// certified history of the chain, instead of being formed before execution.
///
/// Checkpoints commit to a variety of state, including but not limited to:
/// - The hash of the previous checkpoint.
/// - The set of transaction digests, their corresponding effects digests, as well as the set of
///    user signatures that authorized its execution.
/// - The objects produced by a transaction.
/// - The set of live objects that make up the current state of the chain.
/// - On epoch transitions, the next validator committee.
///
/// `CheckpointSummary`s themselves don't directly include all of the previous information but they
/// are the top-level type by which all the information is committed to transitively via cryptographic
/// hashes included in the summary. `CheckpointSummary`s are signed and certified by a quorum of
/// the validator committee in a given epoch to allow verification of the chain's state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointSummary {
    /// This CheckpointSummary serialized as BCS.
    #[prost(message, optional, tag = "1")]
    pub bcs: ::core::option::Option<Bcs>,
    /// The digest of this CheckpointSummary.
    #[prost(string, optional, tag = "2")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Epoch that this checkpoint belongs to.
    #[prost(uint64, optional, tag = "3")]
    pub epoch: ::core::option::Option<u64>,
    /// The height of this checkpoint.
    #[prost(uint64, optional, tag = "4")]
    pub sequence_number: ::core::option::Option<u64>,
    /// Total number of transactions committed since genesis, including those in this
    /// checkpoint.
    #[prost(uint64, optional, tag = "5")]
    pub total_network_transactions: ::core::option::Option<u64>,
    /// The hash of the `CheckpointContents` for this checkpoint.
    #[prost(string, optional, tag = "6")]
    pub content_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The hash of the previous `CheckpointSummary`.
    ///
    /// This will be `None` only for the first, or genesis, checkpoint.
    #[prost(string, optional, tag = "7")]
    pub previous_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The running total gas costs of all transactions included in the current epoch so far
    /// until this checkpoint.
    #[prost(message, optional, tag = "8")]
    pub epoch_rolling_gas_cost_summary: ::core::option::Option<GasCostSummary>,
    /// Timestamp of the checkpoint - number of milliseconds from the Unix epoch
    /// Checkpoint timestamps are monotonic, but not strongly monotonic - subsequent
    /// checkpoints can have the same timestamp if they originate from the same underlining consensus commit.
    #[prost(message, optional, tag = "9")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Commitments to checkpoint-specific state.
    #[prost(message, repeated, tag = "10")]
    pub commitments: ::prost::alloc::vec::Vec<CheckpointCommitment>,
    /// Extra data only present in the final checkpoint of an epoch.
    #[prost(message, optional, tag = "11")]
    pub end_of_epoch_data: ::core::option::Option<EndOfEpochData>,
    /// `CheckpointSummary` is not an evolvable structure - it must be readable by any version of
    /// the code. Therefore, to allow extensions to be added to `CheckpointSummary`,
    /// opaque data can be added to checkpoints, which can be deserialized based on the current
    /// protocol version.
    #[prost(bytes = "bytes", optional, tag = "12")]
    pub version_specific_data: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Data, which when included in a `CheckpointSummary`, signals the end of an `Epoch`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndOfEpochData {
    /// The set of validators that will be in the `ValidatorCommittee` for the next epoch.
    #[prost(message, repeated, tag = "1")]
    pub next_epoch_committee: ::prost::alloc::vec::Vec<ValidatorCommitteeMember>,
    /// The protocol version that is in effect during the next epoch.
    #[prost(uint64, optional, tag = "2")]
    pub next_epoch_protocol_version: ::core::option::Option<u64>,
    /// Commitments to epoch specific state (live object set)
    #[prost(message, repeated, tag = "3")]
    pub epoch_commitments: ::prost::alloc::vec::Vec<CheckpointCommitment>,
}
/// A commitment made by a checkpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointCommitment {
    #[prost(
        enumeration = "checkpoint_commitment::CheckpointCommitmentKind",
        optional,
        tag = "1"
    )]
    pub kind: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `CheckpointCommitment`.
pub mod checkpoint_commitment {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CheckpointCommitmentKind {
        Unknown = 0,
        /// An elliptic curve multiset hash attesting to the set of objects that
        /// comprise the live state of the Sui blockchain.
        EcmhLiveObjectSet = 1,
    }
    impl CheckpointCommitmentKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "CHECKPOINT_COMMITMENT_KIND_UNKNOWN",
                Self::EcmhLiveObjectSet => "ECMH_LIVE_OBJECT_SET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CHECKPOINT_COMMITMENT_KIND_UNKNOWN" => Some(Self::Unknown),
                "ECMH_LIVE_OBJECT_SET" => Some(Self::EcmhLiveObjectSet),
                _ => None,
            }
        }
    }
}
/// The effects of executing a transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionEffects {
    /// This TransactionEffects serialized as BCS.
    #[prost(message, optional, tag = "1")]
    pub bcs: ::core::option::Option<Bcs>,
    /// The digest of this TransactionEffects.
    #[prost(string, optional, tag = "2")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of this TransactionEffects.
    #[prost(int32, optional, tag = "3")]
    pub version: ::core::option::Option<i32>,
    /// The status of the execution.
    #[prost(message, optional, tag = "4")]
    pub status: ::core::option::Option<ExecutionStatus>,
    /// The epoch when this transaction was executed.
    #[prost(uint64, optional, tag = "5")]
    pub epoch: ::core::option::Option<u64>,
    /// The gas used by this transaction.
    #[prost(message, optional, tag = "6")]
    pub gas_used: ::core::option::Option<GasCostSummary>,
    /// The transaction digest.
    #[prost(string, optional, tag = "7")]
    pub transaction_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Information about the gas object. Also present in the `changed_objects` vector.
    ///
    /// System transaction that don't require gas will leave this as `None`.
    #[prost(message, optional, tag = "8")]
    pub gas_object: ::core::option::Option<ChangedObject>,
    /// The digest of the events emitted during execution,
    /// can be `None` if the transaction does not emit any event.
    #[prost(string, optional, tag = "9")]
    pub events_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The set of transaction digests this transaction depends on.
    #[prost(string, repeated, tag = "10")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The version number of all the written objects (excluding packages) by this transaction.
    #[prost(uint64, optional, tag = "11")]
    pub lamport_version: ::core::option::Option<u64>,
    /// Objects whose state are changed by this transaction.
    #[prost(message, repeated, tag = "12")]
    pub changed_objects: ::prost::alloc::vec::Vec<ChangedObject>,
    /// Shared objects that are not mutated in this transaction. Unlike owned objects,
    /// read-only shared objects' version are not committed in the transaction,
    /// and in order for a node to catch up and execute it without consensus sequencing,
    /// the version needs to be committed in the effects.
    #[prost(message, repeated, tag = "13")]
    pub unchanged_shared_objects: ::prost::alloc::vec::Vec<UnchangedSharedObject>,
    /// Auxiliary data that are not protocol-critical, generated as part of the effects but are stored separately.
    /// Storing it separately allows us to avoid bloating the effects with data that are not critical.
    /// It also provides more flexibility on the format and type of the data.
    #[prost(string, optional, tag = "14")]
    pub auxiliary_data_digest: ::core::option::Option<::prost::alloc::string::String>,
}
/// Input/output state of an object that was changed during execution.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangedObject {
    /// ID of the object.
    #[prost(string, optional, tag = "1")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "changed_object::InputObjectState", optional, tag = "2")]
    pub input_state: ::core::option::Option<i32>,
    /// Version of the object before this transaction executed.
    #[prost(uint64, optional, tag = "3")]
    pub input_version: ::core::option::Option<u64>,
    /// Digest of the object before this transaction executed.
    #[prost(string, optional, tag = "4")]
    pub input_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Owner of the object before this transaction executed.
    #[prost(message, optional, tag = "5")]
    pub input_owner: ::core::option::Option<Owner>,
    #[prost(enumeration = "changed_object::OutputObjectState", optional, tag = "6")]
    pub output_state: ::core::option::Option<i32>,
    /// Version of the object after this transaction executed.
    #[prost(uint64, optional, tag = "7")]
    pub output_version: ::core::option::Option<u64>,
    /// Digest of the object after this transaction executed.
    #[prost(string, optional, tag = "8")]
    pub output_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Owner of the object after this transaction executed.
    #[prost(message, optional, tag = "9")]
    pub output_owner: ::core::option::Option<Owner>,
    /// What happened to an `ObjectId` during execution.
    #[prost(enumeration = "changed_object::IdOperation", optional, tag = "10")]
    pub id_operation: ::core::option::Option<i32>,
    /// Type information is not provided by the effects structure but is instead
    /// provided by an indexing layer
    #[prost(string, optional, tag = "11")]
    pub object_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ChangedObject`.
pub mod changed_object {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InputObjectState {
        Unknown = 0,
        DoesNotExist = 1,
        Exists = 2,
    }
    impl InputObjectState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "INPUT_OBJECT_STATE_UNKNOWN",
                Self::DoesNotExist => "INPUT_OBJECT_STATE_DOES_NOT_EXIST",
                Self::Exists => "INPUT_OBJECT_STATE_EXISTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INPUT_OBJECT_STATE_UNKNOWN" => Some(Self::Unknown),
                "INPUT_OBJECT_STATE_DOES_NOT_EXIST" => Some(Self::DoesNotExist),
                "INPUT_OBJECT_STATE_EXISTS" => Some(Self::Exists),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OutputObjectState {
        Unknown = 0,
        DoesNotExist = 1,
        ObjectWrite = 2,
        PackageWrite = 3,
    }
    impl OutputObjectState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "OUTPUT_OBJECT_STATE_UNKNOWN",
                Self::DoesNotExist => "OUTPUT_OBJECT_STATE_DOES_NOT_EXIST",
                Self::ObjectWrite => "OUTPUT_OBJECT_STATE_OBJECT_WRITE",
                Self::PackageWrite => "OUTPUT_OBJECT_STATE_PACKAGE_WRITE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OUTPUT_OBJECT_STATE_UNKNOWN" => Some(Self::Unknown),
                "OUTPUT_OBJECT_STATE_DOES_NOT_EXIST" => Some(Self::DoesNotExist),
                "OUTPUT_OBJECT_STATE_OBJECT_WRITE" => Some(Self::ObjectWrite),
                "OUTPUT_OBJECT_STATE_PACKAGE_WRITE" => Some(Self::PackageWrite),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IdOperation {
        Unknown = 0,
        None = 1,
        Created = 2,
        Deleted = 3,
    }
    impl IdOperation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "ID_OPERATION_UNKNOWN",
                Self::None => "NONE",
                Self::Created => "CREATED",
                Self::Deleted => "DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ID_OPERATION_UNKNOWN" => Some(Self::Unknown),
                "NONE" => Some(Self::None),
                "CREATED" => Some(Self::Created),
                "DELETED" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
}
/// A shared object that wasn't changed during execution.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnchangedSharedObject {
    #[prost(
        enumeration = "unchanged_shared_object::UnchangedSharedObjectKind",
        optional,
        tag = "1"
    )]
    pub kind: ::core::option::Option<i32>,
    /// ObjectId of the shared object.
    #[prost(string, optional, tag = "2")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of the shared object.
    #[prost(uint64, optional, tag = "3")]
    pub version: ::core::option::Option<u64>,
    /// Digest of the shared object.
    #[prost(string, optional, tag = "4")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Type information is not provided by the effects structure but is instead
    /// provided by an indexing layer
    #[prost(string, optional, tag = "5")]
    pub object_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `UnchangedSharedObject`.
pub mod unchanged_shared_object {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UnchangedSharedObjectKind {
        Unknown = 0,
        /// Read-only shared object from the input.
        ReadOnlyRoot = 1,
        /// Deleted shared objects that appear mutably/owned in the input.
        MutateDeleted = 2,
        /// Deleted shared objects that appear as read-only in the input.
        ReadDeleted = 3,
        /// Shared objects that was congested and resulted in this transaction being
        /// canceled.
        Canceled = 4,
        /// Read of a per-epoch config object that should remain the same during an epoch.
        PerEpochConfig = 5,
    }
    impl UnchangedSharedObjectKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNCHANGED_SHARED_OBJECT_KIND_UNKNOWN",
                Self::ReadOnlyRoot => "READ_ONLY_ROOT",
                Self::MutateDeleted => "MUTATE_DELETED",
                Self::ReadDeleted => "READ_DELETED",
                Self::Canceled => "CANCELED",
                Self::PerEpochConfig => "PER_EPOCH_CONFIG",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNCHANGED_SHARED_OBJECT_KIND_UNKNOWN" => Some(Self::Unknown),
                "READ_ONLY_ROOT" => Some(Self::ReadOnlyRoot),
                "MUTATE_DELETED" => Some(Self::MutateDeleted),
                "READ_DELETED" => Some(Self::ReadDeleted),
                "CANCELED" => Some(Self::Canceled),
                "PER_EPOCH_CONFIG" => Some(Self::PerEpochConfig),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Epoch {
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// The committee governing this epoch.
    #[prost(message, optional, tag = "2")]
    pub committee: ::core::option::Option<ValidatorCommittee>,
    /// Reference gas price denominated in MIST
    #[prost(uint64, optional, tag = "8")]
    pub reference_gas_price: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "9")]
    pub protocol_config: ::core::option::Option<ProtocolConfig>,
}
/// Events emitted during the successful execution of a transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionEvents {
    /// This TransactionEvents serialized as BCS.
    #[prost(message, optional, tag = "1")]
    pub bcs: ::core::option::Option<Bcs>,
    /// The digest of this TransactionEvents.
    #[prost(string, optional, tag = "2")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Set of events emitted by a transaction.
    #[prost(message, repeated, tag = "3")]
    pub events: ::prost::alloc::vec::Vec<Event>,
}
/// An event.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    /// Package ID of the top-level function invoked by a `MoveCall` command that triggered this
    /// event to be emitted.
    #[prost(string, optional, tag = "1")]
    pub package_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Module name of the top-level function invoked by a `MoveCall` command that triggered this
    /// event to be emitted.
    #[prost(string, optional, tag = "2")]
    pub module: ::core::option::Option<::prost::alloc::string::String>,
    /// Address of the account that sent the transaction where this event was emitted.
    #[prost(string, optional, tag = "3")]
    pub sender: ::core::option::Option<::prost::alloc::string::String>,
    /// The type of the event emitted.
    #[prost(string, optional, tag = "4")]
    pub event_type: ::core::option::Option<::prost::alloc::string::String>,
    /// BCS serialized bytes of the event.
    #[prost(message, optional, tag = "5")]
    pub contents: ::core::option::Option<Bcs>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutedTransaction {
    /// The digest of this Transaction.
    #[prost(string, optional, tag = "1")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The transaction itself.
    #[prost(message, optional, tag = "2")]
    pub transaction: ::core::option::Option<Transaction>,
    /// List of user signatures that are used to authorize the
    /// execution of this transaction.
    #[prost(message, repeated, tag = "3")]
    pub signatures: ::prost::alloc::vec::Vec<UserSignature>,
    /// The `TransactionEffects` for this transaction.
    #[prost(message, optional, tag = "4")]
    pub effects: ::core::option::Option<TransactionEffects>,
    /// The `TransactionEvents` for this transaction.
    ///
    /// This field might be empty, even if it was explicitly requested, if the
    /// transaction didn't produce any events.
    /// `sui.types.TransactionEffects.events_digest` is populated if the
    /// transaction produced any events.
    #[prost(message, optional, tag = "5")]
    pub events: ::core::option::Option<TransactionEvents>,
    /// The sequence number for the checkpoint that includes this transaction.
    #[prost(uint64, optional, tag = "6")]
    pub checkpoint: ::core::option::Option<u64>,
    /// The Unix timestamp of the checkpoint that includes this transaction.
    #[prost(message, optional, tag = "7")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "8")]
    pub balance_changes: ::prost::alloc::vec::Vec<BalanceChange>,
    /// Set of input objects used during the execution of this transaction.
    #[prost(message, repeated, tag = "10")]
    pub input_objects: ::prost::alloc::vec::Vec<Object>,
    /// Set of output objects produced from the execution of this transaction.
    #[prost(message, repeated, tag = "11")]
    pub output_objects: ::prost::alloc::vec::Vec<Object>,
}
/// The status of an executed transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionStatus {
    /// Indicates if the transaction was successful or not.
    #[prost(bool, optional, tag = "1")]
    pub success: ::core::option::Option<bool>,
    /// The error if `success` is false.
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<ExecutionError>,
}
/// An error that can occur during the execution of a transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionError {
    /// The command, if any, during which the error occurred.
    #[prost(uint64, optional, tag = "1")]
    pub command: ::core::option::Option<u64>,
    #[prost(enumeration = "execution_error::ExecutionErrorKind", optional, tag = "2")]
    pub kind: ::core::option::Option<i32>,
    /// Abort code from Move.
    #[prost(uint64, optional, tag = "3")]
    pub abort_code: ::core::option::Option<u64>,
    /// Location in Move where the error occurred.
    #[prost(message, optional, tag = "4")]
    pub location: ::core::option::Option<MoveLocation>,
    #[prost(message, optional, tag = "5")]
    pub size_error: ::core::option::Option<SizeError>,
    #[prost(message, optional, tag = "6")]
    pub command_argument_error: ::core::option::Option<CommandArgumentError>,
    #[prost(message, optional, tag = "7")]
    pub type_argument_error: ::core::option::Option<TypeArgumentError>,
    #[prost(message, optional, tag = "8")]
    pub package_upgrade_error: ::core::option::Option<PackageUpgradeError>,
    /// Index of an input or result.
    #[prost(uint32, optional, tag = "9")]
    pub index: ::core::option::Option<u32>,
    /// Index of a subresult.
    #[prost(uint32, optional, tag = "10")]
    pub subresult: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "11")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Denied address.
    #[prost(string, optional, tag = "12")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    /// Coin type.
    #[prost(string, optional, tag = "13")]
    pub coin_type: ::core::option::Option<::prost::alloc::string::String>,
    /// Set of objects that were congested, leading to the transaction's cancellation.
    #[prost(string, repeated, tag = "14")]
    pub congested_objects: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ExecutionError`.
pub mod execution_error {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExecutionErrorKind {
        Unknown = 0,
        /// Insufficient gas.
        InsufficientGas = 1,
        /// Invalid `Gas` object.
        InvalidGasObject = 2,
        /// Invariant violation.
        InvariantViolation = 3,
        /// Attempted to use feature that is not supported yet.
        FeatureNotYetSupported = 4,
        /// Move object is larger than the maximum allowed size.
        ObjectTooBig = 5,
        /// Package is larger than the maximum allowed size.
        PackageTooBig = 6,
        /// Circular object ownership.
        CircularObjectOwnership = 7,
        /// Insufficient coin balance for requested operation.
        InsufficientCoinBalance = 8,
        /// Coin balance overflowed an u64.
        CoinBalanceOverflow = 9,
        /// Publish error, non-zero address.
        /// The modules in the package must have their self-addresses set to zero.
        PublishErrorNonZeroAddress = 10,
        /// Sui Move bytecode verification error.
        SuiMoveVerificationError = 11,
        /// Error from a non-abort instruction.
        /// Possible causes:
        ///      Arithmetic error, stack overflow, max value depth, or similar.
        MovePrimitiveRuntimeError = 12,
        /// Move runtime abort.
        MoveAbort = 13,
        /// Bytecode verification error.
        VmVerificationOrDeserializationError = 14,
        /// MoveVm invariant violation.
        VmInvariantViolation = 15,
        /// Function not found.
        FunctionNotFound = 16,
        /// Parity mismatch for Move function.
        /// The number of arguments does not match the number of parameters.
        ArityMismatch = 17,
        /// Type parity mismatch for Move function.
        /// Mismatch between the number of actual versus expected type arguments.
        TypeArityMismatch = 18,
        /// Non-entry function invoked. Move Call must start with an entry function.
        NonEntryFunctionInvoked = 19,
        /// Invalid command argument.
        CommandArgumentError = 20,
        /// Type argument error.
        TypeArgumentError = 21,
        /// Unused result without the drop ability.
        UnusedValueWithoutDrop = 22,
        /// Invalid public Move function signature.
        /// Unsupported return type for return value.
        InvalidPublicFunctionReturnType = 23,
        /// Invalid transfer object, object does not have public transfer.
        InvalidTransferObject = 24,
        /// Effects from the transaction are too large.
        EffectsTooLarge = 25,
        /// Publish or Upgrade is missing dependency.
        PublishUpgradeMissingDependency = 26,
        /// Publish or upgrade dependency downgrade.
        ///
        /// Indirect (transitive) dependency of published or upgraded package has been assigned an
        /// on-chain version that is less than the version required by one of the package's
        /// transitive dependencies.
        PublishUpgradeDependencyDowngrade = 27,
        /// Invalid package upgrade.
        PackageUpgradeError = 28,
        /// Indicates the transaction tried to write objects too large to storage.
        WrittenObjectsTooLarge = 29,
        /// Certificate is on the deny list.
        CertificateDenied = 30,
        /// Sui Move bytecode verification timed out.
        SuiMoveVerificationTimedout = 31,
        /// The requested shared object operation is not allowed.
        SharedObjectOperationNotAllowed = 32,
        /// Requested shared object has been deleted.
        InputObjectDeleted = 33,
        /// Certificate is canceled due to congestion on shared objects.
        ExecutionCanceledDueToSharedObjectCongestion = 34,
        /// Address is denied for this coin type.
        AddressDeniedForCoin = 35,
        /// Coin type is globally paused for use.
        CoinTypeGlobalPause = 36,
        /// Certificate is canceled because randomness could not be generated this epoch.
        ExecutionCanceledDueToRandomnessUnavailable = 37,
    }
    impl ExecutionErrorKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "EXECUTION_ERROR_KIND_UNKNOWN",
                Self::InsufficientGas => "INSUFFICIENT_GAS",
                Self::InvalidGasObject => "INVALID_GAS_OBJECT",
                Self::InvariantViolation => "INVARIANT_VIOLATION",
                Self::FeatureNotYetSupported => "FEATURE_NOT_YET_SUPPORTED",
                Self::ObjectTooBig => "OBJECT_TOO_BIG",
                Self::PackageTooBig => "PACKAGE_TOO_BIG",
                Self::CircularObjectOwnership => "CIRCULAR_OBJECT_OWNERSHIP",
                Self::InsufficientCoinBalance => "INSUFFICIENT_COIN_BALANCE",
                Self::CoinBalanceOverflow => "COIN_BALANCE_OVERFLOW",
                Self::PublishErrorNonZeroAddress => "PUBLISH_ERROR_NON_ZERO_ADDRESS",
                Self::SuiMoveVerificationError => "SUI_MOVE_VERIFICATION_ERROR",
                Self::MovePrimitiveRuntimeError => "MOVE_PRIMITIVE_RUNTIME_ERROR",
                Self::MoveAbort => "MOVE_ABORT",
                Self::VmVerificationOrDeserializationError => {
                    "VM_VERIFICATION_OR_DESERIALIZATION_ERROR"
                }
                Self::VmInvariantViolation => "VM_INVARIANT_VIOLATION",
                Self::FunctionNotFound => "FUNCTION_NOT_FOUND",
                Self::ArityMismatch => "ARITY_MISMATCH",
                Self::TypeArityMismatch => "TYPE_ARITY_MISMATCH",
                Self::NonEntryFunctionInvoked => "NON_ENTRY_FUNCTION_INVOKED",
                Self::CommandArgumentError => "COMMAND_ARGUMENT_ERROR",
                Self::TypeArgumentError => "TYPE_ARGUMENT_ERROR",
                Self::UnusedValueWithoutDrop => "UNUSED_VALUE_WITHOUT_DROP",
                Self::InvalidPublicFunctionReturnType => {
                    "INVALID_PUBLIC_FUNCTION_RETURN_TYPE"
                }
                Self::InvalidTransferObject => "INVALID_TRANSFER_OBJECT",
                Self::EffectsTooLarge => "EFFECTS_TOO_LARGE",
                Self::PublishUpgradeMissingDependency => {
                    "PUBLISH_UPGRADE_MISSING_DEPENDENCY"
                }
                Self::PublishUpgradeDependencyDowngrade => {
                    "PUBLISH_UPGRADE_DEPENDENCY_DOWNGRADE"
                }
                Self::PackageUpgradeError => "PACKAGE_UPGRADE_ERROR",
                Self::WrittenObjectsTooLarge => "WRITTEN_OBJECTS_TOO_LARGE",
                Self::CertificateDenied => "CERTIFICATE_DENIED",
                Self::SuiMoveVerificationTimedout => "SUI_MOVE_VERIFICATION_TIMEDOUT",
                Self::SharedObjectOperationNotAllowed => {
                    "SHARED_OBJECT_OPERATION_NOT_ALLOWED"
                }
                Self::InputObjectDeleted => "INPUT_OBJECT_DELETED",
                Self::ExecutionCanceledDueToSharedObjectCongestion => {
                    "EXECUTION_CANCELED_DUE_TO_SHARED_OBJECT_CONGESTION"
                }
                Self::AddressDeniedForCoin => "ADDRESS_DENIED_FOR_COIN",
                Self::CoinTypeGlobalPause => "COIN_TYPE_GLOBAL_PAUSE",
                Self::ExecutionCanceledDueToRandomnessUnavailable => {
                    "EXECUTION_CANCELED_DUE_TO_RANDOMNESS_UNAVAILABLE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXECUTION_ERROR_KIND_UNKNOWN" => Some(Self::Unknown),
                "INSUFFICIENT_GAS" => Some(Self::InsufficientGas),
                "INVALID_GAS_OBJECT" => Some(Self::InvalidGasObject),
                "INVARIANT_VIOLATION" => Some(Self::InvariantViolation),
                "FEATURE_NOT_YET_SUPPORTED" => Some(Self::FeatureNotYetSupported),
                "OBJECT_TOO_BIG" => Some(Self::ObjectTooBig),
                "PACKAGE_TOO_BIG" => Some(Self::PackageTooBig),
                "CIRCULAR_OBJECT_OWNERSHIP" => Some(Self::CircularObjectOwnership),
                "INSUFFICIENT_COIN_BALANCE" => Some(Self::InsufficientCoinBalance),
                "COIN_BALANCE_OVERFLOW" => Some(Self::CoinBalanceOverflow),
                "PUBLISH_ERROR_NON_ZERO_ADDRESS" => {
                    Some(Self::PublishErrorNonZeroAddress)
                }
                "SUI_MOVE_VERIFICATION_ERROR" => Some(Self::SuiMoveVerificationError),
                "MOVE_PRIMITIVE_RUNTIME_ERROR" => Some(Self::MovePrimitiveRuntimeError),
                "MOVE_ABORT" => Some(Self::MoveAbort),
                "VM_VERIFICATION_OR_DESERIALIZATION_ERROR" => {
                    Some(Self::VmVerificationOrDeserializationError)
                }
                "VM_INVARIANT_VIOLATION" => Some(Self::VmInvariantViolation),
                "FUNCTION_NOT_FOUND" => Some(Self::FunctionNotFound),
                "ARITY_MISMATCH" => Some(Self::ArityMismatch),
                "TYPE_ARITY_MISMATCH" => Some(Self::TypeArityMismatch),
                "NON_ENTRY_FUNCTION_INVOKED" => Some(Self::NonEntryFunctionInvoked),
                "COMMAND_ARGUMENT_ERROR" => Some(Self::CommandArgumentError),
                "TYPE_ARGUMENT_ERROR" => Some(Self::TypeArgumentError),
                "UNUSED_VALUE_WITHOUT_DROP" => Some(Self::UnusedValueWithoutDrop),
                "INVALID_PUBLIC_FUNCTION_RETURN_TYPE" => {
                    Some(Self::InvalidPublicFunctionReturnType)
                }
                "INVALID_TRANSFER_OBJECT" => Some(Self::InvalidTransferObject),
                "EFFECTS_TOO_LARGE" => Some(Self::EffectsTooLarge),
                "PUBLISH_UPGRADE_MISSING_DEPENDENCY" => {
                    Some(Self::PublishUpgradeMissingDependency)
                }
                "PUBLISH_UPGRADE_DEPENDENCY_DOWNGRADE" => {
                    Some(Self::PublishUpgradeDependencyDowngrade)
                }
                "PACKAGE_UPGRADE_ERROR" => Some(Self::PackageUpgradeError),
                "WRITTEN_OBJECTS_TOO_LARGE" => Some(Self::WrittenObjectsTooLarge),
                "CERTIFICATE_DENIED" => Some(Self::CertificateDenied),
                "SUI_MOVE_VERIFICATION_TIMEDOUT" => {
                    Some(Self::SuiMoveVerificationTimedout)
                }
                "SHARED_OBJECT_OPERATION_NOT_ALLOWED" => {
                    Some(Self::SharedObjectOperationNotAllowed)
                }
                "INPUT_OBJECT_DELETED" => Some(Self::InputObjectDeleted),
                "EXECUTION_CANCELED_DUE_TO_SHARED_OBJECT_CONGESTION" => {
                    Some(Self::ExecutionCanceledDueToSharedObjectCongestion)
                }
                "ADDRESS_DENIED_FOR_COIN" => Some(Self::AddressDeniedForCoin),
                "COIN_TYPE_GLOBAL_PAUSE" => Some(Self::CoinTypeGlobalPause),
                "EXECUTION_CANCELED_DUE_TO_RANDOMNESS_UNAVAILABLE" => {
                    Some(Self::ExecutionCanceledDueToRandomnessUnavailable)
                }
                _ => None,
            }
        }
    }
}
/// A size error.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SizeError {
    /// The offending size.
    #[prost(uint64, optional, tag = "1")]
    pub size: ::core::option::Option<u64>,
    /// The maximum allowable size.
    #[prost(uint64, optional, tag = "2")]
    pub max_size: ::core::option::Option<u64>,
}
/// Location in Move bytecode where an error occurred.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveLocation {
    /// The package ID.
    #[prost(string, optional, tag = "1")]
    pub package: ::core::option::Option<::prost::alloc::string::String>,
    /// The module name.
    #[prost(string, optional, tag = "2")]
    pub module: ::core::option::Option<::prost::alloc::string::String>,
    /// The function index.
    #[prost(uint32, optional, tag = "3")]
    pub function: ::core::option::Option<u32>,
    /// Offset of the instruction where the error occurred.
    #[prost(uint32, optional, tag = "4")]
    pub instruction: ::core::option::Option<u32>,
    /// The name of the function, if available.
    #[prost(string, optional, tag = "5")]
    pub function_name: ::core::option::Option<::prost::alloc::string::String>,
}
/// An error with an argument to a command.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CommandArgumentError {
    /// Position of the problematic argument.
    #[prost(uint32, optional, tag = "1")]
    pub argument: ::core::option::Option<u32>,
    #[prost(
        enumeration = "command_argument_error::CommandArgumentErrorKind",
        optional,
        tag = "2"
    )]
    pub kind: ::core::option::Option<i32>,
    /// Index of an input or result.
    #[prost(uint32, optional, tag = "3")]
    pub index: ::core::option::Option<u32>,
    /// Index of a subresult.
    #[prost(uint32, optional, tag = "4")]
    pub subresult: ::core::option::Option<u32>,
}
/// Nested message and enum types in `CommandArgumentError`.
pub mod command_argument_error {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CommandArgumentErrorKind {
        Unknown = 0,
        /// The type of the value does not match the expected type.
        TypeMismatch = 1,
        /// The argument cannot be deserialized into a value of the specified type.
        InvalidBcsBytes = 2,
        /// The argument cannot be instantiated from raw bytes.
        InvalidUsageOfPureArgument = 3,
        /// Invalid argument to private entry function.
        /// Private entry functions cannot take arguments from other Move functions.
        InvalidArgumentToPrivateEntryFunction = 4,
        /// Out of bounds access to input or results.
        ///
        /// `index` field will be set indicating the invalid index value.
        IndexOutOfBounds = 5,
        /// Out of bounds access to subresult.
        ///
        /// `index` and `subresult` fields will be set indicating the invalid index value.
        SecondaryIndexOutOfBounds = 6,
        /// Invalid usage of result.
        /// Expected a single result but found either no return value or multiple.
        /// `index` field will be set indicating the invalid index value.
        InvalidResultArity = 7,
        /// Invalid usage of gas coin.
        /// The gas coin can only be used by-value with a `TransferObject` command.
        InvalidGasCoinUsage = 8,
        /// Invalid usage of Move value.
        ///     - Mutably borrowed values require unique usage.
        ///     - Immutably borrowed values cannot be taken or borrowed mutably.
        ///     - Taken values cannot be used again.
        InvalidValueUsage = 9,
        /// Immutable objects cannot be passed by-value.
        InvalidObjectByValue = 10,
        /// Immutable objects cannot be passed by mutable reference, `&mut`.
        InvalidObjectByMutRef = 11,
        /// Shared object operations such as wrapping, freezing, or converting to owned are not
        /// allowed.
        SharedObjectOperationNotAllowed = 12,
    }
    impl CommandArgumentErrorKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "COMMAND_ARGUMENT_ERROR_KIND_UNKNOWN",
                Self::TypeMismatch => "TYPE_MISMATCH",
                Self::InvalidBcsBytes => "INVALID_BCS_BYTES",
                Self::InvalidUsageOfPureArgument => "INVALID_USAGE_OF_PURE_ARGUMENT",
                Self::InvalidArgumentToPrivateEntryFunction => {
                    "INVALID_ARGUMENT_TO_PRIVATE_ENTRY_FUNCTION"
                }
                Self::IndexOutOfBounds => "INDEX_OUT_OF_BOUNDS",
                Self::SecondaryIndexOutOfBounds => "SECONDARY_INDEX_OUT_OF_BOUNDS",
                Self::InvalidResultArity => "INVALID_RESULT_ARITY",
                Self::InvalidGasCoinUsage => "INVALID_GAS_COIN_USAGE",
                Self::InvalidValueUsage => "INVALID_VALUE_USAGE",
                Self::InvalidObjectByValue => "INVALID_OBJECT_BY_VALUE",
                Self::InvalidObjectByMutRef => "INVALID_OBJECT_BY_MUT_REF",
                Self::SharedObjectOperationNotAllowed => {
                    "SHARED_OBJECT_OPERATION_NOT_ALLOWED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMMAND_ARGUMENT_ERROR_KIND_UNKNOWN" => Some(Self::Unknown),
                "TYPE_MISMATCH" => Some(Self::TypeMismatch),
                "INVALID_BCS_BYTES" => Some(Self::InvalidBcsBytes),
                "INVALID_USAGE_OF_PURE_ARGUMENT" => {
                    Some(Self::InvalidUsageOfPureArgument)
                }
                "INVALID_ARGUMENT_TO_PRIVATE_ENTRY_FUNCTION" => {
                    Some(Self::InvalidArgumentToPrivateEntryFunction)
                }
                "INDEX_OUT_OF_BOUNDS" => Some(Self::IndexOutOfBounds),
                "SECONDARY_INDEX_OUT_OF_BOUNDS" => Some(Self::SecondaryIndexOutOfBounds),
                "INVALID_RESULT_ARITY" => Some(Self::InvalidResultArity),
                "INVALID_GAS_COIN_USAGE" => Some(Self::InvalidGasCoinUsage),
                "INVALID_VALUE_USAGE" => Some(Self::InvalidValueUsage),
                "INVALID_OBJECT_BY_VALUE" => Some(Self::InvalidObjectByValue),
                "INVALID_OBJECT_BY_MUT_REF" => Some(Self::InvalidObjectByMutRef),
                "SHARED_OBJECT_OPERATION_NOT_ALLOWED" => {
                    Some(Self::SharedObjectOperationNotAllowed)
                }
                _ => None,
            }
        }
    }
}
/// An error with upgrading a package.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackageUpgradeError {
    #[prost(
        enumeration = "package_upgrade_error::PackageUpgradeErrorKind",
        optional,
        tag = "1"
    )]
    pub kind: ::core::option::Option<i32>,
    /// The Package Id.
    #[prost(string, optional, tag = "2")]
    pub package_id: ::core::option::Option<::prost::alloc::string::String>,
    /// A digest.
    #[prost(string, optional, tag = "3")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The policy.
    #[prost(uint32, optional, tag = "4")]
    pub policy: ::core::option::Option<u32>,
    /// The ticket Id.
    #[prost(string, optional, tag = "5")]
    pub ticket_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `PackageUpgradeError`.
pub mod package_upgrade_error {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PackageUpgradeErrorKind {
        Unknown = 0,
        /// Unable to fetch package.
        UnableToFetchPackage = 1,
        /// Object is not a package.
        NotAPackage = 2,
        /// Package upgrade is incompatible with previous version.
        IncompatibleUpgrade = 3,
        /// Digest in upgrade ticket and computed digest differ.
        DigetsDoesNotMatch = 4,
        /// Upgrade policy is not valid.
        UnknownUpgradePolicy = 5,
        /// Package ID does not match `PackageId` in upgrade ticket.
        PackageIdDoesNotMatch = 6,
    }
    impl PackageUpgradeErrorKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "PACKAGE_UPGRADE_ERROR_KIND_UNKNOWN",
                Self::UnableToFetchPackage => "UNABLE_TO_FETCH_PACKAGE",
                Self::NotAPackage => "NOT_A_PACKAGE",
                Self::IncompatibleUpgrade => "INCOMPATIBLE_UPGRADE",
                Self::DigetsDoesNotMatch => "DIGETS_DOES_NOT_MATCH",
                Self::UnknownUpgradePolicy => "UNKNOWN_UPGRADE_POLICY",
                Self::PackageIdDoesNotMatch => "PACKAGE_ID_DOES_NOT_MATCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PACKAGE_UPGRADE_ERROR_KIND_UNKNOWN" => Some(Self::Unknown),
                "UNABLE_TO_FETCH_PACKAGE" => Some(Self::UnableToFetchPackage),
                "NOT_A_PACKAGE" => Some(Self::NotAPackage),
                "INCOMPATIBLE_UPGRADE" => Some(Self::IncompatibleUpgrade),
                "DIGETS_DOES_NOT_MATCH" => Some(Self::DigetsDoesNotMatch),
                "UNKNOWN_UPGRADE_POLICY" => Some(Self::UnknownUpgradePolicy),
                "PACKAGE_ID_DOES_NOT_MATCH" => Some(Self::PackageIdDoesNotMatch),
                _ => None,
            }
        }
    }
}
/// Type argument error.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TypeArgumentError {
    /// Index of the problematic type argument.
    #[prost(uint32, optional, tag = "1")]
    pub type_argument: ::core::option::Option<u32>,
    #[prost(
        enumeration = "type_argument_error::TypeArgumentErrorKind",
        optional,
        tag = "2"
    )]
    pub kind: ::core::option::Option<i32>,
}
/// Nested message and enum types in `TypeArgumentError`.
pub mod type_argument_error {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TypeArgumentErrorKind {
        Unknown = 0,
        /// A type was not found in the module specified.
        TypeNotFound = 1,
        /// A type provided did not match the specified constraint.
        ConstraintNotSatisfied = 2,
    }
    impl TypeArgumentErrorKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "TYPE_ARGUMENT_ERROR_KIND_UNKNOWN",
                Self::TypeNotFound => "TYPE_NOT_FOUND",
                Self::ConstraintNotSatisfied => "CONSTRAINT_NOT_SATISFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_ARGUMENT_ERROR_KIND_UNKNOWN" => Some(Self::Unknown),
                "TYPE_NOT_FOUND" => Some(Self::TypeNotFound),
                "CONSTRAINT_NOT_SATISFIED" => Some(Self::ConstraintNotSatisfied),
                _ => None,
            }
        }
    }
}
/// Summary of gas charges.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GasCostSummary {
    /// Cost of computation/execution.
    #[prost(uint64, optional, tag = "1")]
    pub computation_cost: ::core::option::Option<u64>,
    /// Storage cost, it's the sum of all storage cost for all objects created or mutated.
    #[prost(uint64, optional, tag = "2")]
    pub storage_cost: ::core::option::Option<u64>,
    /// The amount of storage cost refunded to the user for all objects deleted or mutated in the
    /// transaction.
    #[prost(uint64, optional, tag = "3")]
    pub storage_rebate: ::core::option::Option<u64>,
    /// The fee for the rebate. The portion of the storage rebate kept by the system.
    #[prost(uint64, optional, tag = "4")]
    pub non_refundable_storage_fee: ::core::option::Option<u64>,
}
/// An input to a user transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Input {
    #[prost(enumeration = "input::InputKind", optional, tag = "1")]
    pub kind: ::core::option::Option<i32>,
    /// A move value serialized as BCS.
    ///
    /// For normal operations this is required to be a move primitive type and not contain structs
    /// or objects.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub pure: ::core::option::Option<::prost::bytes::Bytes>,
    /// `ObjectId` of the object input.
    #[prost(string, optional, tag = "3")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Requested version of the input object when `kind` is `IMMUTABLE_OR_OWNED`
    /// or `RECEIVING` or if `kind` is `SHARED` this is the initial version of the
    /// object when it was shared
    #[prost(uint64, optional, tag = "4")]
    pub version: ::core::option::Option<u64>,
    /// The digest of this object.
    #[prost(string, optional, tag = "5")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Controls whether the caller asks for a mutable reference to the shared
    /// object.
    #[prost(bool, optional, tag = "6")]
    pub mutable: ::core::option::Option<bool>,
}
/// Nested message and enum types in `Input`.
pub mod input {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InputKind {
        Unknown = 0,
        /// A move value serialized as BCS.
        Pure = 1,
        /// A Move object that is either immutable or address owned.
        ImmutableOrOwned = 2,
        /// A Move object whose owner is "Shared".
        Shared = 3,
        /// A Move object that is attempted to be received in this transaction.
        Receiving = 4,
    }
    impl InputKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "INPUT_KIND_UNKNOWN",
                Self::Pure => "PURE",
                Self::ImmutableOrOwned => "IMMUTABLE_OR_OWNED",
                Self::Shared => "SHARED",
                Self::Receiving => "RECEIVING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INPUT_KIND_UNKNOWN" => Some(Self::Unknown),
                "PURE" => Some(Self::Pure),
                "IMMUTABLE_OR_OWNED" => Some(Self::ImmutableOrOwned),
                "SHARED" => Some(Self::Shared),
                "RECEIVING" => Some(Self::Receiving),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetServiceInfoRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetServiceInfoResponse {
    /// The chain identifier of the chain that this node is on.
    ///
    /// The chain identifier is the digest of the genesis checkpoint, the
    /// checkpoint with sequence number 0.
    #[prost(string, optional, tag = "1")]
    pub chain_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Human-readable name of the chain that this node is on.
    ///
    /// This is intended to be a human-readable name like `mainnet`, `testnet`, and so on.
    #[prost(string, optional, tag = "2")]
    pub chain: ::core::option::Option<::prost::alloc::string::String>,
    /// Current epoch of the node based on its highest executed checkpoint.
    #[prost(uint64, optional, tag = "3")]
    pub epoch: ::core::option::Option<u64>,
    /// Checkpoint height of the most recently executed checkpoint.
    #[prost(uint64, optional, tag = "4")]
    pub checkpoint_height: ::core::option::Option<u64>,
    /// Unix timestamp of the most recently executed checkpoint.
    #[prost(message, optional, tag = "5")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// The lowest checkpoint for which checkpoints and transaction data are available.
    #[prost(uint64, optional, tag = "6")]
    pub lowest_available_checkpoint: ::core::option::Option<u64>,
    /// The lowest checkpoint for which object data is available.
    #[prost(uint64, optional, tag = "7")]
    pub lowest_available_checkpoint_objects: ::core::option::Option<u64>,
    /// Software version of the service. Similar to the `server` http header.
    #[prost(string, optional, tag = "8")]
    pub server_version: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetObjectRequest {
    /// Required. The `ObjectId` of the requested object.
    #[prost(string, optional, tag = "1")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Request a specific version of the object.
    /// If no version is specified, and the object is live, then the latest
    /// version of the object is returned.
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `object_id,version,digest`.
    #[prost(message, optional, tag = "3")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetObjectsRequest {
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<GetObjectRequest>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `object_id,version,digest`.
    #[prost(message, optional, tag = "2")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetObjectsResponse {
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<Object>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionRequest {
    /// Required. The digest of the requested transaction.
    #[prost(string, optional, tag = "1")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `digest`.
    #[prost(message, optional, tag = "2")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetTransactionsRequest {
    /// Required. The digests of the requested transactions.
    #[prost(string, repeated, tag = "1")]
    pub digests: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `object_id,version,digest`.
    #[prost(message, optional, tag = "2")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetTransactionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub transactions: ::prost::alloc::vec::Vec<ExecutedTransaction>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCheckpointRequest {
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `object_id,version,digest`.
    #[prost(message, optional, tag = "3")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// If neither is provided, return the latest
    #[prost(oneof = "get_checkpoint_request::CheckpointId", tags = "1, 2")]
    pub checkpoint_id: ::core::option::Option<get_checkpoint_request::CheckpointId>,
}
/// Nested message and enum types in `GetCheckpointRequest`.
pub mod get_checkpoint_request {
    /// If neither is provided, return the latest
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CheckpointId {
        /// The sequence number of the requested checkpoint.
        #[prost(uint64, tag = "1")]
        SequenceNumber(u64),
        /// The digest of the requested checkpoint.
        #[prost(string, tag = "2")]
        Digest(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEpochRequest {
    /// The requested epoch.
    /// If no epoch is provided the current epoch will be returned.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `epoch`.
    #[prost(message, optional, tag = "2")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Generated client implementations.
pub mod ledger_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct LedgerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl LedgerServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> LedgerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> LedgerServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            LedgerServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Query the service for general information about its current state.
        pub async fn get_service_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetServiceInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetServiceInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta.LedgerService/GetServiceInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("sui.rpc.v2beta.LedgerService", "GetServiceInfo"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_object(
            &mut self,
            request: impl tonic::IntoRequest<super::GetObjectRequest>,
        ) -> std::result::Result<tonic::Response<super::Object>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta.LedgerService/GetObject",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sui.rpc.v2beta.LedgerService", "GetObject"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn batch_get_objects(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchGetObjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchGetObjectsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta.LedgerService/BatchGetObjects",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("sui.rpc.v2beta.LedgerService", "BatchGetObjects"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExecutedTransaction>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta.LedgerService/GetTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("sui.rpc.v2beta.LedgerService", "GetTransaction"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn batch_get_transactions(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchGetTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchGetTransactionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta.LedgerService/BatchGetTransactions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "sui.rpc.v2beta.LedgerService",
                        "BatchGetTransactions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_checkpoint(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCheckpointRequest>,
        ) -> std::result::Result<tonic::Response<super::Checkpoint>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta.LedgerService/GetCheckpoint",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("sui.rpc.v2beta.LedgerService", "GetCheckpoint"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_epoch(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEpochRequest>,
        ) -> std::result::Result<tonic::Response<super::Epoch>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta.LedgerService/GetEpoch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sui.rpc.v2beta.LedgerService", "GetEpoch"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod ledger_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with LedgerServiceServer.
    #[async_trait]
    pub trait LedgerService: std::marker::Send + std::marker::Sync + 'static {
        /// Query the service for general information about its current state.
        async fn get_service_info(
            &self,
            request: tonic::Request<super::GetServiceInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetServiceInfoResponse>,
            tonic::Status,
        >;
        async fn get_object(
            &self,
            request: tonic::Request<super::GetObjectRequest>,
        ) -> std::result::Result<tonic::Response<super::Object>, tonic::Status>;
        async fn batch_get_objects(
            &self,
            request: tonic::Request<super::BatchGetObjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchGetObjectsResponse>,
            tonic::Status,
        >;
        async fn get_transaction(
            &self,
            request: tonic::Request<super::GetTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExecutedTransaction>,
            tonic::Status,
        >;
        async fn batch_get_transactions(
            &self,
            request: tonic::Request<super::BatchGetTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchGetTransactionsResponse>,
            tonic::Status,
        >;
        async fn get_checkpoint(
            &self,
            request: tonic::Request<super::GetCheckpointRequest>,
        ) -> std::result::Result<tonic::Response<super::Checkpoint>, tonic::Status>;
        async fn get_epoch(
            &self,
            request: tonic::Request<super::GetEpochRequest>,
        ) -> std::result::Result<tonic::Response<super::Epoch>, tonic::Status>;
    }
    #[derive(Debug)]
    pub struct LedgerServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> LedgerServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for LedgerServiceServer<T>
    where
        T: LedgerService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/sui.rpc.v2beta.LedgerService/GetServiceInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetServiceInfoSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::GetServiceInfoRequest>
                    for GetServiceInfoSvc<T> {
                        type Response = super::GetServiceInfoResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetServiceInfoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::get_service_info(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetServiceInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sui.rpc.v2beta.LedgerService/GetObject" => {
                    #[allow(non_camel_case_types)]
                    struct GetObjectSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::GetObjectRequest>
                    for GetObjectSvc<T> {
                        type Response = super::Object;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetObjectRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::get_object(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetObjectSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sui.rpc.v2beta.LedgerService/BatchGetObjects" => {
                    #[allow(non_camel_case_types)]
                    struct BatchGetObjectsSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::BatchGetObjectsRequest>
                    for BatchGetObjectsSvc<T> {
                        type Response = super::BatchGetObjectsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BatchGetObjectsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::batch_get_objects(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BatchGetObjectsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sui.rpc.v2beta.LedgerService/GetTransaction" => {
                    #[allow(non_camel_case_types)]
                    struct GetTransactionSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::GetTransactionRequest>
                    for GetTransactionSvc<T> {
                        type Response = super::ExecutedTransaction;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTransactionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::get_transaction(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTransactionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sui.rpc.v2beta.LedgerService/BatchGetTransactions" => {
                    #[allow(non_camel_case_types)]
                    struct BatchGetTransactionsSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::BatchGetTransactionsRequest>
                    for BatchGetTransactionsSvc<T> {
                        type Response = super::BatchGetTransactionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BatchGetTransactionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::batch_get_transactions(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BatchGetTransactionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sui.rpc.v2beta.LedgerService/GetCheckpoint" => {
                    #[allow(non_camel_case_types)]
                    struct GetCheckpointSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::GetCheckpointRequest>
                    for GetCheckpointSvc<T> {
                        type Response = super::Checkpoint;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCheckpointRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::get_checkpoint(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetCheckpointSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sui.rpc.v2beta.LedgerService/GetEpoch" => {
                    #[allow(non_camel_case_types)]
                    struct GetEpochSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::GetEpochRequest>
                    for GetEpochSvc<T> {
                        type Response = super::Epoch;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetEpochRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::get_epoch(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetEpochSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for LedgerServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "sui.rpc.v2beta.LedgerService";
    impl<T> tonic::server::NamedService for LedgerServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// An object on the Sui blockchain.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Object {
    /// This Object serialized as BCS.
    #[prost(message, optional, tag = "1")]
    pub bcs: ::core::option::Option<Bcs>,
    /// `ObjectId` for this object.
    #[prost(string, optional, tag = "2")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of the object.
    #[prost(uint64, optional, tag = "3")]
    pub version: ::core::option::Option<u64>,
    /// The digest of this Object.
    #[prost(string, optional, tag = "4")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Owner of the object.
    #[prost(message, optional, tag = "5")]
    pub owner: ::core::option::Option<Owner>,
    /// The type of this object.
    ///
    /// This will be 'package' for packages and a StructTag for move structs.
    #[prost(string, optional, tag = "6")]
    pub object_type: ::core::option::Option<::prost::alloc::string::String>,
    /// DEPRECATED this field is no longer used to determine whether a tx can transfer this
    /// object. Instead, it is always calculated from the objects type when loaded in execution.
    ///
    /// Only set for Move structs
    #[prost(bool, optional, tag = "7")]
    pub has_public_transfer: ::core::option::Option<bool>,
    /// BCS bytes of a Move struct value.
    ///
    /// Only set for Move structs
    #[prost(message, optional, tag = "8")]
    pub contents: ::core::option::Option<Bcs>,
    /// Set of modules defined by this package.
    ///
    /// Only set for Packages
    #[prost(message, repeated, tag = "9")]
    pub modules: ::prost::alloc::vec::Vec<MoveModule>,
    /// Maps struct/module to a package version where it was first defined, stored as a vector for
    /// simple serialization and deserialization.
    ///
    /// Only set for Packages
    #[prost(message, repeated, tag = "10")]
    pub type_origin_table: ::prost::alloc::vec::Vec<TypeOrigin>,
    /// For each dependency, maps original package ID to the info about the (upgraded) dependency
    /// version that this package is using.
    ///
    /// Only set for Packages
    #[prost(message, repeated, tag = "11")]
    pub linkage_table: ::prost::alloc::vec::Vec<UpgradeInfo>,
    /// The digest of the transaction that created or last mutated this object
    #[prost(string, optional, tag = "12")]
    pub previous_transaction: ::core::option::Option<::prost::alloc::string::String>,
    /// The amount of SUI to rebate if this object gets deleted.
    /// This number is re-calculated each time the object is mutated based on
    /// the present storage gas price.
    #[prost(uint64, optional, tag = "13")]
    pub storage_rebate: ::core::option::Option<u64>,
}
/// Module defined by a package.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveModule {
    /// Name of the module.
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Serialized bytecode of the module.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub contents: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Identifies a struct and the module it was defined in.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypeOrigin {
    #[prost(string, optional, tag = "1")]
    pub module_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub struct_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub package_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// / Upgraded package info for the linkage table.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpgradeInfo {
    /// ID of the original package.
    #[prost(string, optional, tag = "1")]
    pub original_id: ::core::option::Option<::prost::alloc::string::String>,
    /// ID of the upgraded package.
    #[prost(string, optional, tag = "2")]
    pub upgraded_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of the upgraded package.
    #[prost(uint64, optional, tag = "3")]
    pub upgraded_version: ::core::option::Option<u64>,
}
/// Reference to an object.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectReference {
    /// The object ID of this object.
    #[prost(string, optional, tag = "1")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The version of this object.
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
    /// The digest of this object.
    #[prost(string, optional, tag = "3")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
}
/// Enum of different types of ownership for an object.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Owner {
    #[prost(enumeration = "owner::OwnerKind", optional, tag = "1")]
    pub kind: ::core::option::Option<i32>,
    /// Address or ObjectId of the owner
    #[prost(string, optional, tag = "2")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3")]
    pub version: ::core::option::Option<u64>,
}
/// Nested message and enum types in `Owner`.
pub mod owner {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OwnerKind {
        Unknown = 0,
        Address = 1,
        Object = 2,
        Shared = 3,
        Immutable = 4,
    }
    impl OwnerKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "OWNER_KIND_UNKNOWN",
                Self::Address => "ADDRESS",
                Self::Object => "OBJECT",
                Self::Shared => "SHARED",
                Self::Immutable => "IMMUTABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OWNER_KIND_UNKNOWN" => Some(Self::Unknown),
                "ADDRESS" => Some(Self::Address),
                "OBJECT" => Some(Self::Object),
                "SHARED" => Some(Self::Shared),
                "IMMUTABLE" => Some(Self::Immutable),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtocolConfig {
    #[prost(uint64, optional, tag = "1")]
    pub protocol_version: ::core::option::Option<u64>,
    #[prost(map = "string, bool", tag = "2")]
    pub feature_flags: ::std::collections::HashMap<::prost::alloc::string::String, bool>,
    #[prost(map = "string, string", tag = "3")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// A signature from a user.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserSignature {
    /// This signature serialized as as BCS.
    ///
    /// When provided as input this will support both the form that is length
    /// prefixed as well as not length prefixed.
    #[prost(message, optional, tag = "1")]
    pub bcs: ::core::option::Option<Bcs>,
    /// The signature scheme of this signature.
    #[prost(enumeration = "SignatureScheme", optional, tag = "2")]
    pub scheme: ::core::option::Option<i32>,
    /// Signature bytes if scheme is ed25519 | secp256k1 | secp256r1.
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub signature: ::core::option::Option<::prost::bytes::Bytes>,
    /// Public key bytes if scheme is ed25519 | secp256k1 | secp256r1.
    #[prost(bytes = "bytes", optional, tag = "4")]
    pub public_key: ::core::option::Option<::prost::bytes::Bytes>,
    /// The multisig aggregated signature if scheme is `MULTISIG`.
    #[prost(message, optional, tag = "5")]
    pub multisig: ::core::option::Option<MultisigAggregatedSignature>,
    /// The zklogin authenticator if scheme is `ZKLOGIN`.
    #[prost(message, optional, boxed, tag = "6")]
    pub zklogin: ::core::option::Option<
        ::prost::alloc::boxed::Box<ZkLoginAuthenticator>,
    >,
    /// The passkey authenticator if scheme is `PASSKEY`.
    #[prost(message, optional, boxed, tag = "7")]
    pub passkey: ::core::option::Option<
        ::prost::alloc::boxed::Box<PasskeyAuthenticator>,
    >,
}
/// Public key equivalent for zklogin authenticators.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginPublicIdentifier {
    #[prost(string, optional, tag = "1")]
    pub iss: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "2")]
    pub address_seed: ::core::option::Option<::prost::alloc::string::String>,
}
/// Set of valid public keys for multisig committee members.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigMemberPublicKey {
    /// The signature scheme of this public key.
    #[prost(enumeration = "SignatureScheme", optional, tag = "1")]
    pub scheme: ::core::option::Option<i32>,
    /// Public key bytes if scheme is ed25519 | secp256k1 | secp256r1.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub public_key: ::core::option::Option<::prost::bytes::Bytes>,
    /// A zklogin public identifier if scheme is zklogin.
    #[prost(message, optional, tag = "3")]
    pub zklogin: ::core::option::Option<ZkLoginPublicIdentifier>,
}
/// A member in a multisig committee.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigMember {
    /// The public key of the committee member.
    #[prost(message, optional, tag = "1")]
    pub public_key: ::core::option::Option<MultisigMemberPublicKey>,
    /// The weight of this member's signature.
    #[prost(uint32, optional, tag = "2")]
    pub weight: ::core::option::Option<u32>,
}
/// A multisig committee.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigCommittee {
    /// A list of committee members and their corresponding weight.
    #[prost(message, repeated, tag = "1")]
    pub members: ::prost::alloc::vec::Vec<MultisigMember>,
    /// The threshold of signatures needed to validate a signature from
    /// this committee.
    #[prost(uint32, optional, tag = "2")]
    pub threshold: ::core::option::Option<u32>,
}
/// Aggregated signature from members of a multisig committee.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigAggregatedSignature {
    /// The plain signatures encoded with signature scheme.
    ///
    /// The signatures must be in the same order as they are listed in the committee.
    #[prost(message, repeated, tag = "1")]
    pub signatures: ::prost::alloc::vec::Vec<MultisigMemberSignature>,
    /// Bitmap indicating which committee members contributed to the
    /// signature.
    #[prost(uint32, optional, tag = "2")]
    pub bitmap: ::core::option::Option<u32>,
    /// If present, means this signature's on-chain format uses the old
    /// legacy multisig format.
    #[prost(uint32, repeated, tag = "3")]
    pub legacy_bitmap: ::prost::alloc::vec::Vec<u32>,
    /// The committee to use to validate this signature.
    #[prost(message, optional, tag = "4")]
    pub committee: ::core::option::Option<MultisigCommittee>,
}
/// A signature from a member of a multisig committee.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigMemberSignature {
    /// The signature scheme of this signature.
    #[prost(enumeration = "SignatureScheme", optional, tag = "1")]
    pub scheme: ::core::option::Option<i32>,
    /// Signature bytes if scheme is ed25519 | secp256k1 | secp256r1.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub signature: ::core::option::Option<::prost::bytes::Bytes>,
    /// The zklogin authenticator if scheme is `ZKLOGIN`.
    #[prost(message, optional, tag = "3")]
    pub zklogin: ::core::option::Option<ZkLoginAuthenticator>,
}
/// A zklogin authenticator.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginAuthenticator {
    /// Zklogin proof and inputs required to perform proof verification.
    #[prost(message, optional, tag = "1")]
    pub inputs: ::core::option::Option<ZkLoginInputs>,
    /// Maximum epoch for which the proof is valid.
    #[prost(uint64, optional, tag = "2")]
    pub max_epoch: ::core::option::Option<u64>,
    /// User signature with the public key attested to by the provided proof.
    #[prost(message, optional, boxed, tag = "3")]
    pub signature: ::core::option::Option<::prost::alloc::boxed::Box<UserSignature>>,
}
/// A zklogin groth16 proof and the required inputs to perform proof verification.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginInputs {
    #[prost(message, optional, tag = "1")]
    pub proof_points: ::core::option::Option<ZkLoginProof>,
    #[prost(message, optional, tag = "2")]
    pub iss_base64_details: ::core::option::Option<ZkLoginClaim>,
    #[prost(string, optional, tag = "3")]
    pub header_base64: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "4")]
    pub address_seed: ::core::option::Option<::prost::alloc::string::String>,
}
/// A zklogin groth16 proof.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginProof {
    #[prost(message, optional, tag = "1")]
    pub a: ::core::option::Option<CircomG1>,
    #[prost(message, optional, tag = "2")]
    pub b: ::core::option::Option<CircomG2>,
    #[prost(message, optional, tag = "3")]
    pub c: ::core::option::Option<CircomG1>,
}
/// A claim of the iss in a zklogin proof.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginClaim {
    #[prost(string, optional, tag = "1")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "2")]
    pub index_mod_4: ::core::option::Option<u32>,
}
/// A G1 point.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CircomG1 {
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "1")]
    pub e0: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "2")]
    pub e1: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "3")]
    pub e2: ::core::option::Option<::prost::alloc::string::String>,
}
/// A G2 point.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CircomG2 {
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "1")]
    pub e00: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "2")]
    pub e01: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "3")]
    pub e10: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "4")]
    pub e11: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "5")]
    pub e20: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "6")]
    pub e21: ::core::option::Option<::prost::alloc::string::String>,
}
/// A passkey authenticator.
///
/// See
/// [struct.PasskeyAuthenticator](<https://mystenlabs.github.io/sui-rust-sdk/sui_sdk_types/struct.PasskeyAuthenticator.html#bcs>)
/// for more information on the requirements on the shape of the
/// `client_data_json` field.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PasskeyAuthenticator {
    /// Opaque authenticator data for this passkey signature.
    ///
    /// See [Authenticator Data](<https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data>) for
    /// more information on this field.
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub authenticator_data: ::core::option::Option<::prost::bytes::Bytes>,
    /// Structured, unparsed, JSON for this passkey signature.
    ///
    /// See [CollectedClientData](<https://www.w3.org/TR/webauthn-2/#dictdef-collectedclientdata>)
    /// for more information on this field.
    #[prost(string, optional, tag = "2")]
    pub client_data_json: ::core::option::Option<::prost::alloc::string::String>,
    /// A secp256r1 signature.
    #[prost(message, optional, boxed, tag = "3")]
    pub signature: ::core::option::Option<::prost::alloc::boxed::Box<UserSignature>>,
}
/// The validator set for a particular epoch.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorCommittee {
    /// The epoch where this committee governs.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// The committee members.
    #[prost(message, repeated, tag = "2")]
    pub members: ::prost::alloc::vec::Vec<ValidatorCommitteeMember>,
}
/// A member of a validator committee.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorCommitteeMember {
    /// The 96-byte Bls12381 public key for this validator.
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub public_key: ::core::option::Option<::prost::bytes::Bytes>,
    /// Stake weight this validator possesses.
    #[prost(uint64, optional, tag = "2")]
    pub stake: ::core::option::Option<u64>,
}
/// / An aggregated signature from multiple validators.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorAggregatedSignature {
    /// The epoch when this signature was produced.
    ///
    /// This can be used to lookup the `ValidatorCommittee` from this epoch
    /// to verify this signature.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// The 48-byte Bls12381 aggregated signature.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub signature: ::core::option::Option<::prost::bytes::Bytes>,
    /// Bitmap indicating which members of the committee contributed to
    /// this signature.
    #[prost(uint32, repeated, tag = "3")]
    pub bitmap: ::prost::alloc::vec::Vec<u32>,
}
/// Flag use to disambiguate the signature schemes supported by Sui.
///
/// Note: the enum values defined by this proto message exactly match their
/// expected BCS serialized values when serialized as a u8. See
/// [enum.SignatureScheme](<https://mystenlabs.github.io/sui-rust-sdk/sui_sdk_types/enum.SignatureScheme.html>)
/// for more information about signature schemes.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SignatureScheme {
    Ed25519 = 0,
    Secp256k1 = 1,
    Secp256r1 = 2,
    Multisig = 3,
    Bls12381 = 4,
    Zklogin = 5,
    Passkey = 6,
}
impl SignatureScheme {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Ed25519 => "ED25519",
            Self::Secp256k1 => "SECP256K1",
            Self::Secp256r1 => "SECP256R1",
            Self::Multisig => "MULTISIG",
            Self::Bls12381 => "BLS12381",
            Self::Zklogin => "ZKLOGIN",
            Self::Passkey => "PASSKEY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ED25519" => Some(Self::Ed25519),
            "SECP256K1" => Some(Self::Secp256k1),
            "SECP256R1" => Some(Self::Secp256r1),
            "MULTISIG" => Some(Self::Multisig),
            "BLS12381" => Some(Self::Bls12381),
            "ZKLOGIN" => Some(Self::Zklogin),
            "PASSKEY" => Some(Self::Passkey),
            _ => None,
        }
    }
}
/// A transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
    /// This Transaction serialized as BCS.
    #[prost(message, optional, tag = "1")]
    pub bcs: ::core::option::Option<Bcs>,
    /// The digest of this Transaction.
    #[prost(string, optional, tag = "2")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of this Transaction.
    #[prost(int32, optional, tag = "3")]
    pub version: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "4")]
    pub kind: ::core::option::Option<TransactionKind>,
    #[prost(string, optional, tag = "5")]
    pub sender: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub gas_payment: ::core::option::Option<GasPayment>,
    #[prost(message, optional, tag = "7")]
    pub expiration: ::core::option::Option<TransactionExpiration>,
}
/// Payment information for executing a transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GasPayment {
    /// Set of gas objects to use for payment.
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<ObjectReference>,
    /// Owner of the gas objects, either the transaction sender or a sponsor.
    #[prost(string, optional, tag = "2")]
    pub owner: ::core::option::Option<::prost::alloc::string::String>,
    /// Gas unit price to use when charging for computation.
    ///
    /// Must be greater than or equal to the network's current RGP (reference gas price).
    #[prost(uint64, optional, tag = "3")]
    pub price: ::core::option::Option<u64>,
    /// Total budget willing to spend for the execution of a transaction.
    #[prost(uint64, optional, tag = "4")]
    pub budget: ::core::option::Option<u64>,
}
/// A TTL for a transaction.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TransactionExpiration {
    #[prost(
        enumeration = "transaction_expiration::TransactionExpirationKind",
        optional,
        tag = "1"
    )]
    pub kind: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "2")]
    pub epoch: ::core::option::Option<u64>,
}
/// Nested message and enum types in `TransactionExpiration`.
pub mod transaction_expiration {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TransactionExpirationKind {
        Unknown = 0,
        /// The transaction has no expiration.
        None = 1,
        /// Validators won't sign and execute transaction unless the expiration epoch
        /// is greater than or equal to the current epoch.
        Epoch = 2,
    }
    impl TransactionExpirationKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "TRANSACTION_EXPIRATION_KIND_UNKNOWN",
                Self::None => "NONE",
                Self::Epoch => "EPOCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRANSACTION_EXPIRATION_KIND_UNKNOWN" => Some(Self::Unknown),
                "NONE" => Some(Self::None),
                "EPOCH" => Some(Self::Epoch),
                _ => None,
            }
        }
    }
}
/// Transaction type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionKind {
    #[prost(
        oneof = "transaction_kind::Kind",
        tags = "2, 100, 101, 102, 103, 104, 105, 106, 107, 108"
    )]
    pub kind: ::core::option::Option<transaction_kind::Kind>,
}
/// Nested message and enum types in `TransactionKind`.
pub mod transaction_kind {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// A user transaction comprised of a list of native commands and Move calls.
        #[prost(message, tag = "2")]
        ProgrammableTransaction(super::ProgrammableTransaction),
        /// System transaction used to end an epoch.
        ///
        /// The `ChangeEpoch` variant is now deprecated (but the `ChangeEpoch` struct is still used by
        /// `EndOfEpochTransaction`).
        #[prost(message, tag = "100")]
        ChangeEpoch(super::ChangeEpoch),
        /// Transaction used to initialize the chain state.
        ///
        /// Only valid if in the genesis checkpoint (0) and if this is the very first transaction ever
        /// executed on the chain.
        #[prost(message, tag = "101")]
        Genesis(super::GenesisTransaction),
        /// V1 consensus commit update.
        #[prost(message, tag = "102")]
        ConsensusCommitPrologueV1(super::ConsensusCommitPrologue),
        /// Update set of valid JWKs used for zklogin.
        #[prost(message, tag = "103")]
        AuthenticatorStateUpdate(super::AuthenticatorStateUpdate),
        /// Set of operations to run at the end of the epoch to close out the current epoch and start
        /// the next one.
        #[prost(message, tag = "104")]
        EndOfEpoch(super::EndOfEpochTransaction),
        /// Randomness update.
        #[prost(message, tag = "105")]
        RandomnessStateUpdate(super::RandomnessStateUpdate),
        /// V2 consensus commit update.
        #[prost(message, tag = "106")]
        ConsensusCommitPrologueV2(super::ConsensusCommitPrologue),
        /// V3 consensus commit update.
        #[prost(message, tag = "107")]
        ConsensusCommitPrologueV3(super::ConsensusCommitPrologue),
        /// V4 consensus commit update.
        #[prost(message, tag = "108")]
        ConsensusCommitPrologueV4(super::ConsensusCommitPrologue),
    }
}
/// A user transaction.
///
/// Contains a series of native commands and Move calls where the results of one command can be
/// used in future commands.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProgrammableTransaction {
    /// Input objects or primitive values.
    #[prost(message, repeated, tag = "1")]
    pub inputs: ::prost::alloc::vec::Vec<Input>,
    /// The commands to be executed sequentially. A failure in any command
    /// results in the failure of the entire transaction.
    #[prost(message, repeated, tag = "2")]
    pub commands: ::prost::alloc::vec::Vec<Command>,
}
/// A single command in a programmable transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Command {
    #[prost(oneof = "command::Command", tags = "1, 2, 3, 4, 5, 6, 7")]
    pub command: ::core::option::Option<command::Command>,
}
/// Nested message and enum types in `Command`.
pub mod command {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Command {
        /// A call to either an entry or a public Move function.
        #[prost(message, tag = "1")]
        MoveCall(super::MoveCall),
        /// `(Vec<forall T:key+store. T>, address)`
        /// It sends n-objects to the specified address. These objects must have store
        /// (public transfer) and either the previous owner must be an address or the object must
        /// be newly created.
        #[prost(message, tag = "2")]
        TransferObjects(super::TransferObjects),
        /// `(&mut Coin<T>, Vec<u64>)` -> `Vec<Coin<T>>`
        /// It splits off some amounts into new coins with those amounts.
        #[prost(message, tag = "3")]
        SplitCoins(super::SplitCoins),
        /// `(&mut Coin<T>, Vec<Coin<T>>)`
        /// It merges n-coins into the first coin.
        #[prost(message, tag = "4")]
        MergeCoins(super::MergeCoins),
        /// Publishes a Move package. It takes the package bytes and a list of the package's transitive
        /// dependencies to link against on chain.
        #[prost(message, tag = "5")]
        Publish(super::Publish),
        /// `forall T: Vec<T> -> vector<T>`
        /// Given n-values of the same type, it constructs a vector. For non-objects or an empty vector,
        /// the type tag must be specified.
        #[prost(message, tag = "6")]
        MakeMoveVector(super::MakeMoveVector),
        /// Upgrades a Move package.
        /// Takes (in order):
        /// 1. A vector of serialized modules for the package.
        /// 2. A vector of object ids for the transitive dependencies of the new package.
        /// 3. The object ID of the package being upgraded.
        /// 4. An argument holding the `UpgradeTicket` that must have been produced from an earlier command in the same
        ///     programmable transaction.
        #[prost(message, tag = "7")]
        Upgrade(super::Upgrade),
    }
}
/// Command to call a Move function.
///
/// Functions that can be called by a `MoveCall` command are those that have a function signature
/// that is either `entry` or `public` (which don't have a reference return type).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveCall {
    /// The package containing the module and function.
    #[prost(string, optional, tag = "1")]
    pub package: ::core::option::Option<::prost::alloc::string::String>,
    /// The specific module in the package containing the function.
    #[prost(string, optional, tag = "2")]
    pub module: ::core::option::Option<::prost::alloc::string::String>,
    /// The function to be called.
    #[prost(string, optional, tag = "3")]
    pub function: ::core::option::Option<::prost::alloc::string::String>,
    /// The type arguments to the function.
    #[prost(string, repeated, tag = "4")]
    pub type_arguments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The arguments to the function.
    #[prost(message, repeated, tag = "5")]
    pub arguments: ::prost::alloc::vec::Vec<Argument>,
}
/// Command to transfer ownership of a set of objects to an address.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferObjects {
    /// Set of objects to transfer.
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<Argument>,
    /// The address to transfer ownership to.
    #[prost(message, optional, tag = "2")]
    pub address: ::core::option::Option<Argument>,
}
/// Command to split a single coin object into multiple coins.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SplitCoins {
    /// The coin to split.
    #[prost(message, optional, tag = "1")]
    pub coin: ::core::option::Option<Argument>,
    /// The amounts to split off.
    #[prost(message, repeated, tag = "2")]
    pub amounts: ::prost::alloc::vec::Vec<Argument>,
}
/// Command to merge multiple coins of the same type into a single coin.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeCoins {
    /// Coin to merge coins into.
    #[prost(message, optional, tag = "1")]
    pub coin: ::core::option::Option<Argument>,
    /// Set of coins to merge into `coin`.
    ///
    /// All listed coins must be of the same type and be the same type as `coin`
    #[prost(message, repeated, tag = "2")]
    pub coins_to_merge: ::prost::alloc::vec::Vec<Argument>,
}
/// Command to publish a new Move package.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Publish {
    /// The serialized Move modules.
    #[prost(bytes = "bytes", repeated, tag = "1")]
    pub modules: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    /// Set of packages that the to-be published package depends on.
    #[prost(string, repeated, tag = "2")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Command to build a Move vector out of a set of individual elements.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MakeMoveVector {
    /// Type of the individual elements.
    ///
    /// This is required to be set when the type can't be inferred, for example when the set of
    /// provided arguments are all pure input values.
    #[prost(string, optional, tag = "1")]
    pub element_type: ::core::option::Option<::prost::alloc::string::String>,
    /// The set individual elements to build the vector with.
    #[prost(message, repeated, tag = "2")]
    pub elements: ::prost::alloc::vec::Vec<Argument>,
}
/// Command to upgrade an already published package.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Upgrade {
    /// The serialized Move modules.
    #[prost(bytes = "bytes", repeated, tag = "1")]
    pub modules: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    /// Set of packages that the to-be published package depends on.
    #[prost(string, repeated, tag = "2")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Package ID of the package to upgrade.
    #[prost(string, optional, tag = "3")]
    pub package: ::core::option::Option<::prost::alloc::string::String>,
    /// Ticket authorizing the upgrade.
    #[prost(message, optional, tag = "4")]
    pub ticket: ::core::option::Option<Argument>,
}
/// Randomness update.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RandomnessStateUpdate {
    /// Epoch of the randomness state update transaction.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// Randomness round of the update.
    #[prost(uint64, optional, tag = "2")]
    pub randomness_round: ::core::option::Option<u64>,
    /// Updated random bytes.
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub random_bytes: ::core::option::Option<::prost::bytes::Bytes>,
    /// The initial version of the randomness object that it was shared at.
    #[prost(uint64, optional, tag = "4")]
    pub randomness_object_initial_shared_version: ::core::option::Option<u64>,
}
/// System transaction used to change the epoch.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeEpoch {
    /// The next (to become) epoch ID.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// The protocol version in effect in the new epoch.
    #[prost(uint64, optional, tag = "2")]
    pub protocol_version: ::core::option::Option<u64>,
    /// The total amount of gas charged for storage during the epoch.
    #[prost(uint64, optional, tag = "3")]
    pub storage_charge: ::core::option::Option<u64>,
    /// The total amount of gas charged for computation during the epoch.
    #[prost(uint64, optional, tag = "4")]
    pub computation_charge: ::core::option::Option<u64>,
    /// The amount of storage rebate refunded to the txn senders.
    #[prost(uint64, optional, tag = "5")]
    pub storage_rebate: ::core::option::Option<u64>,
    /// The non-refundable storage fee.
    #[prost(uint64, optional, tag = "6")]
    pub non_refundable_storage_fee: ::core::option::Option<u64>,
    /// Unix timestamp when epoch started.
    #[prost(message, optional, tag = "7")]
    pub epoch_start_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// System packages (specifically framework and Move stdlib) that are written before the new
    /// epoch starts. This tracks framework upgrades on chain. When executing the `ChangeEpoch` txn,
    /// the validator must write out the following modules.  Modules are provided with the version they
    /// will be upgraded to, their modules in serialized form (which include their package ID), and
    /// a list of their transitive dependencies.
    #[prost(message, repeated, tag = "8")]
    pub system_packages: ::prost::alloc::vec::Vec<SystemPackage>,
}
/// System package.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemPackage {
    /// Version of the package.
    #[prost(uint64, optional, tag = "1")]
    pub version: ::core::option::Option<u64>,
    /// Move modules.
    #[prost(bytes = "bytes", repeated, tag = "2")]
    pub modules: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    /// Package dependencies.
    #[prost(string, repeated, tag = "3")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The genesis transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisTransaction {
    /// Set of genesis objects.
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<Object>,
}
/// Consensus commit prologue system transaction.
///
/// This message can represent V1, V2, and V3 prologue types.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusCommitPrologue {
    /// Epoch of the commit prologue transaction.
    ///
    /// Present in V1, V2, V3, V4.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// Consensus round of the commit.
    ///
    /// Present in V1, V2, V3, V4.
    #[prost(uint64, optional, tag = "2")]
    pub round: ::core::option::Option<u64>,
    /// Unix timestamp from consensus.
    ///
    /// Present in V1, V2, V3, V4.
    #[prost(message, optional, tag = "3")]
    pub commit_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Digest of consensus output.
    ///
    /// Present in V2, V3, V4.
    #[prost(string, optional, tag = "4")]
    pub consensus_commit_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The sub DAG index of the consensus commit. This field is populated if there
    /// are multiple consensus commits per round.
    ///
    /// Present in V3, V4.
    #[prost(uint64, optional, tag = "5")]
    pub sub_dag_index: ::core::option::Option<u64>,
    /// Stores consensus handler determined shared object version assignments.
    ///
    /// Present in V3, V4.
    #[prost(message, optional, tag = "6")]
    pub consensus_determined_version_assignments: ::core::option::Option<
        ConsensusDeterminedVersionAssignments,
    >,
    /// Digest of any additional state computed by the consensus handler.
    /// Used to detect forking bugs as early as possible.
    ///
    /// Present in V4.
    #[prost(string, optional, tag = "7")]
    pub additional_state_digest: ::core::option::Option<::prost::alloc::string::String>,
}
/// Object version assignment from consensus.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VersionAssignment {
    /// `ObjectId` of the object.
    #[prost(string, optional, tag = "1")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Assigned version.
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
}
/// A transaction that was canceled.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CanceledTransaction {
    /// Digest of the canceled transaction.
    #[prost(string, optional, tag = "1")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// List of object version assignments.
    #[prost(message, repeated, tag = "2")]
    pub version_assignments: ::prost::alloc::vec::Vec<VersionAssignment>,
}
/// Set of canceled transactions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CanceledTransactions {
    #[prost(message, repeated, tag = "1")]
    pub canceled_transactions: ::prost::alloc::vec::Vec<CanceledTransaction>,
}
/// Version assignments performed by consensus.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusDeterminedVersionAssignments {
    #[prost(oneof = "consensus_determined_version_assignments::Kind", tags = "2")]
    pub kind: ::core::option::Option<consensus_determined_version_assignments::Kind>,
}
/// Nested message and enum types in `ConsensusDeterminedVersionAssignments`.
pub mod consensus_determined_version_assignments {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// Canceled transaction version assignment.
        #[prost(message, tag = "2")]
        CanceledTransactions(super::CanceledTransactions),
    }
}
/// Update the set of valid JWKs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticatorStateUpdate {
    /// Epoch of the authenticator state update transaction.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// Consensus round of the authenticator state update.
    #[prost(uint64, optional, tag = "2")]
    pub round: ::core::option::Option<u64>,
    /// Newly active JWKs.
    #[prost(message, repeated, tag = "3")]
    pub new_active_jwks: ::prost::alloc::vec::Vec<ActiveJwk>,
    /// The initial version of the authenticator object that it was shared at.
    #[prost(uint64, optional, tag = "4")]
    pub authenticator_object_initial_shared_version: ::core::option::Option<u64>,
}
/// A new JWK.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActiveJwk {
    /// Identifier used to uniquely identify a JWK.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<JwkId>,
    /// The JWK.
    #[prost(message, optional, tag = "2")]
    pub jwk: ::core::option::Option<Jwk>,
    /// Most recent epoch in which the JWK was validated.
    #[prost(uint64, optional, tag = "3")]
    pub epoch: ::core::option::Option<u64>,
}
/// Key to uniquely identify a JWK.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JwkId {
    /// The issuer or identity of the OIDC provider.
    #[prost(string, optional, tag = "1")]
    pub iss: ::core::option::Option<::prost::alloc::string::String>,
    /// A key ID used to uniquely identify a key from an OIDC provider.
    #[prost(string, optional, tag = "2")]
    pub kid: ::core::option::Option<::prost::alloc::string::String>,
}
/// A JSON web key.
///
/// Struct that contains info for a JWK. A list of them for different kinds can
/// be retrieved from the JWK endpoint (for example, <<https://www.googleapis.com/oauth2/v3/certs>>).
/// The JWK is used to verify the JWT token.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Jwk {
    /// Key type parameter, <https://datatracker.ietf.org/doc/html/rfc7517#section-4.1.>
    #[prost(string, optional, tag = "1")]
    pub kty: ::core::option::Option<::prost::alloc::string::String>,
    /// RSA public exponent, <https://datatracker.ietf.org/doc/html/rfc7517#section-9.3.>
    #[prost(string, optional, tag = "2")]
    pub e: ::core::option::Option<::prost::alloc::string::String>,
    /// RSA modulus, <https://datatracker.ietf.org/doc/html/rfc7517#section-9.3.>
    #[prost(string, optional, tag = "3")]
    pub n: ::core::option::Option<::prost::alloc::string::String>,
    /// Algorithm parameter, <https://datatracker.ietf.org/doc/html/rfc7517#section-4.4.>
    #[prost(string, optional, tag = "4")]
    pub alg: ::core::option::Option<::prost::alloc::string::String>,
}
/// Set of operations run at the end of the epoch to close out the current epoch
/// and start the next one.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndOfEpochTransaction {
    #[prost(message, repeated, tag = "1")]
    pub transactions: ::prost::alloc::vec::Vec<EndOfEpochTransactionKind>,
}
/// Operation run at the end of an epoch.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndOfEpochTransactionKind {
    #[prost(
        oneof = "end_of_epoch_transaction_kind::Kind",
        tags = "2, 3, 4, 200, 201, 202, 203, 204"
    )]
    pub kind: ::core::option::Option<end_of_epoch_transaction_kind::Kind>,
}
/// Nested message and enum types in `EndOfEpochTransactionKind`.
pub mod end_of_epoch_transaction_kind {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// End the epoch and start the next one.
        #[prost(message, tag = "2")]
        ChangeEpoch(super::ChangeEpoch),
        /// Expire JWKs used for zklogin.
        #[prost(message, tag = "3")]
        AuthenticatorStateExpire(super::AuthenticatorStateExpire),
        /// Execution time observations from the committee to preserve cross epoch
        #[prost(message, tag = "4")]
        ExecutionTimeObservations(super::ExecutionTimeObservations),
        /// Create and initialize the authenticator object used for zklogin.
        #[prost(message, tag = "200")]
        AuthenticatorStateCreate(()),
        /// Create and initialize the randomness object.
        #[prost(message, tag = "201")]
        RandomnessStateCreate(()),
        /// Create and initialize the deny list object.
        #[prost(message, tag = "202")]
        DenyListStateCreate(()),
        /// Create and initialize the bridge object.
        #[prost(string, tag = "203")]
        BridgeStateCreate(::prost::alloc::string::String),
        /// Initialize the bridge committee.
        #[prost(uint64, tag = "204")]
        BridgeCommitteeInit(u64),
    }
}
/// Expire old JWKs.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AuthenticatorStateExpire {
    /// Expire JWKs that have a lower epoch than this.
    #[prost(uint64, optional, tag = "1")]
    pub min_epoch: ::core::option::Option<u64>,
    /// The initial version of the authenticator object that it was shared at.
    #[prost(uint64, optional, tag = "2")]
    pub authenticator_object_initial_shared_version: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionTimeObservations {
    /// Version of this ExecutionTimeObservations
    #[prost(int32, optional, tag = "1")]
    pub version: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "2")]
    pub observations: ::prost::alloc::vec::Vec<ExecutionTimeObservation>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionTimeObservation {
    #[prost(
        enumeration = "execution_time_observation::ExecutionTimeObservationKind",
        optional,
        tag = "1"
    )]
    pub kind: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub move_entry_point: ::core::option::Option<MoveCall>,
    #[prost(message, repeated, tag = "3")]
    pub validator_observations: ::prost::alloc::vec::Vec<
        ValidatorExecutionTimeObservation,
    >,
}
/// Nested message and enum types in `ExecutionTimeObservation`.
pub mod execution_time_observation {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExecutionTimeObservationKind {
        Unknown = 0,
        MoveEntryPoint = 1,
        TransferObjects = 2,
        SplitCoins = 3,
        MergeCoins = 4,
        Publish = 5,
        MakeMoveVector = 6,
        Upgrade = 7,
    }
    impl ExecutionTimeObservationKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "EXECUTION_TIME_OBSERVATION_KIND_UNKNOWN",
                Self::MoveEntryPoint => "MOVE_ENTRY_POINT",
                Self::TransferObjects => "TRANSFER_OBJECTS",
                Self::SplitCoins => "SPLIT_COINS",
                Self::MergeCoins => "MERGE_COINS",
                Self::Publish => "PUBLISH",
                Self::MakeMoveVector => "MAKE_MOVE_VECTOR",
                Self::Upgrade => "UPGRADE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXECUTION_TIME_OBSERVATION_KIND_UNKNOWN" => Some(Self::Unknown),
                "MOVE_ENTRY_POINT" => Some(Self::MoveEntryPoint),
                "TRANSFER_OBJECTS" => Some(Self::TransferObjects),
                "SPLIT_COINS" => Some(Self::SplitCoins),
                "MERGE_COINS" => Some(Self::MergeCoins),
                "PUBLISH" => Some(Self::Publish),
                "MAKE_MOVE_VECTOR" => Some(Self::MakeMoveVector),
                "UPGRADE" => Some(Self::Upgrade),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorExecutionTimeObservation {
    /// Bls12381 public key of the validator
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub validator: ::core::option::Option<::prost::bytes::Bytes>,
    /// Duration of an execution observation
    #[prost(message, optional, tag = "2")]
    pub duration: ::core::option::Option<::prost_types::Duration>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteTransactionRequest {
    /// The transaction to execute.
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<Transaction>,
    /// Set of `UserSiganture`s authorizing the execution of the provided
    /// transaction.
    #[prost(message, repeated, tag = "2")]
    pub signatures: ::prost::alloc::vec::Vec<UserSignature>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `finality`.
    #[prost(message, optional, tag = "3")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Response message for `NodeService.ExecuteTransaction`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteTransactionResponse {
    /// Indicates the finality of the executed transaction.
    #[prost(message, optional, tag = "1")]
    pub finality: ::core::option::Option<TransactionFinality>,
    #[prost(message, optional, tag = "2")]
    pub transaction: ::core::option::Option<ExecutedTransaction>,
}
/// Indicates the finality of the executed transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionFinality {
    #[prost(oneof = "transaction_finality::Finality", tags = "1, 2, 3")]
    pub finality: ::core::option::Option<transaction_finality::Finality>,
}
/// Nested message and enum types in `TransactionFinality`.
pub mod transaction_finality {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Finality {
        /// A quorum certificate certifying that a transaction is final but might not
        /// be included in a checkpoint yet.
        #[prost(message, tag = "1")]
        Certified(super::ValidatorAggregatedSignature),
        /// Sequence number of the checkpoint that includes the transaction.
        #[prost(uint64, tag = "2")]
        Checkpointed(u64),
        /// Indicates that a quorum of validators has executed the transaction but
        /// that it might not be included in a checkpoint yet.
        #[prost(message, tag = "3")]
        QuorumExecuted(()),
    }
}
/// Generated client implementations.
pub mod transaction_execution_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct TransactionExecutionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl TransactionExecutionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> TransactionExecutionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TransactionExecutionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            TransactionExecutionServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn execute_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::ExecuteTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExecuteTransactionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta.TransactionExecutionService/ExecuteTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "sui.rpc.v2beta.TransactionExecutionService",
                        "ExecuteTransaction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod transaction_execution_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with TransactionExecutionServiceServer.
    #[async_trait]
    pub trait TransactionExecutionService: std::marker::Send + std::marker::Sync + 'static {
        async fn execute_transaction(
            &self,
            request: tonic::Request<super::ExecuteTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExecuteTransactionResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct TransactionExecutionServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> TransactionExecutionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for TransactionExecutionServiceServer<T>
    where
        T: TransactionExecutionService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/sui.rpc.v2beta.TransactionExecutionService/ExecuteTransaction" => {
                    #[allow(non_camel_case_types)]
                    struct ExecuteTransactionSvc<T: TransactionExecutionService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: TransactionExecutionService,
                    > tonic::server::UnaryService<super::ExecuteTransactionRequest>
                    for ExecuteTransactionSvc<T> {
                        type Response = super::ExecuteTransactionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExecuteTransactionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TransactionExecutionService>::execute_transaction(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ExecuteTransactionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for TransactionExecutionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "sui.rpc.v2beta.TransactionExecutionService";
    impl<T> tonic::server::NamedService for TransactionExecutionServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
