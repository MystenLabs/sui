// This file is @generated by prost-build.
/// An argument to a programmable transaction command.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Argument {
    #[prost(enumeration = "argument::ArgumentKind", optional, tag = "1")]
    pub kind: ::core::option::Option<i32>,
    /// Index of an input when `kind` is `INPUT`.
    #[prost(uint32, optional, tag = "2")]
    pub input: ::core::option::Option<u32>,
    /// Index of a result when `kind` is `RESULT`.
    #[prost(uint32, optional, tag = "3")]
    pub result: ::core::option::Option<u32>,
    /// Used to access a nested result when `kind` is `RESULT`.
    #[prost(uint32, optional, tag = "4")]
    pub subresult: ::core::option::Option<u32>,
}
/// Nested message and enum types in `Argument`.
pub mod argument {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ArgumentKind {
        Unknown = 0,
        /// The gas coin.
        Gas = 1,
        /// One of the input objects or primitive values (from
        /// `ProgrammableTransaction` inputs).
        Input = 2,
        /// The result of another command (from `ProgrammableTransaction` commands).
        Result = 3,
    }
    impl ArgumentKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "ARGUMENT_KIND_UNKNOWN",
                Self::Gas => "GAS",
                Self::Input => "INPUT",
                Self::Result => "RESULT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ARGUMENT_KIND_UNKNOWN" => Some(Self::Unknown),
                "GAS" => Some(Self::Gas),
                "INPUT" => Some(Self::Input),
                "RESULT" => Some(Self::Result),
                _ => None,
            }
        }
    }
}
/// The delta, or change, in balance for an address for a particular `Coin` type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BalanceChange {
    /// The account address that is affected by this balance change event.
    #[prost(string, optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    /// The `Coin` type of this balance change event.
    #[prost(string, optional, tag = "2")]
    pub coin_type: ::core::option::Option<::prost::alloc::string::String>,
    /// The amount or change in balance.
    #[prost(string, optional, tag = "3")]
    pub amount: ::core::option::Option<::prost::alloc::string::String>,
}
/// `Bcs` contains an arbitrary type that is serialized using the
/// [BCS](<https://mystenlabs.github.io/sui-rust-sdk/sui_sdk_types/index.html#bcs>)
/// format as well as a name that identifies the type of the serialized value.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bcs {
    /// Name that identifies the type of the serialized value.
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Bytes of a BCS serialized value.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub value: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Checkpoint {
    /// The height of this checkpoint.
    #[prost(uint64, optional, tag = "1")]
    pub sequence_number: ::core::option::Option<u64>,
    /// The digest of this Checkpoint's CheckpointSummary.
    #[prost(string, optional, tag = "2")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The `CheckpointSummary` for this checkpoint.
    #[prost(message, optional, tag = "3")]
    pub summary: ::core::option::Option<CheckpointSummary>,
    /// An aggregated quorum signature from the validator committee that
    /// certified this checkpoint.
    #[prost(message, optional, tag = "4")]
    pub signature: ::core::option::Option<ValidatorAggregatedSignature>,
    /// The `CheckpointContents` for this checkpoint.
    #[prost(message, optional, tag = "5")]
    pub contents: ::core::option::Option<CheckpointContents>,
    /// List of transactions included in this checkpoint.
    #[prost(message, repeated, tag = "6")]
    pub transactions: ::prost::alloc::vec::Vec<ExecutedTransaction>,
}
/// The committed to contents of a checkpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointContents {
    /// This CheckpointContents serialized as BCS.
    #[prost(message, optional, tag = "1")]
    pub bcs: ::core::option::Option<Bcs>,
    /// The digest of this CheckpointContents.
    #[prost(string, optional, tag = "2")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of this CheckpointContents
    #[prost(int32, optional, tag = "3")]
    pub version: ::core::option::Option<i32>,
    /// Set of transactions committed to in this checkpoint.
    #[prost(message, repeated, tag = "4")]
    pub transactions: ::prost::alloc::vec::Vec<CheckpointedTransactionInfo>,
}
/// Transaction information committed to in a checkpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointedTransactionInfo {
    /// Digest of the transaction.
    #[prost(string, optional, tag = "1")]
    pub transaction: ::core::option::Option<::prost::alloc::string::String>,
    /// Digest of the effects.
    #[prost(string, optional, tag = "2")]
    pub effects: ::core::option::Option<::prost::alloc::string::String>,
    /// Set of user signatures that authorized the transaction.
    #[prost(message, repeated, tag = "3")]
    pub signatures: ::prost::alloc::vec::Vec<UserSignature>,
}
/// A header for a checkpoint on the Sui blockchain.
///
/// On the Sui network, checkpoints define the history of the blockchain. They are quite similar to
/// the concept of blocks used by other blockchains like Bitcoin or Ethereum. The Sui blockchain,
/// however, forms checkpoints after transaction execution has already happened to provide a
/// certified history of the chain, instead of being formed before execution.
///
/// Checkpoints commit to a variety of state, including but not limited to:
/// - The hash of the previous checkpoint.
/// - The set of transaction digests, their corresponding effects digests, as well as the set of
///    user signatures that authorized its execution.
/// - The objects produced by a transaction.
/// - The set of live objects that make up the current state of the chain.
/// - On epoch transitions, the next validator committee.
///
/// `CheckpointSummary`s themselves don't directly include all of the previous information but they
/// are the top-level type by which all the information is committed to transitively via cryptographic
/// hashes included in the summary. `CheckpointSummary`s are signed and certified by a quorum of
/// the validator committee in a given epoch to allow verification of the chain's state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointSummary {
    /// This CheckpointSummary serialized as BCS.
    #[prost(message, optional, tag = "1")]
    pub bcs: ::core::option::Option<Bcs>,
    /// The digest of this CheckpointSummary.
    #[prost(string, optional, tag = "2")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Epoch that this checkpoint belongs to.
    #[prost(uint64, optional, tag = "3")]
    pub epoch: ::core::option::Option<u64>,
    /// The height of this checkpoint.
    #[prost(uint64, optional, tag = "4")]
    pub sequence_number: ::core::option::Option<u64>,
    /// Total number of transactions committed since genesis, including those in this
    /// checkpoint.
    #[prost(uint64, optional, tag = "5")]
    pub total_network_transactions: ::core::option::Option<u64>,
    /// The hash of the `CheckpointContents` for this checkpoint.
    #[prost(string, optional, tag = "6")]
    pub content_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The hash of the previous `CheckpointSummary`.
    ///
    /// This will be `None` only for the first, or genesis, checkpoint.
    #[prost(string, optional, tag = "7")]
    pub previous_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The running total gas costs of all transactions included in the current epoch so far
    /// until this checkpoint.
    #[prost(message, optional, tag = "8")]
    pub epoch_rolling_gas_cost_summary: ::core::option::Option<GasCostSummary>,
    /// Timestamp of the checkpoint - number of milliseconds from the Unix epoch
    /// Checkpoint timestamps are monotonic, but not strongly monotonic - subsequent
    /// checkpoints can have the same timestamp if they originate from the same underlining consensus commit.
    #[prost(message, optional, tag = "9")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Commitments to checkpoint-specific state.
    #[prost(message, repeated, tag = "10")]
    pub commitments: ::prost::alloc::vec::Vec<CheckpointCommitment>,
    /// Extra data only present in the final checkpoint of an epoch.
    #[prost(message, optional, tag = "11")]
    pub end_of_epoch_data: ::core::option::Option<EndOfEpochData>,
    /// `CheckpointSummary` is not an evolvable structure - it must be readable by any version of
    /// the code. Therefore, to allow extensions to be added to `CheckpointSummary`,
    /// opaque data can be added to checkpoints, which can be deserialized based on the current
    /// protocol version.
    #[prost(bytes = "bytes", optional, tag = "12")]
    pub version_specific_data: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Data, which when included in a `CheckpointSummary`, signals the end of an `Epoch`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndOfEpochData {
    /// The set of validators that will be in the `ValidatorCommittee` for the next epoch.
    #[prost(message, repeated, tag = "1")]
    pub next_epoch_committee: ::prost::alloc::vec::Vec<ValidatorCommitteeMember>,
    /// The protocol version that is in effect during the next epoch.
    #[prost(uint64, optional, tag = "2")]
    pub next_epoch_protocol_version: ::core::option::Option<u64>,
    /// Commitments to epoch specific state (live object set)
    #[prost(message, repeated, tag = "3")]
    pub epoch_commitments: ::prost::alloc::vec::Vec<CheckpointCommitment>,
}
/// A commitment made by a checkpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointCommitment {
    #[prost(
        enumeration = "checkpoint_commitment::CheckpointCommitmentKind",
        optional,
        tag = "1"
    )]
    pub kind: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `CheckpointCommitment`.
pub mod checkpoint_commitment {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CheckpointCommitmentKind {
        Unknown = 0,
        /// An elliptic curve multiset hash attesting to the set of objects that
        /// comprise the live state of the Sui blockchain.
        EcmhLiveObjectSet = 1,
    }
    impl CheckpointCommitmentKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "CHECKPOINT_COMMITMENT_KIND_UNKNOWN",
                Self::EcmhLiveObjectSet => "ECMH_LIVE_OBJECT_SET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CHECKPOINT_COMMITMENT_KIND_UNKNOWN" => Some(Self::Unknown),
                "ECMH_LIVE_OBJECT_SET" => Some(Self::EcmhLiveObjectSet),
                _ => None,
            }
        }
    }
}
/// The effects of executing a transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionEffects {
    /// This TransactionEffects serialized as BCS.
    #[prost(message, optional, tag = "1")]
    pub bcs: ::core::option::Option<Bcs>,
    /// The digest of this TransactionEffects.
    #[prost(string, optional, tag = "2")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of this TransactionEffects.
    #[prost(int32, optional, tag = "3")]
    pub version: ::core::option::Option<i32>,
    /// The status of the execution.
    #[prost(message, optional, tag = "4")]
    pub status: ::core::option::Option<ExecutionStatus>,
    /// The epoch when this transaction was executed.
    #[prost(uint64, optional, tag = "5")]
    pub epoch: ::core::option::Option<u64>,
    /// The gas used by this transaction.
    #[prost(message, optional, tag = "6")]
    pub gas_used: ::core::option::Option<GasCostSummary>,
    /// The transaction digest.
    #[prost(string, optional, tag = "7")]
    pub transaction_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Information about the gas object. Also present in the `changed_objects` vector.
    ///
    /// System transaction that don't require gas will leave this as `None`.
    #[prost(message, optional, tag = "8")]
    pub gas_object: ::core::option::Option<ChangedObject>,
    /// The digest of the events emitted during execution,
    /// can be `None` if the transaction does not emit any event.
    #[prost(string, optional, tag = "9")]
    pub events_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The set of transaction digests this transaction depends on.
    #[prost(string, repeated, tag = "10")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The version number of all the written objects (excluding packages) by this transaction.
    #[prost(uint64, optional, tag = "11")]
    pub lamport_version: ::core::option::Option<u64>,
    /// Objects whose state are changed by this transaction.
    #[prost(message, repeated, tag = "12")]
    pub changed_objects: ::prost::alloc::vec::Vec<ChangedObject>,
    /// Shared objects that are not mutated in this transaction. Unlike owned objects,
    /// read-only shared objects' version are not committed in the transaction,
    /// and in order for a node to catch up and execute it without consensus sequencing,
    /// the version needs to be committed in the effects.
    #[prost(message, repeated, tag = "13")]
    pub unchanged_shared_objects: ::prost::alloc::vec::Vec<UnchangedSharedObject>,
    /// Auxiliary data that are not protocol-critical, generated as part of the effects but are stored separately.
    /// Storing it separately allows us to avoid bloating the effects with data that are not critical.
    /// It also provides more flexibility on the format and type of the data.
    #[prost(string, optional, tag = "14")]
    pub auxiliary_data_digest: ::core::option::Option<::prost::alloc::string::String>,
}
/// Input/output state of an object that was changed during execution.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangedObject {
    /// ID of the object.
    #[prost(string, optional, tag = "1")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "changed_object::InputObjectState", optional, tag = "2")]
    pub input_state: ::core::option::Option<i32>,
    /// Version of the object before this transaction executed.
    #[prost(uint64, optional, tag = "3")]
    pub input_version: ::core::option::Option<u64>,
    /// Digest of the object before this transaction executed.
    #[prost(string, optional, tag = "4")]
    pub input_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Owner of the object before this transaction executed.
    #[prost(message, optional, tag = "5")]
    pub input_owner: ::core::option::Option<Owner>,
    #[prost(enumeration = "changed_object::OutputObjectState", optional, tag = "6")]
    pub output_state: ::core::option::Option<i32>,
    /// Version of the object after this transaction executed.
    #[prost(uint64, optional, tag = "7")]
    pub output_version: ::core::option::Option<u64>,
    /// Digest of the object after this transaction executed.
    #[prost(string, optional, tag = "8")]
    pub output_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Owner of the object after this transaction executed.
    #[prost(message, optional, tag = "9")]
    pub output_owner: ::core::option::Option<Owner>,
    /// What happened to an `ObjectId` during execution.
    #[prost(enumeration = "changed_object::IdOperation", optional, tag = "10")]
    pub id_operation: ::core::option::Option<i32>,
    /// Type information is not provided by the effects structure but is instead
    /// provided by an indexing layer
    #[prost(string, optional, tag = "11")]
    pub object_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ChangedObject`.
pub mod changed_object {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InputObjectState {
        Unknown = 0,
        DoesNotExist = 1,
        Exists = 2,
    }
    impl InputObjectState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "INPUT_OBJECT_STATE_UNKNOWN",
                Self::DoesNotExist => "INPUT_OBJECT_STATE_DOES_NOT_EXIST",
                Self::Exists => "INPUT_OBJECT_STATE_EXISTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INPUT_OBJECT_STATE_UNKNOWN" => Some(Self::Unknown),
                "INPUT_OBJECT_STATE_DOES_NOT_EXIST" => Some(Self::DoesNotExist),
                "INPUT_OBJECT_STATE_EXISTS" => Some(Self::Exists),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OutputObjectState {
        Unknown = 0,
        DoesNotExist = 1,
        ObjectWrite = 2,
        PackageWrite = 3,
    }
    impl OutputObjectState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "OUTPUT_OBJECT_STATE_UNKNOWN",
                Self::DoesNotExist => "OUTPUT_OBJECT_STATE_DOES_NOT_EXIST",
                Self::ObjectWrite => "OUTPUT_OBJECT_STATE_OBJECT_WRITE",
                Self::PackageWrite => "OUTPUT_OBJECT_STATE_PACKAGE_WRITE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OUTPUT_OBJECT_STATE_UNKNOWN" => Some(Self::Unknown),
                "OUTPUT_OBJECT_STATE_DOES_NOT_EXIST" => Some(Self::DoesNotExist),
                "OUTPUT_OBJECT_STATE_OBJECT_WRITE" => Some(Self::ObjectWrite),
                "OUTPUT_OBJECT_STATE_PACKAGE_WRITE" => Some(Self::PackageWrite),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IdOperation {
        Unknown = 0,
        None = 1,
        Created = 2,
        Deleted = 3,
    }
    impl IdOperation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "ID_OPERATION_UNKNOWN",
                Self::None => "NONE",
                Self::Created => "CREATED",
                Self::Deleted => "DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ID_OPERATION_UNKNOWN" => Some(Self::Unknown),
                "NONE" => Some(Self::None),
                "CREATED" => Some(Self::Created),
                "DELETED" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
}
/// A shared object that wasn't changed during execution.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnchangedSharedObject {
    #[prost(
        enumeration = "unchanged_shared_object::UnchangedSharedObjectKind",
        optional,
        tag = "1"
    )]
    pub kind: ::core::option::Option<i32>,
    /// ObjectId of the shared object.
    #[prost(string, optional, tag = "2")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of the shared object.
    #[prost(uint64, optional, tag = "3")]
    pub version: ::core::option::Option<u64>,
    /// Digest of the shared object.
    #[prost(string, optional, tag = "4")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Type information is not provided by the effects structure but is instead
    /// provided by an indexing layer
    #[prost(string, optional, tag = "5")]
    pub object_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `UnchangedSharedObject`.
pub mod unchanged_shared_object {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UnchangedSharedObjectKind {
        Unknown = 0,
        /// Read-only shared object from the input.
        ReadOnlyRoot = 1,
        /// Deleted shared objects that appear mutably/owned in the input.
        MutateDeleted = 2,
        /// Deleted shared objects that appear as read-only in the input.
        ReadDeleted = 3,
        /// Shared objects that was congested and resulted in this transaction being
        /// canceled.
        Canceled = 4,
        /// Read of a per-epoch config object that should remain the same during an
        /// epoch. This optionally will indicate the sequence number of the config
        /// object at the start of the epoch.
        PerEpochConfig = 5,
    }
    impl UnchangedSharedObjectKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNCHANGED_SHARED_OBJECT_KIND_UNKNOWN",
                Self::ReadOnlyRoot => "READ_ONLY_ROOT",
                Self::MutateDeleted => "MUTATE_DELETED",
                Self::ReadDeleted => "READ_DELETED",
                Self::Canceled => "CANCELED",
                Self::PerEpochConfig => "PER_EPOCH_CONFIG",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNCHANGED_SHARED_OBJECT_KIND_UNKNOWN" => Some(Self::Unknown),
                "READ_ONLY_ROOT" => Some(Self::ReadOnlyRoot),
                "MUTATE_DELETED" => Some(Self::MutateDeleted),
                "READ_DELETED" => Some(Self::ReadDeleted),
                "CANCELED" => Some(Self::Canceled),
                "PER_EPOCH_CONFIG" => Some(Self::PerEpochConfig),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Epoch {
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// The committee governing this epoch.
    #[prost(message, optional, tag = "2")]
    pub committee: ::core::option::Option<ValidatorCommittee>,
    /// Snapshot of Sui's SystemState (`0x3::sui_system::SystemState`) at the
    /// beginning of the epoch, for past epochs, or the current state for the
    /// current epoch.
    #[prost(message, optional, boxed, tag = "3")]
    pub system_state: ::core::option::Option<::prost::alloc::boxed::Box<SystemState>>,
    #[prost(uint64, optional, tag = "4")]
    pub first_checkpoint: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub last_checkpoint: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "6")]
    pub start: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub end: ::core::option::Option<::prost_types::Timestamp>,
    /// Reference gas price denominated in MIST
    #[prost(uint64, optional, tag = "8")]
    pub reference_gas_price: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "9")]
    pub protocol_config: ::core::option::Option<ProtocolConfig>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorReason {
    Unknown = 0,
    FieldInvalid = 1,
    FieldMissing = 2,
}
impl ErrorReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ERROR_REASON_UNKNOWN",
            Self::FieldInvalid => "FIELD_INVALID",
            Self::FieldMissing => "FIELD_MISSING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ERROR_REASON_UNKNOWN" => Some(Self::Unknown),
            "FIELD_INVALID" => Some(Self::FieldInvalid),
            "FIELD_MISSING" => Some(Self::FieldMissing),
            _ => None,
        }
    }
}
/// Events emitted during the successful execution of a transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionEvents {
    /// This TransactionEvents serialized as BCS.
    #[prost(message, optional, tag = "1")]
    pub bcs: ::core::option::Option<Bcs>,
    /// The digest of this TransactionEvents.
    #[prost(string, optional, tag = "2")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Set of events emitted by a transaction.
    #[prost(message, repeated, tag = "3")]
    pub events: ::prost::alloc::vec::Vec<Event>,
}
/// An event.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    /// Package ID of the top-level function invoked by a `MoveCall` command that triggered this
    /// event to be emitted.
    #[prost(string, optional, tag = "1")]
    pub package_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Module name of the top-level function invoked by a `MoveCall` command that triggered this
    /// event to be emitted.
    #[prost(string, optional, tag = "2")]
    pub module: ::core::option::Option<::prost::alloc::string::String>,
    /// Address of the account that sent the transaction where this event was emitted.
    #[prost(string, optional, tag = "3")]
    pub sender: ::core::option::Option<::prost::alloc::string::String>,
    /// The type of the event emitted.
    #[prost(string, optional, tag = "4")]
    pub event_type: ::core::option::Option<::prost::alloc::string::String>,
    /// BCS serialized bytes of the event.
    #[prost(message, optional, tag = "5")]
    pub contents: ::core::option::Option<Bcs>,
    /// JSON rendering of the event.
    #[prost(message, optional, boxed, tag = "6")]
    pub json: ::core::option::Option<::prost::alloc::boxed::Box<::prost_types::Value>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutedTransaction {
    /// The digest of this Transaction.
    #[prost(string, optional, tag = "1")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The transaction itself.
    #[prost(message, optional, tag = "2")]
    pub transaction: ::core::option::Option<Transaction>,
    /// List of user signatures that are used to authorize the
    /// execution of this transaction.
    #[prost(message, repeated, tag = "3")]
    pub signatures: ::prost::alloc::vec::Vec<UserSignature>,
    /// The `TransactionEffects` for this transaction.
    #[prost(message, optional, tag = "4")]
    pub effects: ::core::option::Option<TransactionEffects>,
    /// The `TransactionEvents` for this transaction.
    ///
    /// This field might be empty, even if it was explicitly requested, if the
    /// transaction didn't produce any events.
    /// `sui.types.TransactionEffects.events_digest` is populated if the
    /// transaction produced any events.
    #[prost(message, optional, tag = "5")]
    pub events: ::core::option::Option<TransactionEvents>,
    /// The sequence number for the checkpoint that includes this transaction.
    #[prost(uint64, optional, tag = "6")]
    pub checkpoint: ::core::option::Option<u64>,
    /// The Unix timestamp of the checkpoint that includes this transaction.
    #[prost(message, optional, tag = "7")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "8")]
    pub balance_changes: ::prost::alloc::vec::Vec<BalanceChange>,
    /// Set of input objects used during the execution of this transaction.
    #[prost(message, repeated, tag = "10")]
    pub input_objects: ::prost::alloc::vec::Vec<Object>,
    /// Set of output objects produced from the execution of this transaction.
    #[prost(message, repeated, tag = "11")]
    pub output_objects: ::prost::alloc::vec::Vec<Object>,
}
/// The status of an executed transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionStatus {
    /// Indicates if the transaction was successful or not.
    #[prost(bool, optional, tag = "1")]
    pub success: ::core::option::Option<bool>,
    /// The error if `success` is false.
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<ExecutionError>,
}
/// An error that can occur during the execution of a transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionError {
    /// A human readable description of the error
    #[prost(string, optional, tag = "1")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// The command, if any, during which the error occurred.
    #[prost(uint64, optional, tag = "2")]
    pub command: ::core::option::Option<u64>,
    #[prost(enumeration = "execution_error::ExecutionErrorKind", optional, tag = "3")]
    pub kind: ::core::option::Option<i32>,
    #[prost(
        oneof = "execution_error::ErrorDetails",
        tags = "4, 5, 6, 7, 8, 9, 10, 11, 12"
    )]
    pub error_details: ::core::option::Option<execution_error::ErrorDetails>,
}
/// Nested message and enum types in `ExecutionError`.
pub mod execution_error {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExecutionErrorKind {
        Unknown = 0,
        /// Insufficient gas.
        InsufficientGas = 1,
        /// Invalid `Gas` object.
        InvalidGasObject = 2,
        /// Invariant violation.
        InvariantViolation = 3,
        /// Attempted to use feature that is not supported yet.
        FeatureNotYetSupported = 4,
        /// Move object is larger than the maximum allowed size.
        ObjectTooBig = 5,
        /// Package is larger than the maximum allowed size.
        PackageTooBig = 6,
        /// Circular object ownership.
        CircularObjectOwnership = 7,
        /// Insufficient coin balance for requested operation.
        InsufficientCoinBalance = 8,
        /// Coin balance overflowed an u64.
        CoinBalanceOverflow = 9,
        /// Publish error, non-zero address.
        /// The modules in the package must have their self-addresses set to zero.
        PublishErrorNonZeroAddress = 10,
        /// Sui Move bytecode verification error.
        SuiMoveVerificationError = 11,
        /// Error from a non-abort instruction.
        /// Possible causes:
        ///      Arithmetic error, stack overflow, max value depth, or similar.
        MovePrimitiveRuntimeError = 12,
        /// Move runtime abort.
        MoveAbort = 13,
        /// Bytecode verification error.
        VmVerificationOrDeserializationError = 14,
        /// MoveVm invariant violation.
        VmInvariantViolation = 15,
        /// Function not found.
        FunctionNotFound = 16,
        /// Parity mismatch for Move function.
        /// The number of arguments does not match the number of parameters.
        ArityMismatch = 17,
        /// Type parity mismatch for Move function.
        /// Mismatch between the number of actual versus expected type arguments.
        TypeArityMismatch = 18,
        /// Non-entry function invoked. Move Call must start with an entry function.
        NonEntryFunctionInvoked = 19,
        /// Invalid command argument.
        CommandArgumentError = 20,
        /// Type argument error.
        TypeArgumentError = 21,
        /// Unused result without the drop ability.
        UnusedValueWithoutDrop = 22,
        /// Invalid public Move function signature.
        /// Unsupported return type for return value.
        InvalidPublicFunctionReturnType = 23,
        /// Invalid transfer object, object does not have public transfer.
        InvalidTransferObject = 24,
        /// Effects from the transaction are too large.
        EffectsTooLarge = 25,
        /// Publish or Upgrade is missing dependency.
        PublishUpgradeMissingDependency = 26,
        /// Publish or upgrade dependency downgrade.
        ///
        /// Indirect (transitive) dependency of published or upgraded package has been assigned an
        /// on-chain version that is less than the version required by one of the package's
        /// transitive dependencies.
        PublishUpgradeDependencyDowngrade = 27,
        /// Invalid package upgrade.
        PackageUpgradeError = 28,
        /// Indicates the transaction tried to write objects too large to storage.
        WrittenObjectsTooLarge = 29,
        /// Certificate is on the deny list.
        CertificateDenied = 30,
        /// Sui Move bytecode verification timed out.
        SuiMoveVerificationTimedout = 31,
        /// The requested shared object operation is not allowed.
        SharedObjectOperationNotAllowed = 32,
        /// Requested shared object has been deleted.
        InputObjectDeleted = 33,
        /// Certificate is canceled due to congestion on shared objects.
        ExecutionCanceledDueToSharedObjectCongestion = 34,
        /// Address is denied for this coin type.
        AddressDeniedForCoin = 35,
        /// Coin type is globally paused for use.
        CoinTypeGlobalPause = 36,
        /// Certificate is canceled because randomness could not be generated this epoch.
        ExecutionCanceledDueToRandomnessUnavailable = 37,
        MoveVectorElemTooBig = 38,
        MoveRawValueTooBig = 39,
        InvalidLinkage = 40,
    }
    impl ExecutionErrorKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "EXECUTION_ERROR_KIND_UNKNOWN",
                Self::InsufficientGas => "INSUFFICIENT_GAS",
                Self::InvalidGasObject => "INVALID_GAS_OBJECT",
                Self::InvariantViolation => "INVARIANT_VIOLATION",
                Self::FeatureNotYetSupported => "FEATURE_NOT_YET_SUPPORTED",
                Self::ObjectTooBig => "OBJECT_TOO_BIG",
                Self::PackageTooBig => "PACKAGE_TOO_BIG",
                Self::CircularObjectOwnership => "CIRCULAR_OBJECT_OWNERSHIP",
                Self::InsufficientCoinBalance => "INSUFFICIENT_COIN_BALANCE",
                Self::CoinBalanceOverflow => "COIN_BALANCE_OVERFLOW",
                Self::PublishErrorNonZeroAddress => "PUBLISH_ERROR_NON_ZERO_ADDRESS",
                Self::SuiMoveVerificationError => "SUI_MOVE_VERIFICATION_ERROR",
                Self::MovePrimitiveRuntimeError => "MOVE_PRIMITIVE_RUNTIME_ERROR",
                Self::MoveAbort => "MOVE_ABORT",
                Self::VmVerificationOrDeserializationError => {
                    "VM_VERIFICATION_OR_DESERIALIZATION_ERROR"
                }
                Self::VmInvariantViolation => "VM_INVARIANT_VIOLATION",
                Self::FunctionNotFound => "FUNCTION_NOT_FOUND",
                Self::ArityMismatch => "ARITY_MISMATCH",
                Self::TypeArityMismatch => "TYPE_ARITY_MISMATCH",
                Self::NonEntryFunctionInvoked => "NON_ENTRY_FUNCTION_INVOKED",
                Self::CommandArgumentError => "COMMAND_ARGUMENT_ERROR",
                Self::TypeArgumentError => "TYPE_ARGUMENT_ERROR",
                Self::UnusedValueWithoutDrop => "UNUSED_VALUE_WITHOUT_DROP",
                Self::InvalidPublicFunctionReturnType => {
                    "INVALID_PUBLIC_FUNCTION_RETURN_TYPE"
                }
                Self::InvalidTransferObject => "INVALID_TRANSFER_OBJECT",
                Self::EffectsTooLarge => "EFFECTS_TOO_LARGE",
                Self::PublishUpgradeMissingDependency => {
                    "PUBLISH_UPGRADE_MISSING_DEPENDENCY"
                }
                Self::PublishUpgradeDependencyDowngrade => {
                    "PUBLISH_UPGRADE_DEPENDENCY_DOWNGRADE"
                }
                Self::PackageUpgradeError => "PACKAGE_UPGRADE_ERROR",
                Self::WrittenObjectsTooLarge => "WRITTEN_OBJECTS_TOO_LARGE",
                Self::CertificateDenied => "CERTIFICATE_DENIED",
                Self::SuiMoveVerificationTimedout => "SUI_MOVE_VERIFICATION_TIMEDOUT",
                Self::SharedObjectOperationNotAllowed => {
                    "SHARED_OBJECT_OPERATION_NOT_ALLOWED"
                }
                Self::InputObjectDeleted => "INPUT_OBJECT_DELETED",
                Self::ExecutionCanceledDueToSharedObjectCongestion => {
                    "EXECUTION_CANCELED_DUE_TO_SHARED_OBJECT_CONGESTION"
                }
                Self::AddressDeniedForCoin => "ADDRESS_DENIED_FOR_COIN",
                Self::CoinTypeGlobalPause => "COIN_TYPE_GLOBAL_PAUSE",
                Self::ExecutionCanceledDueToRandomnessUnavailable => {
                    "EXECUTION_CANCELED_DUE_TO_RANDOMNESS_UNAVAILABLE"
                }
                Self::MoveVectorElemTooBig => "MOVE_VECTOR_ELEM_TOO_BIG",
                Self::MoveRawValueTooBig => "MOVE_RAW_VALUE_TOO_BIG",
                Self::InvalidLinkage => "INVALID_LINKAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXECUTION_ERROR_KIND_UNKNOWN" => Some(Self::Unknown),
                "INSUFFICIENT_GAS" => Some(Self::InsufficientGas),
                "INVALID_GAS_OBJECT" => Some(Self::InvalidGasObject),
                "INVARIANT_VIOLATION" => Some(Self::InvariantViolation),
                "FEATURE_NOT_YET_SUPPORTED" => Some(Self::FeatureNotYetSupported),
                "OBJECT_TOO_BIG" => Some(Self::ObjectTooBig),
                "PACKAGE_TOO_BIG" => Some(Self::PackageTooBig),
                "CIRCULAR_OBJECT_OWNERSHIP" => Some(Self::CircularObjectOwnership),
                "INSUFFICIENT_COIN_BALANCE" => Some(Self::InsufficientCoinBalance),
                "COIN_BALANCE_OVERFLOW" => Some(Self::CoinBalanceOverflow),
                "PUBLISH_ERROR_NON_ZERO_ADDRESS" => {
                    Some(Self::PublishErrorNonZeroAddress)
                }
                "SUI_MOVE_VERIFICATION_ERROR" => Some(Self::SuiMoveVerificationError),
                "MOVE_PRIMITIVE_RUNTIME_ERROR" => Some(Self::MovePrimitiveRuntimeError),
                "MOVE_ABORT" => Some(Self::MoveAbort),
                "VM_VERIFICATION_OR_DESERIALIZATION_ERROR" => {
                    Some(Self::VmVerificationOrDeserializationError)
                }
                "VM_INVARIANT_VIOLATION" => Some(Self::VmInvariantViolation),
                "FUNCTION_NOT_FOUND" => Some(Self::FunctionNotFound),
                "ARITY_MISMATCH" => Some(Self::ArityMismatch),
                "TYPE_ARITY_MISMATCH" => Some(Self::TypeArityMismatch),
                "NON_ENTRY_FUNCTION_INVOKED" => Some(Self::NonEntryFunctionInvoked),
                "COMMAND_ARGUMENT_ERROR" => Some(Self::CommandArgumentError),
                "TYPE_ARGUMENT_ERROR" => Some(Self::TypeArgumentError),
                "UNUSED_VALUE_WITHOUT_DROP" => Some(Self::UnusedValueWithoutDrop),
                "INVALID_PUBLIC_FUNCTION_RETURN_TYPE" => {
                    Some(Self::InvalidPublicFunctionReturnType)
                }
                "INVALID_TRANSFER_OBJECT" => Some(Self::InvalidTransferObject),
                "EFFECTS_TOO_LARGE" => Some(Self::EffectsTooLarge),
                "PUBLISH_UPGRADE_MISSING_DEPENDENCY" => {
                    Some(Self::PublishUpgradeMissingDependency)
                }
                "PUBLISH_UPGRADE_DEPENDENCY_DOWNGRADE" => {
                    Some(Self::PublishUpgradeDependencyDowngrade)
                }
                "PACKAGE_UPGRADE_ERROR" => Some(Self::PackageUpgradeError),
                "WRITTEN_OBJECTS_TOO_LARGE" => Some(Self::WrittenObjectsTooLarge),
                "CERTIFICATE_DENIED" => Some(Self::CertificateDenied),
                "SUI_MOVE_VERIFICATION_TIMEDOUT" => {
                    Some(Self::SuiMoveVerificationTimedout)
                }
                "SHARED_OBJECT_OPERATION_NOT_ALLOWED" => {
                    Some(Self::SharedObjectOperationNotAllowed)
                }
                "INPUT_OBJECT_DELETED" => Some(Self::InputObjectDeleted),
                "EXECUTION_CANCELED_DUE_TO_SHARED_OBJECT_CONGESTION" => {
                    Some(Self::ExecutionCanceledDueToSharedObjectCongestion)
                }
                "ADDRESS_DENIED_FOR_COIN" => Some(Self::AddressDeniedForCoin),
                "COIN_TYPE_GLOBAL_PAUSE" => Some(Self::CoinTypeGlobalPause),
                "EXECUTION_CANCELED_DUE_TO_RANDOMNESS_UNAVAILABLE" => {
                    Some(Self::ExecutionCanceledDueToRandomnessUnavailable)
                }
                "MOVE_VECTOR_ELEM_TOO_BIG" => Some(Self::MoveVectorElemTooBig),
                "MOVE_RAW_VALUE_TOO_BIG" => Some(Self::MoveRawValueTooBig),
                "INVALID_LINKAGE" => Some(Self::InvalidLinkage),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ErrorDetails {
        #[prost(message, tag = "4")]
        Abort(super::MoveAbort),
        #[prost(message, tag = "5")]
        SizeError(super::SizeError),
        #[prost(message, tag = "6")]
        CommandArgumentError(super::CommandArgumentError),
        #[prost(message, tag = "7")]
        TypeArgumentError(super::TypeArgumentError),
        #[prost(message, tag = "8")]
        PackageUpgradeError(super::PackageUpgradeError),
        #[prost(message, tag = "9")]
        IndexError(super::IndexError),
        #[prost(string, tag = "10")]
        ObjectId(::prost::alloc::string::String),
        #[prost(message, tag = "11")]
        CoinDenyListError(super::CoinDenyListError),
        /// Set of objects that were congested, leading to the transaction's cancellation.
        #[prost(message, tag = "12")]
        CongestedObjects(super::CongestedObjects),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveAbort {
    #[prost(uint64, optional, tag = "1")]
    pub abort_code: ::core::option::Option<u64>,
    /// Location in Move where the error occurred.
    #[prost(message, optional, tag = "2")]
    pub location: ::core::option::Option<MoveLocation>,
    /// Extra error information if abort code is a "Clever Error"
    #[prost(message, optional, tag = "3")]
    pub clever_error: ::core::option::Option<CleverError>,
}
/// Location in Move bytecode where an error occurred.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveLocation {
    /// The package ID.
    #[prost(string, optional, tag = "1")]
    pub package: ::core::option::Option<::prost::alloc::string::String>,
    /// The module name.
    #[prost(string, optional, tag = "2")]
    pub module: ::core::option::Option<::prost::alloc::string::String>,
    /// The function index.
    #[prost(uint32, optional, tag = "3")]
    pub function: ::core::option::Option<u32>,
    /// Offset of the instruction where the error occurred.
    #[prost(uint32, optional, tag = "4")]
    pub instruction: ::core::option::Option<u32>,
    /// The name of the function, if available.
    #[prost(string, optional, tag = "5")]
    pub function_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CleverError {
    #[prost(uint64, optional, tag = "1")]
    pub error_code: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub line_number: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3")]
    pub constant_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub constant_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(oneof = "clever_error::Value", tags = "5, 6")]
    pub value: ::core::option::Option<clever_error::Value>,
}
/// Nested message and enum types in `CleverError`.
pub mod clever_error {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(string, tag = "5")]
        Rendered(::prost::alloc::string::String),
        #[prost(bytes, tag = "6")]
        Raw(::prost::bytes::Bytes),
    }
}
/// A size error.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SizeError {
    /// The offending size.
    #[prost(uint64, optional, tag = "1")]
    pub size: ::core::option::Option<u64>,
    /// The maximum allowable size.
    #[prost(uint64, optional, tag = "2")]
    pub max_size: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IndexError {
    /// Index of an input or result.
    #[prost(uint32, optional, tag = "1")]
    pub index: ::core::option::Option<u32>,
    /// Index of a subresult.
    #[prost(uint32, optional, tag = "2")]
    pub subresult: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoinDenyListError {
    /// Denied address.
    #[prost(string, optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    /// Coin type.
    #[prost(string, optional, tag = "2")]
    pub coin_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Set of objects that were congested, leading to the transaction's cancellation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CongestedObjects {
    #[prost(string, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// An error with an argument to a command.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CommandArgumentError {
    /// Position of the problematic argument.
    #[prost(uint32, optional, tag = "1")]
    pub argument: ::core::option::Option<u32>,
    #[prost(
        enumeration = "command_argument_error::CommandArgumentErrorKind",
        optional,
        tag = "2"
    )]
    pub kind: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub index_error: ::core::option::Option<IndexError>,
}
/// Nested message and enum types in `CommandArgumentError`.
pub mod command_argument_error {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CommandArgumentErrorKind {
        Unknown = 0,
        /// The type of the value does not match the expected type.
        TypeMismatch = 1,
        /// The argument cannot be deserialized into a value of the specified type.
        InvalidBcsBytes = 2,
        /// The argument cannot be instantiated from raw bytes.
        InvalidUsageOfPureArgument = 3,
        /// Invalid argument to private entry function.
        /// Private entry functions cannot take arguments from other Move functions.
        InvalidArgumentToPrivateEntryFunction = 4,
        /// Out of bounds access to input or results.
        ///
        /// `index` field will be set indicating the invalid index value.
        IndexOutOfBounds = 5,
        /// Out of bounds access to subresult.
        ///
        /// `index` and `subresult` fields will be set indicating the invalid index value.
        SecondaryIndexOutOfBounds = 6,
        /// Invalid usage of result.
        /// Expected a single result but found either no return value or multiple.
        /// `index` field will be set indicating the invalid index value.
        InvalidResultArity = 7,
        /// Invalid usage of gas coin.
        /// The gas coin can only be used by-value with a `TransferObject` command.
        InvalidGasCoinUsage = 8,
        /// Invalid usage of Move value.
        ///     - Mutably borrowed values require unique usage.
        ///     - Immutably borrowed values cannot be taken or borrowed mutably.
        ///     - Taken values cannot be used again.
        InvalidValueUsage = 9,
        /// Immutable objects cannot be passed by-value.
        InvalidObjectByValue = 10,
        /// Immutable objects cannot be passed by mutable reference, `&mut`.
        InvalidObjectByMutRef = 11,
        /// Shared object operations such as wrapping, freezing, or converting to owned are not
        /// allowed.
        SharedObjectOperationNotAllowed = 12,
        /// Invalid argument arity. Expected a single argument but found a result that expanded to
        /// multiple arguments.
        InvalidArgumentArity = 13,
    }
    impl CommandArgumentErrorKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "COMMAND_ARGUMENT_ERROR_KIND_UNKNOWN",
                Self::TypeMismatch => "TYPE_MISMATCH",
                Self::InvalidBcsBytes => "INVALID_BCS_BYTES",
                Self::InvalidUsageOfPureArgument => "INVALID_USAGE_OF_PURE_ARGUMENT",
                Self::InvalidArgumentToPrivateEntryFunction => {
                    "INVALID_ARGUMENT_TO_PRIVATE_ENTRY_FUNCTION"
                }
                Self::IndexOutOfBounds => "INDEX_OUT_OF_BOUNDS",
                Self::SecondaryIndexOutOfBounds => "SECONDARY_INDEX_OUT_OF_BOUNDS",
                Self::InvalidResultArity => "INVALID_RESULT_ARITY",
                Self::InvalidGasCoinUsage => "INVALID_GAS_COIN_USAGE",
                Self::InvalidValueUsage => "INVALID_VALUE_USAGE",
                Self::InvalidObjectByValue => "INVALID_OBJECT_BY_VALUE",
                Self::InvalidObjectByMutRef => "INVALID_OBJECT_BY_MUT_REF",
                Self::SharedObjectOperationNotAllowed => {
                    "SHARED_OBJECT_OPERATION_NOT_ALLOWED"
                }
                Self::InvalidArgumentArity => "INVALID_ARGUMENT_ARITY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMMAND_ARGUMENT_ERROR_KIND_UNKNOWN" => Some(Self::Unknown),
                "TYPE_MISMATCH" => Some(Self::TypeMismatch),
                "INVALID_BCS_BYTES" => Some(Self::InvalidBcsBytes),
                "INVALID_USAGE_OF_PURE_ARGUMENT" => {
                    Some(Self::InvalidUsageOfPureArgument)
                }
                "INVALID_ARGUMENT_TO_PRIVATE_ENTRY_FUNCTION" => {
                    Some(Self::InvalidArgumentToPrivateEntryFunction)
                }
                "INDEX_OUT_OF_BOUNDS" => Some(Self::IndexOutOfBounds),
                "SECONDARY_INDEX_OUT_OF_BOUNDS" => Some(Self::SecondaryIndexOutOfBounds),
                "INVALID_RESULT_ARITY" => Some(Self::InvalidResultArity),
                "INVALID_GAS_COIN_USAGE" => Some(Self::InvalidGasCoinUsage),
                "INVALID_VALUE_USAGE" => Some(Self::InvalidValueUsage),
                "INVALID_OBJECT_BY_VALUE" => Some(Self::InvalidObjectByValue),
                "INVALID_OBJECT_BY_MUT_REF" => Some(Self::InvalidObjectByMutRef),
                "SHARED_OBJECT_OPERATION_NOT_ALLOWED" => {
                    Some(Self::SharedObjectOperationNotAllowed)
                }
                "INVALID_ARGUMENT_ARITY" => Some(Self::InvalidArgumentArity),
                _ => None,
            }
        }
    }
}
/// An error with upgrading a package.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackageUpgradeError {
    #[prost(
        enumeration = "package_upgrade_error::PackageUpgradeErrorKind",
        optional,
        tag = "1"
    )]
    pub kind: ::core::option::Option<i32>,
    /// The Package Id.
    #[prost(string, optional, tag = "2")]
    pub package_id: ::core::option::Option<::prost::alloc::string::String>,
    /// A digest.
    #[prost(string, optional, tag = "3")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The policy.
    #[prost(uint32, optional, tag = "4")]
    pub policy: ::core::option::Option<u32>,
    /// The ticket Id.
    #[prost(string, optional, tag = "5")]
    pub ticket_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `PackageUpgradeError`.
pub mod package_upgrade_error {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PackageUpgradeErrorKind {
        Unknown = 0,
        /// Unable to fetch package.
        UnableToFetchPackage = 1,
        /// Object is not a package.
        NotAPackage = 2,
        /// Package upgrade is incompatible with previous version.
        IncompatibleUpgrade = 3,
        /// Digest in upgrade ticket and computed digest differ.
        DigetsDoesNotMatch = 4,
        /// Upgrade policy is not valid.
        UnknownUpgradePolicy = 5,
        /// Package ID does not match `PackageId` in upgrade ticket.
        PackageIdDoesNotMatch = 6,
    }
    impl PackageUpgradeErrorKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "PACKAGE_UPGRADE_ERROR_KIND_UNKNOWN",
                Self::UnableToFetchPackage => "UNABLE_TO_FETCH_PACKAGE",
                Self::NotAPackage => "NOT_A_PACKAGE",
                Self::IncompatibleUpgrade => "INCOMPATIBLE_UPGRADE",
                Self::DigetsDoesNotMatch => "DIGETS_DOES_NOT_MATCH",
                Self::UnknownUpgradePolicy => "UNKNOWN_UPGRADE_POLICY",
                Self::PackageIdDoesNotMatch => "PACKAGE_ID_DOES_NOT_MATCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PACKAGE_UPGRADE_ERROR_KIND_UNKNOWN" => Some(Self::Unknown),
                "UNABLE_TO_FETCH_PACKAGE" => Some(Self::UnableToFetchPackage),
                "NOT_A_PACKAGE" => Some(Self::NotAPackage),
                "INCOMPATIBLE_UPGRADE" => Some(Self::IncompatibleUpgrade),
                "DIGETS_DOES_NOT_MATCH" => Some(Self::DigetsDoesNotMatch),
                "UNKNOWN_UPGRADE_POLICY" => Some(Self::UnknownUpgradePolicy),
                "PACKAGE_ID_DOES_NOT_MATCH" => Some(Self::PackageIdDoesNotMatch),
                _ => None,
            }
        }
    }
}
/// Type argument error.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TypeArgumentError {
    /// Index of the problematic type argument.
    #[prost(uint32, optional, tag = "1")]
    pub type_argument: ::core::option::Option<u32>,
    #[prost(
        enumeration = "type_argument_error::TypeArgumentErrorKind",
        optional,
        tag = "2"
    )]
    pub kind: ::core::option::Option<i32>,
}
/// Nested message and enum types in `TypeArgumentError`.
pub mod type_argument_error {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TypeArgumentErrorKind {
        Unknown = 0,
        /// A type was not found in the module specified.
        TypeNotFound = 1,
        /// A type provided did not match the specified constraint.
        ConstraintNotSatisfied = 2,
    }
    impl TypeArgumentErrorKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "TYPE_ARGUMENT_ERROR_KIND_UNKNOWN",
                Self::TypeNotFound => "TYPE_NOT_FOUND",
                Self::ConstraintNotSatisfied => "CONSTRAINT_NOT_SATISFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_ARGUMENT_ERROR_KIND_UNKNOWN" => Some(Self::Unknown),
                "TYPE_NOT_FOUND" => Some(Self::TypeNotFound),
                "CONSTRAINT_NOT_SATISFIED" => Some(Self::ConstraintNotSatisfied),
                _ => None,
            }
        }
    }
}
/// Summary of gas charges.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GasCostSummary {
    /// Cost of computation/execution.
    #[prost(uint64, optional, tag = "1")]
    pub computation_cost: ::core::option::Option<u64>,
    /// Storage cost, it's the sum of all storage cost for all objects created or mutated.
    #[prost(uint64, optional, tag = "2")]
    pub storage_cost: ::core::option::Option<u64>,
    /// The amount of storage cost refunded to the user for all objects deleted or mutated in the
    /// transaction.
    #[prost(uint64, optional, tag = "3")]
    pub storage_rebate: ::core::option::Option<u64>,
    /// The fee for the rebate. The portion of the storage rebate kept by the system.
    #[prost(uint64, optional, tag = "4")]
    pub non_refundable_storage_fee: ::core::option::Option<u64>,
}
/// An input to a user transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Input {
    #[prost(enumeration = "input::InputKind", optional, tag = "1")]
    pub kind: ::core::option::Option<i32>,
    /// A move value serialized as BCS.
    ///
    /// For normal operations this is required to be a move primitive type and not contain structs
    /// or objects.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub pure: ::core::option::Option<::prost::bytes::Bytes>,
    /// `ObjectId` of the object input.
    #[prost(string, optional, tag = "3")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Requested version of the input object when `kind` is `IMMUTABLE_OR_OWNED`
    /// or `RECEIVING` or if `kind` is `SHARED` this is the initial version of the
    /// object when it was shared
    #[prost(uint64, optional, tag = "4")]
    pub version: ::core::option::Option<u64>,
    /// The digest of this object.
    #[prost(string, optional, tag = "5")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Controls whether the caller asks for a mutable reference to the shared
    /// object.
    #[prost(bool, optional, tag = "6")]
    pub mutable: ::core::option::Option<bool>,
    /// A literal value
    ///
    /// INPUT ONLY
    #[prost(message, optional, boxed, tag = "1000")]
    pub literal: ::core::option::Option<
        ::prost::alloc::boxed::Box<::prost_types::Value>,
    >,
}
/// Nested message and enum types in `Input`.
pub mod input {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InputKind {
        Unknown = 0,
        /// A move value serialized as BCS.
        Pure = 1,
        /// A Move object that is either immutable or address owned.
        ImmutableOrOwned = 2,
        /// A Move object whose owner is "Shared".
        Shared = 3,
        /// A Move object that is attempted to be received in this transaction.
        Receiving = 4,
    }
    impl InputKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "INPUT_KIND_UNKNOWN",
                Self::Pure => "PURE",
                Self::ImmutableOrOwned => "IMMUTABLE_OR_OWNED",
                Self::Shared => "SHARED",
                Self::Receiving => "RECEIVING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INPUT_KIND_UNKNOWN" => Some(Self::Unknown),
                "PURE" => Some(Self::Pure),
                "IMMUTABLE_OR_OWNED" => Some(Self::ImmutableOrOwned),
                "SHARED" => Some(Self::Shared),
                "RECEIVING" => Some(Self::Receiving),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetServiceInfoRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetServiceInfoResponse {
    /// The chain identifier of the chain that this node is on.
    ///
    /// The chain identifier is the digest of the genesis checkpoint, the
    /// checkpoint with sequence number 0.
    #[prost(string, optional, tag = "1")]
    pub chain_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Human-readable name of the chain that this node is on.
    ///
    /// This is intended to be a human-readable name like `mainnet`, `testnet`, and so on.
    #[prost(string, optional, tag = "2")]
    pub chain: ::core::option::Option<::prost::alloc::string::String>,
    /// Current epoch of the node based on its highest executed checkpoint.
    #[prost(uint64, optional, tag = "3")]
    pub epoch: ::core::option::Option<u64>,
    /// Checkpoint height of the most recently executed checkpoint.
    #[prost(uint64, optional, tag = "4")]
    pub checkpoint_height: ::core::option::Option<u64>,
    /// Unix timestamp of the most recently executed checkpoint.
    #[prost(message, optional, tag = "5")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// The lowest checkpoint for which checkpoints and transaction data are available.
    #[prost(uint64, optional, tag = "6")]
    pub lowest_available_checkpoint: ::core::option::Option<u64>,
    /// The lowest checkpoint for which object data is available.
    #[prost(uint64, optional, tag = "7")]
    pub lowest_available_checkpoint_objects: ::core::option::Option<u64>,
    /// Software version of the service. Similar to the `server` http header.
    #[prost(string, optional, tag = "8")]
    pub server_version: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetObjectRequest {
    /// Required. The `ObjectId` of the requested object.
    #[prost(string, optional, tag = "1")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Request a specific version of the object.
    /// If no version is specified, and the object is live, then the latest
    /// version of the object is returned.
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `object_id,version,digest`.
    #[prost(message, optional, tag = "3")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetObjectResponse {
    #[prost(message, optional, tag = "1")]
    pub object: ::core::option::Option<Object>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetObjectsRequest {
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<GetObjectRequest>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `object_id,version,digest`.
    #[prost(message, optional, tag = "2")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetObjectsResponse {
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<GetObjectResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetObjectResult {
    #[prost(oneof = "get_object_result::Result", tags = "1, 2")]
    pub result: ::core::option::Option<get_object_result::Result>,
}
/// Nested message and enum types in `GetObjectResult`.
pub mod get_object_result {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag = "1")]
        Object(super::Object),
        #[prost(message, tag = "2")]
        Error(crate::proto::google::rpc::Status),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionRequest {
    /// Required. The digest of the requested transaction.
    #[prost(string, optional, tag = "1")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `digest`.
    #[prost(message, optional, tag = "2")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionResponse {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<ExecutedTransaction>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetTransactionsRequest {
    /// Required. The digests of the requested transactions.
    #[prost(string, repeated, tag = "1")]
    pub digests: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `object_id,version,digest`.
    #[prost(message, optional, tag = "2")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetTransactionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub transactions: ::prost::alloc::vec::Vec<GetTransactionResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionResult {
    #[prost(oneof = "get_transaction_result::Result", tags = "1, 2")]
    pub result: ::core::option::Option<get_transaction_result::Result>,
}
/// Nested message and enum types in `GetTransactionResult`.
pub mod get_transaction_result {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag = "1")]
        Transaction(super::ExecutedTransaction),
        #[prost(message, tag = "2")]
        Error(crate::proto::google::rpc::Status),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCheckpointRequest {
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `object_id,version,digest`.
    #[prost(message, optional, tag = "3")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// If neither is provided, return the latest
    #[prost(oneof = "get_checkpoint_request::CheckpointId", tags = "1, 2")]
    pub checkpoint_id: ::core::option::Option<get_checkpoint_request::CheckpointId>,
}
/// Nested message and enum types in `GetCheckpointRequest`.
pub mod get_checkpoint_request {
    /// If neither is provided, return the latest
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CheckpointId {
        /// The sequence number of the requested checkpoint.
        #[prost(uint64, tag = "1")]
        SequenceNumber(u64),
        /// The digest of the requested checkpoint.
        #[prost(string, tag = "2")]
        Digest(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCheckpointResponse {
    #[prost(message, optional, tag = "1")]
    pub checkpoint: ::core::option::Option<Checkpoint>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEpochRequest {
    /// The requested epoch.
    /// If no epoch is provided the current epoch will be returned.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `epoch`.
    #[prost(message, optional, tag = "2")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEpochResponse {
    #[prost(message, optional, tag = "1")]
    pub epoch: ::core::option::Option<Epoch>,
}
/// Generated client implementations.
pub mod ledger_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct LedgerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl LedgerServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> LedgerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> LedgerServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            LedgerServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Query the service for general information about its current state.
        pub async fn get_service_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetServiceInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetServiceInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta2.LedgerService/GetServiceInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("sui.rpc.v2beta2.LedgerService", "GetServiceInfo"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_object(
            &mut self,
            request: impl tonic::IntoRequest<super::GetObjectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetObjectResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta2.LedgerService/GetObject",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sui.rpc.v2beta2.LedgerService", "GetObject"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn batch_get_objects(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchGetObjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchGetObjectsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta2.LedgerService/BatchGetObjects",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("sui.rpc.v2beta2.LedgerService", "BatchGetObjects"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTransactionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta2.LedgerService/GetTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("sui.rpc.v2beta2.LedgerService", "GetTransaction"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn batch_get_transactions(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchGetTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchGetTransactionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta2.LedgerService/BatchGetTransactions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "sui.rpc.v2beta2.LedgerService",
                        "BatchGetTransactions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_checkpoint(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCheckpointRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetCheckpointResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta2.LedgerService/GetCheckpoint",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("sui.rpc.v2beta2.LedgerService", "GetCheckpoint"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_epoch(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEpochRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetEpochResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta2.LedgerService/GetEpoch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sui.rpc.v2beta2.LedgerService", "GetEpoch"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod ledger_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with LedgerServiceServer.
    #[async_trait]
    pub trait LedgerService: std::marker::Send + std::marker::Sync + 'static {
        /// Query the service for general information about its current state.
        async fn get_service_info(
            &self,
            request: tonic::Request<super::GetServiceInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetServiceInfoResponse>,
            tonic::Status,
        >;
        async fn get_object(
            &self,
            request: tonic::Request<super::GetObjectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetObjectResponse>,
            tonic::Status,
        >;
        async fn batch_get_objects(
            &self,
            request: tonic::Request<super::BatchGetObjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchGetObjectsResponse>,
            tonic::Status,
        >;
        async fn get_transaction(
            &self,
            request: tonic::Request<super::GetTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTransactionResponse>,
            tonic::Status,
        >;
        async fn batch_get_transactions(
            &self,
            request: tonic::Request<super::BatchGetTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchGetTransactionsResponse>,
            tonic::Status,
        >;
        async fn get_checkpoint(
            &self,
            request: tonic::Request<super::GetCheckpointRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetCheckpointResponse>,
            tonic::Status,
        >;
        async fn get_epoch(
            &self,
            request: tonic::Request<super::GetEpochRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetEpochResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct LedgerServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> LedgerServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for LedgerServiceServer<T>
    where
        T: LedgerService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/sui.rpc.v2beta2.LedgerService/GetServiceInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetServiceInfoSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::GetServiceInfoRequest>
                    for GetServiceInfoSvc<T> {
                        type Response = super::GetServiceInfoResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetServiceInfoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::get_service_info(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetServiceInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sui.rpc.v2beta2.LedgerService/GetObject" => {
                    #[allow(non_camel_case_types)]
                    struct GetObjectSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::GetObjectRequest>
                    for GetObjectSvc<T> {
                        type Response = super::GetObjectResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetObjectRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::get_object(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetObjectSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sui.rpc.v2beta2.LedgerService/BatchGetObjects" => {
                    #[allow(non_camel_case_types)]
                    struct BatchGetObjectsSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::BatchGetObjectsRequest>
                    for BatchGetObjectsSvc<T> {
                        type Response = super::BatchGetObjectsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BatchGetObjectsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::batch_get_objects(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BatchGetObjectsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sui.rpc.v2beta2.LedgerService/GetTransaction" => {
                    #[allow(non_camel_case_types)]
                    struct GetTransactionSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::GetTransactionRequest>
                    for GetTransactionSvc<T> {
                        type Response = super::GetTransactionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTransactionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::get_transaction(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTransactionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sui.rpc.v2beta2.LedgerService/BatchGetTransactions" => {
                    #[allow(non_camel_case_types)]
                    struct BatchGetTransactionsSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::BatchGetTransactionsRequest>
                    for BatchGetTransactionsSvc<T> {
                        type Response = super::BatchGetTransactionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BatchGetTransactionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::batch_get_transactions(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BatchGetTransactionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sui.rpc.v2beta2.LedgerService/GetCheckpoint" => {
                    #[allow(non_camel_case_types)]
                    struct GetCheckpointSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::GetCheckpointRequest>
                    for GetCheckpointSvc<T> {
                        type Response = super::GetCheckpointResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCheckpointRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::get_checkpoint(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetCheckpointSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sui.rpc.v2beta2.LedgerService/GetEpoch" => {
                    #[allow(non_camel_case_types)]
                    struct GetEpochSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::GetEpochRequest>
                    for GetEpochSvc<T> {
                        type Response = super::GetEpochResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetEpochRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::get_epoch(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetEpochSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for LedgerServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "sui.rpc.v2beta2.LedgerService";
    impl<T> tonic::server::NamedService for LedgerServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for `NodeService.GetCoinInfo`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCoinInfoRequest {
    /// The coin type to request information about
    #[prost(string, optional, tag = "1")]
    pub coin_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Response message for `NodeService.GetCoinInfo`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCoinInfoResponse {
    /// Required. The coin type.
    #[prost(string, optional, tag = "1")]
    pub coin_type: ::core::option::Option<::prost::alloc::string::String>,
    /// This field will be populated with information about this coin
    /// type's `0x2::coin::CoinMetadata` if it exists and has not been wrapped.
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<CoinMetadata>,
    /// This field will be populated with information about this coin
    /// type's `0x2::coin::TreasuryCap` if it exists and has not been wrapped.
    #[prost(message, optional, tag = "3")]
    pub treasury: ::core::option::Option<CoinTreasury>,
    /// If this coin type is a regulated coin, this field will be
    /// populated with information about its `0x2::coin::RegulatedCoinMetadata`
    /// object.
    #[prost(message, optional, tag = "4")]
    pub regulated_metadata: ::core::option::Option<RegulatedCoinMetadata>,
}
/// Metadata for a coin type
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoinMetadata {
    /// ObjectId of the `0x2::coin::CoinMetadata` object.
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    /// Number of decimal places to coin uses.
    #[prost(uint32, optional, tag = "2")]
    pub decimals: ::core::option::Option<u32>,
    /// Name for the token
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Symbol for the token
    #[prost(string, optional, tag = "4")]
    pub symbol: ::core::option::Option<::prost::alloc::string::String>,
    /// Description of the token
    #[prost(string, optional, tag = "5")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// URL for the token logo
    #[prost(string, optional, tag = "6")]
    pub icon_url: ::core::option::Option<::prost::alloc::string::String>,
}
/// Information about a coin type's `0x2::coin::TreasuryCap` and its total available supply
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoinTreasury {
    /// ObjectId of the `0x2::coin::TreasuryCap` object.
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    /// Total available supply for this coin type.
    #[prost(uint64, optional, tag = "2")]
    pub total_supply: ::core::option::Option<u64>,
}
/// Information about a regulated coin, which indicates that it makes use of the transfer deny list.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegulatedCoinMetadata {
    /// ObjectId of the `0x2::coin::RegulatedCoinMetadata` object.
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    /// The ID of the coin's `CoinMetadata` object.
    #[prost(string, optional, tag = "2")]
    pub coin_metadata_object: ::core::option::Option<::prost::alloc::string::String>,
    /// The ID of the coin's `DenyCap` object.
    #[prost(string, optional, tag = "3")]
    pub deny_cap_object: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request message for `LiveDataService.GetBalance`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBalanceRequest {
    /// Required. The owner's Sui address.
    #[prost(string, optional, tag = "1")]
    pub owner: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. The type names for the coin (e.g., 0x2::sui::SUI).
    #[prost(string, optional, tag = "2")]
    pub coin_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Response message for `LiveDataService.GetBalance`.
/// Return the total coin balance for one coin type, owned by the address owner.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBalanceResponse {
    /// The balance information for the requested coin type.
    #[prost(message, optional, tag = "1")]
    pub balance: ::core::option::Option<Balance>,
}
/// Request message for `LiveDataService.ListBalances`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBalancesRequest {
    /// Required. The owner's Sui address.
    #[prost(string, optional, tag = "1")]
    pub owner: ::core::option::Option<::prost::alloc::string::String>,
    /// The maximum number of balance entries to return. The service may return fewer than this value.
    /// If unspecified, at most `50` entries will be returned.
    /// The maximum value is `1000`; values above `1000` will be coerced to `1000`.
    #[prost(uint32, optional, tag = "2")]
    pub page_size: ::core::option::Option<u32>,
    /// A page token, received from a previous `ListBalances` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListBalances` must
    /// match the call that provided the page token.
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub page_token: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Response message for `LiveDataService.ListBalances`.
/// Return the total coin balance for all coin types, owned by the address owner.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBalancesResponse {
    /// The list of coin types and their respective balances.
    #[prost(message, repeated, tag = "1")]
    pub balances: ::prost::alloc::vec::Vec<Balance>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub next_page_token: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Balance information for a specific coin type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Balance {
    /// The type of the coin (e.g., 0x2::sui::SUI).
    #[prost(string, optional, tag = "1")]
    pub coin_type: ::core::option::Option<::prost::alloc::string::String>,
    /// Shows the total balance of the coin in its smallest unit.
    #[prost(uint64, optional, tag = "3")]
    pub balance: ::core::option::Option<u64>,
}
/// Request message for `NodeService.ListDynamicFields`
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDynamicFieldsRequest {
    /// Required. The `UID` of the parent, which owns the collections of dynamic fields.
    #[prost(string, optional, tag = "1")]
    pub parent: ::core::option::Option<::prost::alloc::string::String>,
    /// The maximum number of dynamic fields to return. The service may return fewer than this value.
    /// If unspecified, at most `50` entries will be returned.
    /// The maximum value is `1000`; values above `1000` will be coerced to `1000`.
    #[prost(uint32, optional, tag = "2")]
    pub page_size: ::core::option::Option<u32>,
    /// A page token, received from a previous `ListDynamicFields` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListDynamicFields` must
    /// match the call that provided the page token.
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub page_token: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Response message for `NodeService.ListDynamicFields`
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDynamicFieldsResponse {
    /// Page of dynamic fields owned by the specified parent.
    #[prost(message, repeated, tag = "1")]
    pub dynamic_fields: ::prost::alloc::vec::Vec<DynamicField>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub next_page_token: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynamicField {
    #[prost(enumeration = "dynamic_field::DynamicFieldKind", optional, tag = "1")]
    pub kind: ::core::option::Option<i32>,
    /// ObjectId of this dynamic field's parent.
    #[prost(string, optional, tag = "2")]
    pub parent: ::core::option::Option<::prost::alloc::string::String>,
    /// ObjectId of this dynamic field.
    #[prost(string, optional, tag = "3")]
    pub field_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The type of the dynamic field "name"
    #[prost(string, optional, tag = "4")]
    pub name_type: ::core::option::Option<::prost::alloc::string::String>,
    /// The serialized move value of "name"
    #[prost(bytes = "bytes", optional, tag = "5")]
    pub name_value: ::core::option::Option<::prost::bytes::Bytes>,
    /// The type of the dynamic field "value".
    ///
    /// If this is a dynamic object field then this is the type of the object
    /// itself (which is a child of this field), otherwise this is the type of the
    /// value of this field.
    #[prost(string, optional, tag = "6")]
    pub value_type: ::core::option::Option<::prost::alloc::string::String>,
    /// The ObjectId of the child object when a child is a dynamic
    /// object field.
    ///
    /// The presence or absence of this field can be used to determine if a child
    /// is a dynamic field or a dynamic child object
    #[prost(string, optional, tag = "7")]
    pub dynamic_object_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `DynamicField`.
pub mod dynamic_field {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DynamicFieldKind {
        Unknown = 0,
        Field = 1,
        Object = 2,
    }
    impl DynamicFieldKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "DYNAMIC_FIELD_KIND_UNKNOWN",
                Self::Field => "FIELD",
                Self::Object => "OBJECT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DYNAMIC_FIELD_KIND_UNKNOWN" => Some(Self::Unknown),
                "FIELD" => Some(Self::Field),
                "OBJECT" => Some(Self::Object),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimulateTransactionRequest {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<Transaction>,
    #[prost(message, optional, tag = "2")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Specify whether checks should be ENABLED (default) or DISABLED while executing the transaction
    #[prost(
        enumeration = "simulate_transaction_request::TransactionChecks",
        optional,
        tag = "3"
    )]
    pub checks: ::core::option::Option<i32>,
    /// Perform gas selection based on a budget estimation and include the
    /// selected gas payment and budget in the response.
    ///
    /// This option will be ignored if `checks` is `DISABLED`.
    #[prost(bool, optional, tag = "4")]
    pub do_gas_selection: ::core::option::Option<bool>,
}
/// Nested message and enum types in `SimulateTransactionRequest`.
pub mod simulate_transaction_request {
    /// buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TransactionChecks {
        Enabled = 0,
        Disabled = 1,
    }
    impl TransactionChecks {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Enabled => "ENABLED",
                Self::Disabled => "DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ENABLED" => Some(Self::Enabled),
                "DISABLED" => Some(Self::Disabled),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimulateTransactionResponse {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<ExecutedTransaction>,
    #[prost(message, repeated, tag = "2")]
    pub outputs: ::prost::alloc::vec::Vec<CommandResult>,
}
/// An intermediate result/output from the execution of a single command
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandResult {
    #[prost(message, repeated, tag = "1")]
    pub return_values: ::prost::alloc::vec::Vec<CommandOutput>,
    #[prost(message, repeated, tag = "2")]
    pub mutated_by_ref: ::prost::alloc::vec::Vec<CommandOutput>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandOutput {
    #[prost(message, optional, tag = "1")]
    pub argument: ::core::option::Option<Argument>,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<Bcs>,
    /// JSON rendering of the output.
    #[prost(message, optional, boxed, tag = "3")]
    pub json: ::core::option::Option<::prost::alloc::boxed::Box<::prost_types::Value>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOwnedObjectsRequest {
    /// Required. The address of the account that owns the objects.
    #[prost(string, optional, tag = "1")]
    pub owner: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional type filter to limit the types of objects listed.
    ///
    /// Providing an object type with no type params will return objects of that
    /// type with any type parameter, e.g. `0x2::coin::Coin` will return all
    /// `Coin<T>` objects regardless of the type parameter `T`. Providing a type
    /// with a type param will retrict the returned objects to only those objects
    /// that match the provided type parameters, e.g.
    /// `0x2::coin::Coin<0x2::sui::SUI>` will only return `Coin<SUI>` objects.
    #[prost(string, optional, tag = "4")]
    pub object_type: ::core::option::Option<::prost::alloc::string::String>,
    /// The maximum number of entries return. The service may return fewer than this value.
    /// If unspecified, at most `50` entries will be returned.
    /// The maximum value is `1000`; values above `1000` will be coerced to `1000`.
    #[prost(uint32, optional, tag = "2")]
    pub page_size: ::core::option::Option<u32>,
    /// A page token, received from a previous `ListOwnedObjects` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListOwnedObjects` must
    /// match the call that provided the page token.
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub page_token: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOwnedObjectsResponse {
    /// Page of dynamic fields owned by the specified parent.
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<OwnedObject>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub next_page_token: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OwnedObject {
    #[prost(string, optional, tag = "2")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3")]
    pub version: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "4")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "5")]
    pub owner: ::core::option::Option<Owner>,
    #[prost(string, optional, tag = "6")]
    pub object_type: ::core::option::Option<::prost::alloc::string::String>,
    /// Current balance if this object is a `0x2::coin::Coin<T>`
    #[prost(uint64, optional, tag = "200")]
    pub balance: ::core::option::Option<u64>,
}
/// Generated client implementations.
pub mod live_data_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct LiveDataServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl LiveDataServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> LiveDataServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> LiveDataServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            LiveDataServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn list_dynamic_fields(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDynamicFieldsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDynamicFieldsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta2.LiveDataService/ListDynamicFields",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "sui.rpc.v2beta2.LiveDataService",
                        "ListDynamicFields",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn list_owned_objects(
            &mut self,
            request: impl tonic::IntoRequest<super::ListOwnedObjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListOwnedObjectsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta2.LiveDataService/ListOwnedObjects",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "sui.rpc.v2beta2.LiveDataService",
                        "ListOwnedObjects",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_coin_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCoinInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetCoinInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta2.LiveDataService/GetCoinInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("sui.rpc.v2beta2.LiveDataService", "GetCoinInfo"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_balance(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBalanceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta2.LiveDataService/GetBalance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("sui.rpc.v2beta2.LiveDataService", "GetBalance"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn list_balances(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBalancesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBalancesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta2.LiveDataService/ListBalances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("sui.rpc.v2beta2.LiveDataService", "ListBalances"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn simulate_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::SimulateTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SimulateTransactionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta2.LiveDataService/SimulateTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "sui.rpc.v2beta2.LiveDataService",
                        "SimulateTransaction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod live_data_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with LiveDataServiceServer.
    #[async_trait]
    pub trait LiveDataService: std::marker::Send + std::marker::Sync + 'static {
        async fn list_dynamic_fields(
            &self,
            request: tonic::Request<super::ListDynamicFieldsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDynamicFieldsResponse>,
            tonic::Status,
        >;
        async fn list_owned_objects(
            &self,
            request: tonic::Request<super::ListOwnedObjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListOwnedObjectsResponse>,
            tonic::Status,
        >;
        async fn get_coin_info(
            &self,
            request: tonic::Request<super::GetCoinInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetCoinInfoResponse>,
            tonic::Status,
        >;
        async fn get_balance(
            &self,
            request: tonic::Request<super::GetBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBalanceResponse>,
            tonic::Status,
        >;
        async fn list_balances(
            &self,
            request: tonic::Request<super::ListBalancesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBalancesResponse>,
            tonic::Status,
        >;
        async fn simulate_transaction(
            &self,
            request: tonic::Request<super::SimulateTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SimulateTransactionResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct LiveDataServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> LiveDataServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for LiveDataServiceServer<T>
    where
        T: LiveDataService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/sui.rpc.v2beta2.LiveDataService/ListDynamicFields" => {
                    #[allow(non_camel_case_types)]
                    struct ListDynamicFieldsSvc<T: LiveDataService>(pub Arc<T>);
                    impl<
                        T: LiveDataService,
                    > tonic::server::UnaryService<super::ListDynamicFieldsRequest>
                    for ListDynamicFieldsSvc<T> {
                        type Response = super::ListDynamicFieldsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListDynamicFieldsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LiveDataService>::list_dynamic_fields(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListDynamicFieldsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sui.rpc.v2beta2.LiveDataService/ListOwnedObjects" => {
                    #[allow(non_camel_case_types)]
                    struct ListOwnedObjectsSvc<T: LiveDataService>(pub Arc<T>);
                    impl<
                        T: LiveDataService,
                    > tonic::server::UnaryService<super::ListOwnedObjectsRequest>
                    for ListOwnedObjectsSvc<T> {
                        type Response = super::ListOwnedObjectsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListOwnedObjectsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LiveDataService>::list_owned_objects(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListOwnedObjectsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sui.rpc.v2beta2.LiveDataService/GetCoinInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetCoinInfoSvc<T: LiveDataService>(pub Arc<T>);
                    impl<
                        T: LiveDataService,
                    > tonic::server::UnaryService<super::GetCoinInfoRequest>
                    for GetCoinInfoSvc<T> {
                        type Response = super::GetCoinInfoResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCoinInfoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LiveDataService>::get_coin_info(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetCoinInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sui.rpc.v2beta2.LiveDataService/GetBalance" => {
                    #[allow(non_camel_case_types)]
                    struct GetBalanceSvc<T: LiveDataService>(pub Arc<T>);
                    impl<
                        T: LiveDataService,
                    > tonic::server::UnaryService<super::GetBalanceRequest>
                    for GetBalanceSvc<T> {
                        type Response = super::GetBalanceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetBalanceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LiveDataService>::get_balance(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetBalanceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sui.rpc.v2beta2.LiveDataService/ListBalances" => {
                    #[allow(non_camel_case_types)]
                    struct ListBalancesSvc<T: LiveDataService>(pub Arc<T>);
                    impl<
                        T: LiveDataService,
                    > tonic::server::UnaryService<super::ListBalancesRequest>
                    for ListBalancesSvc<T> {
                        type Response = super::ListBalancesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListBalancesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LiveDataService>::list_balances(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListBalancesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sui.rpc.v2beta2.LiveDataService/SimulateTransaction" => {
                    #[allow(non_camel_case_types)]
                    struct SimulateTransactionSvc<T: LiveDataService>(pub Arc<T>);
                    impl<
                        T: LiveDataService,
                    > tonic::server::UnaryService<super::SimulateTransactionRequest>
                    for SimulateTransactionSvc<T> {
                        type Response = super::SimulateTransactionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SimulateTransactionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LiveDataService>::simulate_transaction(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SimulateTransactionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for LiveDataServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "sui.rpc.v2beta2.LiveDataService";
    impl<T> tonic::server::NamedService for LiveDataServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// A Move Package
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Package {
    /// The PackageId of this package
    ///
    /// A package's `storage_id` is the Sui ObjectId of the package on-chain.
    /// Outside of system packages the `storage_id` for every package version is
    /// different.
    #[prost(string, optional, tag = "1")]
    pub storage_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The PackageId of the first published version of this package.
    ///
    /// A package's `original_id` (sometimes also called its `runtime_id`) is the
    /// `storage_id` of the first version of this package that has been published.
    /// The `original_id`/`runtime_id` is stable across all versions of the
    /// package and does not ever change.
    #[prost(string, optional, tag = "2")]
    pub original_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The version of this package
    #[prost(uint64, optional, tag = "3")]
    pub version: ::core::option::Option<u64>,
    /// The modules defined by this package
    #[prost(message, repeated, tag = "4")]
    pub modules: ::prost::alloc::vec::Vec<Module>,
    /// List of datatype origins for mapping datatypes to a package version where
    /// it was first defined
    #[prost(message, repeated, tag = "5")]
    pub type_origins: ::prost::alloc::vec::Vec<TypeOrigin>,
    /// The package's transitive dependencies as a mapping from the package's
    /// runtime Id (the Id it is referred to by in other packages) to its
    /// storage Id (the Id it is loaded from on chain).
    #[prost(message, repeated, tag = "6")]
    pub linkage: ::prost::alloc::vec::Vec<Linkage>,
}
/// A Move Module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Module {
    /// Name of this module.
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Serialized bytecode of the module.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub contents: ::core::option::Option<::prost::bytes::Bytes>,
    /// List of DataTypes defined by this module.
    #[prost(message, repeated, tag = "3")]
    pub datatypes: ::prost::alloc::vec::Vec<DatatypeDescriptor>,
    /// List of Functions defined by this module.
    #[prost(message, repeated, tag = "4")]
    pub functions: ::prost::alloc::vec::Vec<FunctionDescriptor>,
}
/// Describes a Move Datatype.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatatypeDescriptor {
    /// Fully qualified name of this Datatype.
    ///
    /// This is `<defining_id>::<module>::<name>`
    #[prost(string, optional, tag = "1")]
    pub type_name: ::core::option::Option<::prost::alloc::string::String>,
    /// PackageId of the package where this Datatype is defined.
    ///
    /// A type's `defining_id` is the `storage_id` of the package version that first introduced or added that type.
    #[prost(string, optional, tag = "2")]
    pub defining_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Name of the module where this Datatype is defined
    #[prost(string, optional, tag = "3")]
    pub module: ::core::option::Option<::prost::alloc::string::String>,
    /// Name of this Datatype
    #[prost(string, optional, tag = "4")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// This type's abilities
    #[prost(enumeration = "Ability", repeated, tag = "5")]
    pub abilities: ::prost::alloc::vec::Vec<i32>,
    /// Ability constraints and phantom status for this type's generic type parameters
    #[prost(message, repeated, tag = "6")]
    pub type_parameters: ::prost::alloc::vec::Vec<TypeParameter>,
    /// Indicates whether this datatype is a 'STRUCT' or an 'ENUM'
    #[prost(enumeration = "datatype_descriptor::DatatypeKind", optional, tag = "7")]
    pub kind: ::core::option::Option<i32>,
    /// Set of fields if this Datatype is a struct.
    ///
    /// The order of the entries is the order of how the fields are defined.
    #[prost(message, repeated, tag = "8")]
    pub fields: ::prost::alloc::vec::Vec<FieldDescriptor>,
    /// Set of variants if this Datatype is an enum.
    ///
    /// The order of the entries is the order of how the variants are defined.
    #[prost(message, repeated, tag = "9")]
    pub variants: ::prost::alloc::vec::Vec<VariantDescriptor>,
}
/// Nested message and enum types in `DatatypeDescriptor`.
pub mod datatype_descriptor {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DatatypeKind {
        Unknown = 0,
        Struct = 1,
        Enum = 2,
    }
    impl DatatypeKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "DATATYPE_KIND_UNKNOWN",
                Self::Struct => "STRUCT",
                Self::Enum => "ENUM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATATYPE_KIND_UNKNOWN" => Some(Self::Unknown),
                "STRUCT" => Some(Self::Struct),
                "ENUM" => Some(Self::Enum),
                _ => None,
            }
        }
    }
}
/// A generic type parameter used in the declaration of a struct or enum.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypeParameter {
    /// The type parameter constraints
    #[prost(enumeration = "Ability", repeated, tag = "1")]
    pub constraints: ::prost::alloc::vec::Vec<i32>,
    /// Whether the parameter is declared as phantom
    #[prost(bool, optional, tag = "2")]
    pub is_phantom: ::core::option::Option<bool>,
}
/// Descriptor of a field that belongs to a struct or enum variant
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldDescriptor {
    /// Name of the field
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Order or position of the field in the struct or enum variant definition.
    #[prost(uint32, optional, tag = "2")]
    pub position: ::core::option::Option<u32>,
    /// The type of the field
    #[prost(message, optional, tag = "3")]
    pub r#type: ::core::option::Option<OpenSignatureBody>,
}
/// Descriptor of an enum variant
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VariantDescriptor {
    /// Name of the variant
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Order or position of the variant in the enum definition.
    #[prost(uint32, optional, tag = "2")]
    pub position: ::core::option::Option<u32>,
    /// Set of fields defined by this variant.
    #[prost(message, repeated, tag = "3")]
    pub fields: ::prost::alloc::vec::Vec<FieldDescriptor>,
}
/// Representation of a type signature that could appear as a field type for a struct or enum
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenSignatureBody {
    /// Type of this signature
    #[prost(enumeration = "open_signature_body::Type", optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    /// Fully qualified name of the datatype when `type` is `DATATYPE`
    #[prost(string, optional, tag = "2")]
    pub type_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Set when `type` is `VECTOR` or `DATATYPE`
    #[prost(message, repeated, tag = "3")]
    pub type_parameter_instantiation: ::prost::alloc::vec::Vec<OpenSignatureBody>,
    /// Position of the type parameter as defined in the containing data type descriptor when `type` is `TYPE_PARAMETER`
    #[prost(uint32, optional, tag = "4")]
    pub type_parameter: ::core::option::Option<u32>,
}
/// Nested message and enum types in `OpenSignatureBody`.
pub mod open_signature_body {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unknown = 0,
        Address = 1,
        Bool = 2,
        U8 = 3,
        U16 = 4,
        U32 = 5,
        U64 = 6,
        U128 = 7,
        U256 = 8,
        Vector = 9,
        Datatype = 10,
        Parameter = 11,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "TYPE_UNKNOWN",
                Self::Address => "ADDRESS",
                Self::Bool => "BOOL",
                Self::U8 => "U8",
                Self::U16 => "U16",
                Self::U32 => "U32",
                Self::U64 => "U64",
                Self::U128 => "U128",
                Self::U256 => "U256",
                Self::Vector => "VECTOR",
                Self::Datatype => "DATATYPE",
                Self::Parameter => "TYPE_PARAMETER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNKNOWN" => Some(Self::Unknown),
                "ADDRESS" => Some(Self::Address),
                "BOOL" => Some(Self::Bool),
                "U8" => Some(Self::U8),
                "U16" => Some(Self::U16),
                "U32" => Some(Self::U32),
                "U64" => Some(Self::U64),
                "U128" => Some(Self::U128),
                "U256" => Some(Self::U256),
                "VECTOR" => Some(Self::Vector),
                "DATATYPE" => Some(Self::Datatype),
                "TYPE_PARAMETER" => Some(Self::Parameter),
                _ => None,
            }
        }
    }
}
/// Descriptor of a Move function
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionDescriptor {
    /// Name of the function
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Whether the function is `public`, `private` or `public(friend)`
    #[prost(enumeration = "function_descriptor::Visibility", optional, tag = "5")]
    pub visibility: ::core::option::Option<i32>,
    /// Whether the function is marked `entry` or not.
    #[prost(bool, optional, tag = "6")]
    pub is_entry: ::core::option::Option<bool>,
    /// Ability constraints for type parameters
    #[prost(message, repeated, tag = "7")]
    pub type_parameters: ::prost::alloc::vec::Vec<TypeParameter>,
    /// Formal parameter types.
    #[prost(message, repeated, tag = "8")]
    pub parameters: ::prost::alloc::vec::Vec<OpenSignature>,
    /// Return types.
    #[prost(message, repeated, tag = "9")]
    pub returns: ::prost::alloc::vec::Vec<OpenSignature>,
}
/// Nested message and enum types in `FunctionDescriptor`.
pub mod function_descriptor {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Visibility {
        Unknown = 0,
        Private = 1,
        Public = 2,
        Friend = 3,
    }
    impl Visibility {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "VISIBILITY_UNKNOWN",
                Self::Private => "PRIVATE",
                Self::Public => "PUBLIC",
                Self::Friend => "FRIEND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VISIBILITY_UNKNOWN" => Some(Self::Unknown),
                "PRIVATE" => Some(Self::Private),
                "PUBLIC" => Some(Self::Public),
                "FRIEND" => Some(Self::Friend),
                _ => None,
            }
        }
    }
}
/// Representation of a type signature that could appear as a function parameter or return value.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenSignature {
    #[prost(enumeration = "open_signature::Reference", optional, tag = "1")]
    pub reference: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<OpenSignatureBody>,
}
/// Nested message and enum types in `OpenSignature`.
pub mod open_signature {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Reference {
        Unknown = 0,
        Immutable = 1,
        Mutable = 2,
    }
    impl Reference {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "REFERENCE_UNKNOWN",
                Self::Immutable => "IMMUTABLE",
                Self::Mutable => "MUTABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REFERENCE_UNKNOWN" => Some(Self::Unknown),
                "IMMUTABLE" => Some(Self::Immutable),
                "MUTABLE" => Some(Self::Mutable),
                _ => None,
            }
        }
    }
}
/// Identifies a struct and the module it was defined in.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypeOrigin {
    #[prost(string, optional, tag = "1")]
    pub module_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub datatype_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub package_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Upgraded package info for the linkage table.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Linkage {
    /// Id of the original package.
    #[prost(string, optional, tag = "1")]
    pub original_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Id of the upgraded package.
    #[prost(string, optional, tag = "2")]
    pub upgraded_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of the upgraded package.
    #[prost(uint64, optional, tag = "3")]
    pub upgraded_version: ::core::option::Option<u64>,
}
/// An `Ability` classifies what operations are permitted for a given type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Ability {
    Unknown = 0,
    /// Allows values of types with this ability to be copied
    Copy = 1,
    /// Allows values of types with this ability to be dropped.
    Drop = 2,
    /// Allows values of types with this ability to exist inside a struct in global storage
    Store = 3,
    /// Allows the type to serve as a key for global storage operations
    Key = 4,
}
impl Ability {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ABILITY_UNKNOWN",
            Self::Copy => "COPY",
            Self::Drop => "DROP",
            Self::Store => "STORE",
            Self::Key => "KEY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ABILITY_UNKNOWN" => Some(Self::Unknown),
            "COPY" => Some(Self::Copy),
            "DROP" => Some(Self::Drop),
            "STORE" => Some(Self::Store),
            "KEY" => Some(Self::Key),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPackageRequest {
    /// Required. The `storage_id` of the requested package.
    #[prost(string, optional, tag = "1")]
    pub package_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPackageResponse {
    /// The package.
    #[prost(message, optional, tag = "1")]
    pub package: ::core::option::Option<Package>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDatatypeRequest {
    /// Required. The `storage_id` of the requested package.
    #[prost(string, optional, tag = "1")]
    pub package_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. The name of the requested module.
    #[prost(string, optional, tag = "2")]
    pub module_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. The name of the requested datatype.
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDatatypeResponse {
    /// The datatype.
    #[prost(message, optional, tag = "1")]
    pub datatype: ::core::option::Option<DatatypeDescriptor>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFunctionRequest {
    /// Required. The `storage_id` of the requested package.
    #[prost(string, optional, tag = "1")]
    pub package_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. The name of the requested module.
    #[prost(string, optional, tag = "2")]
    pub module_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. The name of the requested function.
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFunctionResponse {
    /// The function.
    #[prost(message, optional, tag = "1")]
    pub function: ::core::option::Option<FunctionDescriptor>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPackageVersionsRequest {
    /// Required. The `storage_id` of any version of the package.
    #[prost(string, optional, tag = "1")]
    pub package_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The maximum number of versions to return. The service may return fewer than this value.
    /// If unspecified, at most `1000` entries will be returned.
    /// The maximum value is `10000`; values above `10000` will be coerced to `10000`.
    #[prost(uint32, optional, tag = "2")]
    pub page_size: ::core::option::Option<u32>,
    /// A page token, received from a previous `ListPackageVersions` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListPackageVersions` must
    /// match the call that provided the page token.
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub page_token: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPackageVersionsResponse {
    /// List of all package versions, ordered by version.
    #[prost(message, repeated, tag = "1")]
    pub versions: ::prost::alloc::vec::Vec<PackageVersion>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub next_page_token: ::core::option::Option<::prost::bytes::Bytes>,
}
/// A simplified representation of a package version
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackageVersion {
    /// The storage ID of this package version
    #[prost(string, optional, tag = "1")]
    pub package_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The version number
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
}
/// Generated client implementations.
pub mod move_package_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct MovePackageServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MovePackageServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MovePackageServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MovePackageServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MovePackageServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn get_package(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPackageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetPackageResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta2.MovePackageService/GetPackage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("sui.rpc.v2beta2.MovePackageService", "GetPackage"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_datatype(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDatatypeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetDatatypeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta2.MovePackageService/GetDatatype",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("sui.rpc.v2beta2.MovePackageService", "GetDatatype"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_function(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFunctionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFunctionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta2.MovePackageService/GetFunction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("sui.rpc.v2beta2.MovePackageService", "GetFunction"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn list_package_versions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPackageVersionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPackageVersionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta2.MovePackageService/ListPackageVersions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "sui.rpc.v2beta2.MovePackageService",
                        "ListPackageVersions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod move_package_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with MovePackageServiceServer.
    #[async_trait]
    pub trait MovePackageService: std::marker::Send + std::marker::Sync + 'static {
        async fn get_package(
            &self,
            request: tonic::Request<super::GetPackageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetPackageResponse>,
            tonic::Status,
        >;
        async fn get_datatype(
            &self,
            request: tonic::Request<super::GetDatatypeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetDatatypeResponse>,
            tonic::Status,
        >;
        async fn get_function(
            &self,
            request: tonic::Request<super::GetFunctionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFunctionResponse>,
            tonic::Status,
        >;
        async fn list_package_versions(
            &self,
            request: tonic::Request<super::ListPackageVersionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPackageVersionsResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct MovePackageServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> MovePackageServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for MovePackageServiceServer<T>
    where
        T: MovePackageService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/sui.rpc.v2beta2.MovePackageService/GetPackage" => {
                    #[allow(non_camel_case_types)]
                    struct GetPackageSvc<T: MovePackageService>(pub Arc<T>);
                    impl<
                        T: MovePackageService,
                    > tonic::server::UnaryService<super::GetPackageRequest>
                    for GetPackageSvc<T> {
                        type Response = super::GetPackageResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetPackageRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MovePackageService>::get_package(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPackageSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sui.rpc.v2beta2.MovePackageService/GetDatatype" => {
                    #[allow(non_camel_case_types)]
                    struct GetDatatypeSvc<T: MovePackageService>(pub Arc<T>);
                    impl<
                        T: MovePackageService,
                    > tonic::server::UnaryService<super::GetDatatypeRequest>
                    for GetDatatypeSvc<T> {
                        type Response = super::GetDatatypeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetDatatypeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MovePackageService>::get_datatype(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetDatatypeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sui.rpc.v2beta2.MovePackageService/GetFunction" => {
                    #[allow(non_camel_case_types)]
                    struct GetFunctionSvc<T: MovePackageService>(pub Arc<T>);
                    impl<
                        T: MovePackageService,
                    > tonic::server::UnaryService<super::GetFunctionRequest>
                    for GetFunctionSvc<T> {
                        type Response = super::GetFunctionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFunctionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MovePackageService>::get_function(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFunctionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sui.rpc.v2beta2.MovePackageService/ListPackageVersions" => {
                    #[allow(non_camel_case_types)]
                    struct ListPackageVersionsSvc<T: MovePackageService>(pub Arc<T>);
                    impl<
                        T: MovePackageService,
                    > tonic::server::UnaryService<super::ListPackageVersionsRequest>
                    for ListPackageVersionsSvc<T> {
                        type Response = super::ListPackageVersionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListPackageVersionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MovePackageService>::list_package_versions(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListPackageVersionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for MovePackageServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "sui.rpc.v2beta2.MovePackageService";
    impl<T> tonic::server::NamedService for MovePackageServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// An object on the Sui blockchain.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Object {
    /// This Object serialized as BCS.
    #[prost(message, optional, tag = "1")]
    pub bcs: ::core::option::Option<Bcs>,
    /// `ObjectId` for this object.
    #[prost(string, optional, tag = "2")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of the object.
    #[prost(uint64, optional, tag = "3")]
    pub version: ::core::option::Option<u64>,
    /// The digest of this Object.
    #[prost(string, optional, tag = "4")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Owner of the object.
    #[prost(message, optional, tag = "5")]
    pub owner: ::core::option::Option<Owner>,
    /// The type of this object.
    ///
    /// This will be 'package' for packages and a StructTag for move structs.
    #[prost(string, optional, tag = "6")]
    pub object_type: ::core::option::Option<::prost::alloc::string::String>,
    /// DEPRECATED this field is no longer used to determine whether a tx can transfer this
    /// object. Instead, it is always calculated from the objects type when loaded in execution.
    ///
    /// Only set for Move structs
    #[prost(bool, optional, tag = "7")]
    pub has_public_transfer: ::core::option::Option<bool>,
    /// BCS bytes of a Move struct value.
    ///
    /// Only set for Move structs
    #[prost(message, optional, tag = "8")]
    pub contents: ::core::option::Option<Bcs>,
    /// Package information for Move Packages
    #[prost(message, optional, tag = "9")]
    pub package: ::core::option::Option<Package>,
    /// The digest of the transaction that created or last mutated this object
    #[prost(string, optional, tag = "10")]
    pub previous_transaction: ::core::option::Option<::prost::alloc::string::String>,
    /// The amount of SUI to rebate if this object gets deleted.
    /// This number is re-calculated each time the object is mutated based on
    /// the present storage gas price.
    #[prost(uint64, optional, tag = "11")]
    pub storage_rebate: ::core::option::Option<u64>,
    /// JSON rendering of the object.
    #[prost(message, optional, boxed, tag = "100")]
    pub json: ::core::option::Option<::prost::alloc::boxed::Box<::prost_types::Value>>,
}
/// Reference to an object.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectReference {
    /// The object id of this object.
    #[prost(string, optional, tag = "1")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The version of this object.
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
    /// The digest of this object.
    #[prost(string, optional, tag = "3")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
}
/// Enum of different types of ownership for an object.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Owner {
    #[prost(enumeration = "owner::OwnerKind", optional, tag = "1")]
    pub kind: ::core::option::Option<i32>,
    /// Address or ObjectId of the owner
    #[prost(string, optional, tag = "2")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    /// The `initial_shared_version` if kind is `SHARED` or `start_version` if kind `CONSENSUS_ADDRESS`.
    #[prost(uint64, optional, tag = "3")]
    pub version: ::core::option::Option<u64>,
}
/// Nested message and enum types in `Owner`.
pub mod owner {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OwnerKind {
        Unknown = 0,
        Address = 1,
        Object = 2,
        Shared = 3,
        Immutable = 4,
        ConsensusAddress = 5,
    }
    impl OwnerKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "OWNER_KIND_UNKNOWN",
                Self::Address => "ADDRESS",
                Self::Object => "OBJECT",
                Self::Shared => "SHARED",
                Self::Immutable => "IMMUTABLE",
                Self::ConsensusAddress => "CONSENSUS_ADDRESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OWNER_KIND_UNKNOWN" => Some(Self::Unknown),
                "ADDRESS" => Some(Self::Address),
                "OBJECT" => Some(Self::Object),
                "SHARED" => Some(Self::Shared),
                "IMMUTABLE" => Some(Self::Immutable),
                "CONSENSUS_ADDRESS" => Some(Self::ConsensusAddress),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtocolConfig {
    #[prost(uint64, optional, tag = "1")]
    pub protocol_version: ::core::option::Option<u64>,
    #[prost(map = "string, bool", tag = "2")]
    pub feature_flags: ::std::collections::HashMap<::prost::alloc::string::String, bool>,
    #[prost(map = "string, string", tag = "3")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// A signature from a user.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserSignature {
    /// This signature serialized as as BCS.
    ///
    /// When provided as input this will support both the form that is length
    /// prefixed as well as not length prefixed.
    #[prost(message, optional, tag = "1")]
    pub bcs: ::core::option::Option<Bcs>,
    /// The signature scheme of this signature.
    #[prost(enumeration = "SignatureScheme", optional, tag = "2")]
    pub scheme: ::core::option::Option<i32>,
    #[prost(oneof = "user_signature::Signature", tags = "3, 4, 5, 6")]
    pub signature: ::core::option::Option<user_signature::Signature>,
}
/// Nested message and enum types in `UserSignature`.
pub mod user_signature {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Signature {
        /// Simple signature if scheme is ed25519 | secp256k1 | secp256r1.
        #[prost(message, tag = "3")]
        Simple(super::SimpleSignature),
        /// The multisig aggregated signature if scheme is `MULTISIG`.
        #[prost(message, tag = "4")]
        Multisig(super::MultisigAggregatedSignature),
        /// The zklogin authenticator if scheme is `ZKLOGIN`.
        #[prost(message, tag = "5")]
        Zklogin(super::ZkLoginAuthenticator),
        /// The passkey authenticator if scheme is `PASSKEY`.
        #[prost(message, tag = "6")]
        Passkey(super::PasskeyAuthenticator),
    }
}
/// Either an ed25519, secp256k1 or secp256r1 signature
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimpleSignature {
    /// The signature scheme of this signature.
    #[prost(enumeration = "SignatureScheme", optional, tag = "1")]
    pub scheme: ::core::option::Option<i32>,
    /// Signature bytes
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub signature: ::core::option::Option<::prost::bytes::Bytes>,
    /// Public key bytes
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub public_key: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Public key equivalent for zklogin authenticators.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginPublicIdentifier {
    #[prost(string, optional, tag = "1")]
    pub iss: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "2")]
    pub address_seed: ::core::option::Option<::prost::alloc::string::String>,
}
/// Set of valid public keys for multisig committee members.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigMemberPublicKey {
    /// The signature scheme of this public key.
    #[prost(enumeration = "SignatureScheme", optional, tag = "1")]
    pub scheme: ::core::option::Option<i32>,
    /// Public key bytes if scheme is ed25519 | secp256k1 | secp256r1 | passkey.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub public_key: ::core::option::Option<::prost::bytes::Bytes>,
    /// A zklogin public identifier if scheme is zklogin.
    #[prost(message, optional, tag = "3")]
    pub zklogin: ::core::option::Option<ZkLoginPublicIdentifier>,
}
/// A member in a multisig committee.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigMember {
    /// The public key of the committee member.
    #[prost(message, optional, tag = "1")]
    pub public_key: ::core::option::Option<MultisigMemberPublicKey>,
    /// The weight of this member's signature.
    #[prost(uint32, optional, tag = "2")]
    pub weight: ::core::option::Option<u32>,
}
/// A multisig committee.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigCommittee {
    /// A list of committee members and their corresponding weight.
    #[prost(message, repeated, tag = "1")]
    pub members: ::prost::alloc::vec::Vec<MultisigMember>,
    /// The threshold of signatures needed to validate a signature from
    /// this committee.
    #[prost(uint32, optional, tag = "2")]
    pub threshold: ::core::option::Option<u32>,
}
/// Aggregated signature from members of a multisig committee.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigAggregatedSignature {
    /// The plain signatures encoded with signature scheme.
    ///
    /// The signatures must be in the same order as they are listed in the committee.
    #[prost(message, repeated, tag = "1")]
    pub signatures: ::prost::alloc::vec::Vec<MultisigMemberSignature>,
    /// Bitmap indicating which committee members contributed to the
    /// signature.
    #[prost(uint32, optional, tag = "2")]
    pub bitmap: ::core::option::Option<u32>,
    /// If present, means this signature's on-chain format uses the old
    /// legacy multisig format.
    #[prost(uint32, repeated, tag = "3")]
    pub legacy_bitmap: ::prost::alloc::vec::Vec<u32>,
    /// The committee to use to validate this signature.
    #[prost(message, optional, tag = "4")]
    pub committee: ::core::option::Option<MultisigCommittee>,
}
/// A signature from a member of a multisig committee.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigMemberSignature {
    /// The signature scheme of this signature.
    #[prost(enumeration = "SignatureScheme", optional, tag = "1")]
    pub scheme: ::core::option::Option<i32>,
    /// Signature bytes if scheme is ed25519 | secp256k1 | secp256r1.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub signature: ::core::option::Option<::prost::bytes::Bytes>,
    /// The zklogin authenticator if scheme is `ZKLOGIN`.
    #[prost(message, optional, tag = "3")]
    pub zklogin: ::core::option::Option<ZkLoginAuthenticator>,
    /// The passkey authenticator if scheme is `PASSKEY`.
    #[prost(message, optional, tag = "4")]
    pub passkey: ::core::option::Option<PasskeyAuthenticator>,
}
/// A zklogin authenticator.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginAuthenticator {
    /// Zklogin proof and inputs required to perform proof verification.
    #[prost(message, optional, tag = "1")]
    pub inputs: ::core::option::Option<ZkLoginInputs>,
    /// Maximum epoch for which the proof is valid.
    #[prost(uint64, optional, tag = "2")]
    pub max_epoch: ::core::option::Option<u64>,
    /// User signature with the public key attested to by the provided proof.
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<SimpleSignature>,
}
/// A zklogin groth16 proof and the required inputs to perform proof verification.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginInputs {
    #[prost(message, optional, tag = "1")]
    pub proof_points: ::core::option::Option<ZkLoginProof>,
    #[prost(message, optional, tag = "2")]
    pub iss_base64_details: ::core::option::Option<ZkLoginClaim>,
    #[prost(string, optional, tag = "3")]
    pub header_base64: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "4")]
    pub address_seed: ::core::option::Option<::prost::alloc::string::String>,
}
/// A zklogin groth16 proof.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginProof {
    #[prost(message, optional, tag = "1")]
    pub a: ::core::option::Option<CircomG1>,
    #[prost(message, optional, tag = "2")]
    pub b: ::core::option::Option<CircomG2>,
    #[prost(message, optional, tag = "3")]
    pub c: ::core::option::Option<CircomG1>,
}
/// A claim of the iss in a zklogin proof.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginClaim {
    #[prost(string, optional, tag = "1")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "2")]
    pub index_mod_4: ::core::option::Option<u32>,
}
/// A G1 point.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CircomG1 {
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "1")]
    pub e0: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "2")]
    pub e1: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "3")]
    pub e2: ::core::option::Option<::prost::alloc::string::String>,
}
/// A G2 point.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CircomG2 {
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "1")]
    pub e00: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "2")]
    pub e01: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "3")]
    pub e10: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "4")]
    pub e11: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "5")]
    pub e20: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "6")]
    pub e21: ::core::option::Option<::prost::alloc::string::String>,
}
/// A passkey authenticator.
///
/// See
/// [struct.PasskeyAuthenticator](<https://mystenlabs.github.io/sui-rust-sdk/sui_sdk_types/struct.PasskeyAuthenticator.html#bcs>)
/// for more information on the requirements on the shape of the
/// `client_data_json` field.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PasskeyAuthenticator {
    /// Opaque authenticator data for this passkey signature.
    ///
    /// See [Authenticator Data](<https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data>) for
    /// more information on this field.
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub authenticator_data: ::core::option::Option<::prost::bytes::Bytes>,
    /// Structured, unparsed, JSON for this passkey signature.
    ///
    /// See [CollectedClientData](<https://www.w3.org/TR/webauthn-2/#dictdef-collectedclientdata>)
    /// for more information on this field.
    #[prost(string, optional, tag = "2")]
    pub client_data_json: ::core::option::Option<::prost::alloc::string::String>,
    /// A secp256r1 signature.
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<SimpleSignature>,
}
/// The validator set for a particular epoch.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorCommittee {
    /// The epoch where this committee governs.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// The committee members.
    #[prost(message, repeated, tag = "2")]
    pub members: ::prost::alloc::vec::Vec<ValidatorCommitteeMember>,
}
/// A member of a validator committee.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorCommitteeMember {
    /// The 96-byte Bls12381 public key for this validator.
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub public_key: ::core::option::Option<::prost::bytes::Bytes>,
    /// voting weight this validator possesses.
    #[prost(uint64, optional, tag = "2")]
    pub weight: ::core::option::Option<u64>,
}
/// / An aggregated signature from multiple validators.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorAggregatedSignature {
    /// The epoch when this signature was produced.
    ///
    /// This can be used to lookup the `ValidatorCommittee` from this epoch
    /// to verify this signature.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// The 48-byte Bls12381 aggregated signature.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub signature: ::core::option::Option<::prost::bytes::Bytes>,
    /// Bitmap indicating which members of the committee contributed to
    /// this signature.
    #[prost(uint32, repeated, tag = "3")]
    pub bitmap: ::prost::alloc::vec::Vec<u32>,
}
/// Flag use to disambiguate the signature schemes supported by Sui.
///
/// Note: the enum values defined by this proto message exactly match their
/// expected BCS serialized values when serialized as a u8. See
/// [enum.SignatureScheme](<https://mystenlabs.github.io/sui-rust-sdk/sui_sdk_types/enum.SignatureScheme.html>)
/// for more information about signature schemes.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SignatureScheme {
    Ed25519 = 0,
    Secp256k1 = 1,
    Secp256r1 = 2,
    Multisig = 3,
    Bls12381 = 4,
    Zklogin = 5,
    Passkey = 6,
}
impl SignatureScheme {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Ed25519 => "ED25519",
            Self::Secp256k1 => "SECP256K1",
            Self::Secp256r1 => "SECP256R1",
            Self::Multisig => "MULTISIG",
            Self::Bls12381 => "BLS12381",
            Self::Zklogin => "ZKLOGIN",
            Self::Passkey => "PASSKEY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ED25519" => Some(Self::Ed25519),
            "SECP256K1" => Some(Self::Secp256k1),
            "SECP256R1" => Some(Self::Secp256r1),
            "MULTISIG" => Some(Self::Multisig),
            "BLS12381" => Some(Self::Bls12381),
            "ZKLOGIN" => Some(Self::Zklogin),
            "PASSKEY" => Some(Self::Passkey),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifySignatureRequest {
    /// The message to verify against.
    ///
    /// Today the only supported message types are `PersonalMessage` and
    /// `TransactionData` and the `Bcs.name` must be set to indicate which type of
    /// message is being verified.
    #[prost(message, optional, tag = "1")]
    pub message: ::core::option::Option<Bcs>,
    /// The siganture to verify.
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<UserSignature>,
    /// Optional. Address to validate against the provided signature.
    ///
    /// If provided, this address will be compared against the the address derived
    /// from the provide signature and a successful response will only be returned
    /// if they match.
    #[prost(string, optional, tag = "3")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    /// The set of JWKs to use when verifying Zklogin signatures.
    /// If this is empty the current set of valid JWKs stored onchain will be used
    #[prost(message, repeated, tag = "4")]
    pub jwks: ::prost::alloc::vec::Vec<ActiveJwk>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifySignatureResponse {
    /// Indicates if the provided signature was valid given the requested parameters.
    #[prost(bool, optional, tag = "1")]
    pub is_valid: ::core::option::Option<bool>,
    /// If `is_valid` is `false`, this is the reason for why the signature verification failed.
    #[prost(string, optional, tag = "2")]
    pub reason: ::core::option::Option<::prost::alloc::string::String>,
}
/// Generated client implementations.
pub mod signature_verification_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct SignatureVerificationServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SignatureVerificationServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SignatureVerificationServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SignatureVerificationServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SignatureVerificationServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Perform signature verification of a UserSignature against the provided message.
        pub async fn verify_signature(
            &mut self,
            request: impl tonic::IntoRequest<super::VerifySignatureRequest>,
        ) -> std::result::Result<
            tonic::Response<super::VerifySignatureResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta2.SignatureVerificationService/VerifySignature",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "sui.rpc.v2beta2.SignatureVerificationService",
                        "VerifySignature",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod signature_verification_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SignatureVerificationServiceServer.
    #[async_trait]
    pub trait SignatureVerificationService: std::marker::Send + std::marker::Sync + 'static {
        /// Perform signature verification of a UserSignature against the provided message.
        async fn verify_signature(
            &self,
            request: tonic::Request<super::VerifySignatureRequest>,
        ) -> std::result::Result<
            tonic::Response<super::VerifySignatureResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct SignatureVerificationServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> SignatureVerificationServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for SignatureVerificationServiceServer<T>
    where
        T: SignatureVerificationService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/sui.rpc.v2beta2.SignatureVerificationService/VerifySignature" => {
                    #[allow(non_camel_case_types)]
                    struct VerifySignatureSvc<T: SignatureVerificationService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: SignatureVerificationService,
                    > tonic::server::UnaryService<super::VerifySignatureRequest>
                    for VerifySignatureSvc<T> {
                        type Response = super::VerifySignatureResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VerifySignatureRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SignatureVerificationService>::verify_signature(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = VerifySignatureSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for SignatureVerificationServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "sui.rpc.v2beta2.SignatureVerificationService";
    impl<T> tonic::server::NamedService for SignatureVerificationServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for SubscriptionService.SubscribeCheckpoints
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeCheckpointsRequest {
    /// Optional. Mask for specifiying which parts of the
    /// SubscribeCheckpointsResponse should be returned.
    #[prost(message, optional, tag = "1")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Response message for SubscriptionService.SubscribeCheckpoints
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeCheckpointsResponse {
    /// Required. The checkpoint sequence number and value of the current cursor
    /// into the checkpoint stream
    #[prost(uint64, optional, tag = "1")]
    pub cursor: ::core::option::Option<u64>,
    /// The requested data for this checkpoint
    #[prost(message, optional, tag = "2")]
    pub checkpoint: ::core::option::Option<Checkpoint>,
}
/// Generated client implementations.
pub mod subscription_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct SubscriptionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SubscriptionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SubscriptionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SubscriptionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SubscriptionServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Subscribe to the stream of checkpoints.
        ///
        /// This API provides a subscription to the checkpoint stream for the Sui
        /// blockchain. When a subscription is initialized the stream will begin with
        /// the latest executed checkpoint as seen by the server. Responses are
        /// gaurenteed to return checkpoints in-order and without gaps. This enables
        /// clients to know exactly the last checkpoint they have processed and in the
        /// event the subscription terminates (either by the client/server or by the
        /// connection breaking), clients will be able to reinitailize a subscription
        /// and then leverage other APIs in order to request data for the checkpoints
        /// they missed.
        pub async fn subscribe_checkpoints(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeCheckpointsRequest>,
        ) -> std::result::Result<
            tonic::Response<
                tonic::codec::Streaming<super::SubscribeCheckpointsResponse>,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta2.SubscriptionService/SubscribeCheckpoints",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "sui.rpc.v2beta2.SubscriptionService",
                        "SubscribeCheckpoints",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod subscription_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SubscriptionServiceServer.
    #[async_trait]
    pub trait SubscriptionService: std::marker::Send + std::marker::Sync + 'static {
        /// Server streaming response type for the SubscribeCheckpoints method.
        type SubscribeCheckpointsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<
                    super::SubscribeCheckpointsResponse,
                    tonic::Status,
                >,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to the stream of checkpoints.
        ///
        /// This API provides a subscription to the checkpoint stream for the Sui
        /// blockchain. When a subscription is initialized the stream will begin with
        /// the latest executed checkpoint as seen by the server. Responses are
        /// gaurenteed to return checkpoints in-order and without gaps. This enables
        /// clients to know exactly the last checkpoint they have processed and in the
        /// event the subscription terminates (either by the client/server or by the
        /// connection breaking), clients will be able to reinitailize a subscription
        /// and then leverage other APIs in order to request data for the checkpoints
        /// they missed.
        async fn subscribe_checkpoints(
            &self,
            request: tonic::Request<super::SubscribeCheckpointsRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::SubscribeCheckpointsStream>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct SubscriptionServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> SubscriptionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for SubscriptionServiceServer<T>
    where
        T: SubscriptionService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/sui.rpc.v2beta2.SubscriptionService/SubscribeCheckpoints" => {
                    #[allow(non_camel_case_types)]
                    struct SubscribeCheckpointsSvc<T: SubscriptionService>(pub Arc<T>);
                    impl<
                        T: SubscriptionService,
                    > tonic::server::ServerStreamingService<
                        super::SubscribeCheckpointsRequest,
                    > for SubscribeCheckpointsSvc<T> {
                        type Response = super::SubscribeCheckpointsResponse;
                        type ResponseStream = T::SubscribeCheckpointsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubscribeCheckpointsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SubscriptionService>::subscribe_checkpoints(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubscribeCheckpointsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for SubscriptionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "sui.rpc.v2beta2.SubscriptionService";
    impl<T> tonic::server::NamedService for SubscriptionServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemState {
    /// The version of the system state data structure type.
    #[prost(uint64, optional, tag = "1")]
    pub version: ::core::option::Option<u64>,
    /// The epoch id
    #[prost(uint64, optional, tag = "2")]
    pub epoch: ::core::option::Option<u64>,
    /// The protocol version
    #[prost(uint64, optional, tag = "3")]
    pub protocol_version: ::core::option::Option<u64>,
    /// Information about the validators
    #[prost(message, optional, tag = "4")]
    pub validators: ::core::option::Option<ValidatorSet>,
    /// Storage Fund info
    #[prost(message, optional, tag = "5")]
    pub storage_fund: ::core::option::Option<StorageFund>,
    /// Set of system config parameters
    #[prost(message, optional, tag = "6")]
    pub parameters: ::core::option::Option<SystemParameters>,
    /// The reference gas price for this epoch
    #[prost(uint64, optional, tag = "7")]
    pub reference_gas_price: ::core::option::Option<u64>,
    /// A list of the records of validator reporting each other.
    ///
    /// There is an entry in this list for each validator that has been reported
    /// at least once. Each record contains all the validators that reported
    /// them. If a validator has never been reported they don't have a record in this list.
    /// This lists persists across epoch: a peer continues being in a reported state until the
    /// reporter doesn't explicitly remove their report.
    #[prost(message, repeated, tag = "8")]
    pub validator_report_records: ::prost::alloc::vec::Vec<ValidatorReportRecord>,
    /// Schedule of stake subsidies given out each epoch.
    #[prost(message, optional, tag = "9")]
    pub stake_subsidy: ::core::option::Option<StakeSubsidy>,
    /// Whether the system is running in a downgraded safe mode due to a non-recoverable bug.
    /// This is set whenever we failed to execute advance_epoch, and ended up executing advance_epoch_safe_mode.
    /// It can be reset once we are able to successfully execute advance_epoch.
    /// The rest of the fields starting with `safe_mode_` are accumulated during safe mode
    /// when advance_epoch_safe_mode is executed. They will eventually be processed once we
    /// are out of safe mode.
    #[prost(bool, optional, tag = "10")]
    pub safe_mode: ::core::option::Option<bool>,
    /// Storage rewards accumulated during safe_mode
    #[prost(uint64, optional, tag = "11")]
    pub safe_mode_storage_rewards: ::core::option::Option<u64>,
    /// Computation rewards accumulated during safe_mode
    #[prost(uint64, optional, tag = "12")]
    pub safe_mode_computation_rewards: ::core::option::Option<u64>,
    /// Storage rebates paid out during safe_mode
    #[prost(uint64, optional, tag = "13")]
    pub safe_mode_storage_rebates: ::core::option::Option<u64>,
    /// Nonrefundable storage fees accumulated during safe_mode
    #[prost(uint64, optional, tag = "14")]
    pub safe_mode_non_refundable_storage_fee: ::core::option::Option<u64>,
    /// Unix timestamp of when this this epoch started
    #[prost(uint64, optional, tag = "15")]
    pub epoch_start_timestamp_ms: ::core::option::Option<u64>,
    /// Any extra fields that's not defined statically.
    #[prost(message, optional, tag = "16")]
    pub extra_fields: ::core::option::Option<MoveTable>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorReportRecord {
    /// The address of the validator being reported
    #[prost(string, optional, tag = "1")]
    pub reported: ::core::option::Option<::prost::alloc::string::String>,
    /// The list of validator (addresses) that are reporting on the validator specified by `reported`
    #[prost(string, repeated, tag = "2")]
    pub reporters: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemParameters {
    /// The duration of an epoch, in milliseconds.
    #[prost(uint64, optional, tag = "1")]
    pub epoch_duration_ms: ::core::option::Option<u64>,
    /// The starting epoch in which stake subsidies start being paid out
    #[prost(uint64, optional, tag = "2")]
    pub stake_subsidy_start_epoch: ::core::option::Option<u64>,
    /// Minimum number of active validators at any moment.
    #[prost(uint64, optional, tag = "3")]
    pub min_validator_count: ::core::option::Option<u64>,
    /// Maximum number of active validators at any moment.
    /// We do not allow the number of validators in any epoch to go above this.
    #[prost(uint64, optional, tag = "4")]
    pub max_validator_count: ::core::option::Option<u64>,
    /// Deprecated.
    /// Lower-bound on the amount of stake required to become a validator.
    #[prost(uint64, optional, tag = "5")]
    pub min_validator_joining_stake: ::core::option::Option<u64>,
    /// Deprecated.
    /// Validators with stake amount below `validator_low_stake_threshold` are considered to
    /// have low stake and will be escorted out of the validator set after being below this
    /// threshold for more than `validator_low_stake_grace_period` number of epochs.
    #[prost(uint64, optional, tag = "6")]
    pub validator_low_stake_threshold: ::core::option::Option<u64>,
    /// Deprecated.
    /// Validators with stake below `validator_very_low_stake_threshold` will be removed
    /// immediately at epoch change, no grace period.
    #[prost(uint64, optional, tag = "7")]
    pub validator_very_low_stake_threshold: ::core::option::Option<u64>,
    /// A validator can have stake below `validator_low_stake_threshold`
    /// for this many epochs before being kicked out.
    #[prost(uint64, optional, tag = "8")]
    pub validator_low_stake_grace_period: ::core::option::Option<u64>,
    /// Any extra fields that are not defined statically.
    #[prost(message, optional, tag = "9")]
    pub extra_fields: ::core::option::Option<MoveTable>,
}
/// A message that represents a Move `0x2::table::Table` or `0x2::bag::Bag`
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveTable {
    /// The UID of the table or bag
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    /// The size or number of key-value pairs in the table or bag
    #[prost(uint64, optional, tag = "2")]
    pub size: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StakeSubsidy {
    /// Balance of SUI set aside for stake subsidies that will be drawn down over time.
    #[prost(uint64, optional, tag = "1")]
    pub balance: ::core::option::Option<u64>,
    /// Count of the number of times stake subsidies have been distributed.
    #[prost(uint64, optional, tag = "2")]
    pub distribution_counter: ::core::option::Option<u64>,
    /// The amount of stake subsidy to be drawn down per distribution.
    /// This amount decays and decreases over time.
    #[prost(uint64, optional, tag = "3")]
    pub current_distribution_amount: ::core::option::Option<u64>,
    /// Number of distributions to occur before the distribution amount decays.
    #[prost(uint64, optional, tag = "4")]
    pub stake_subsidy_period_length: ::core::option::Option<u64>,
    /// The rate at which the distribution amount decays at the end of each
    /// period. Expressed in basis points.
    #[prost(uint32, optional, tag = "5")]
    pub stake_subsidy_decrease_rate: ::core::option::Option<u32>,
    /// Any extra fields that's not defined statically.
    #[prost(message, optional, tag = "6")]
    pub extra_fields: ::core::option::Option<MoveTable>,
}
/// Struct representing the onchain storage fund.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StorageFund {
    /// This is the sum of `storage_rebate` of
    /// all objects currently stored on-chain. To maintain this invariant, the only inflow of this
    /// balance is storage charges collected from transactions, and the only outflow is storage rebates
    /// of transactions, including both the portion refunded to the transaction senders as well as
    /// the non-refundable portion taken out and put into `non_refundable_balance`.
    #[prost(uint64, optional, tag = "1")]
    pub total_object_storage_rebates: ::core::option::Option<u64>,
    /// Represents any remaining inflow of the storage fund that should not
    /// be taken out of the fund.
    #[prost(uint64, optional, tag = "2")]
    pub non_refundable_balance: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorSet {
    /// Total amount of stake from all active validators at the beginning of the epoch.
    /// Written only once per epoch, in `advance_epoch` function.
    #[prost(uint64, optional, tag = "1")]
    pub total_stake: ::core::option::Option<u64>,
    /// The current list of active validators.
    #[prost(message, repeated, tag = "2")]
    pub active_validators: ::prost::alloc::vec::Vec<Validator>,
    /// List of new validator candidates added during the current epoch.
    /// They will be processed at the end of the epoch.
    ///
    /// key: u64 (index), value: 0x3::validator::Validator
    #[prost(message, optional, tag = "3")]
    pub pending_active_validators: ::core::option::Option<MoveTable>,
    /// Removal requests from the validators. Each element is an index
    /// pointing to `active_validators`.
    #[prost(uint64, repeated, tag = "4")]
    pub pending_removals: ::prost::alloc::vec::Vec<u64>,
    /// Mappings from staking pool's ID to the sui address of a validator.
    ///
    /// key: address (staking pool Id), value: address (sui address of the validator)
    #[prost(message, optional, tag = "5")]
    pub staking_pool_mappings: ::core::option::Option<MoveTable>,
    /// Mapping from a staking pool ID to the inactive validator that has that pool as its staking pool.
    /// When a validator is deactivated the validator is removed from `active_validators` it
    /// is added to this table so that stakers can continue to withdraw their stake from it.
    ///
    /// key: address (staking pool Id), value: 0x3::validator_wrapper::ValidatorWrapper
    #[prost(message, optional, tag = "6")]
    pub inactive_validators: ::core::option::Option<MoveTable>,
    /// Table storing preactive/candidate validators, mapping their addresses to their `Validator ` structs.
    /// When an address calls `request_add_validator_candidate`, they get added to this table and become a preactive
    /// validator.
    /// When the candidate has met the min stake requirement, they can call `request_add_validator` to
    /// officially add them to the active validator set `active_validators` next epoch.
    ///
    /// key: address (sui address of the validator), value: 0x3::validator_wrapper::ValidatorWrapper
    #[prost(message, optional, tag = "7")]
    pub validator_candidates: ::core::option::Option<MoveTable>,
    /// Table storing the number of epochs during which a validator's stake has been below the low stake threshold.
    #[prost(map = "string, uint64", tag = "8")]
    pub at_risk_validators: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        u64,
    >,
    /// Any extra fields that's not defined statically.
    #[prost(message, optional, tag = "9")]
    pub extra_fields: ::core::option::Option<MoveTable>,
}
/// Definition of a Validator in the system contracts
///
/// Note: fields of ValidatorMetadata are flattened into this type
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Validator {
    /// A unique human-readable name of this validator.
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The Sui Address of the validator. This is the sender that created the Validator object,
    /// and also the address to send validator/coins to during withdraws.
    #[prost(string, optional, tag = "2")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub image_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub project_url: ::core::option::Option<::prost::alloc::string::String>,
    /// The public key bytes corresponding to the private key that the validator
    /// holds to sign transactions. For now, this is the same as AuthorityName.
    #[prost(bytes = "bytes", optional, tag = "7")]
    pub protocol_public_key: ::core::option::Option<::prost::bytes::Bytes>,
    /// This is a proof that the validator has ownership of the protocol private key
    #[prost(bytes = "bytes", optional, tag = "8")]
    pub proof_of_possession: ::core::option::Option<::prost::bytes::Bytes>,
    /// The public key bytes corresponding to the private key that the validator
    /// uses to establish TLS connections
    #[prost(bytes = "bytes", optional, tag = "10")]
    pub network_public_key: ::core::option::Option<::prost::bytes::Bytes>,
    /// The public key bytes correstponding to the Narwhal Worker
    #[prost(bytes = "bytes", optional, tag = "12")]
    pub worker_public_key: ::core::option::Option<::prost::bytes::Bytes>,
    /// The network address of the validator (could also contain extra info such as port, DNS and etc.).
    #[prost(string, optional, tag = "13")]
    pub network_address: ::core::option::Option<::prost::alloc::string::String>,
    /// The address of the validator used for p2p activities such as state sync (could also contain extra info such as port, DNS and etc.).
    #[prost(string, optional, tag = "14")]
    pub p2p_address: ::core::option::Option<::prost::alloc::string::String>,
    /// The address of the narwhal primary
    #[prost(string, optional, tag = "15")]
    pub primary_address: ::core::option::Option<::prost::alloc::string::String>,
    /// The address of the narwhal worker
    #[prost(string, optional, tag = "16")]
    pub worker_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "bytes", optional, tag = "18")]
    pub next_epoch_protocol_public_key: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "19")]
    pub next_epoch_proof_of_possession: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "21")]
    pub next_epoch_network_public_key: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "23")]
    pub next_epoch_worker_public_key: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(string, optional, tag = "24")]
    pub next_epoch_network_address: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "25")]
    pub next_epoch_p2p_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "26")]
    pub next_epoch_primary_address: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "27")]
    pub next_epoch_worker_address: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// Any extra fields that's not defined statically in the `ValidatorMetadata` struct
    #[prost(message, optional, tag = "28")]
    pub metadata_extra_fields: ::core::option::Option<MoveTable>,
    /// The voting power of this validator, which might be different from its
    /// stake amount.
    #[prost(uint64, optional, tag = "29")]
    pub voting_power: ::core::option::Option<u64>,
    /// The ID of this validator's current valid `UnverifiedValidatorOperationCap`
    #[prost(string, optional, tag = "30")]
    pub operation_cap_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Gas price quote, updated only at end of epoch.
    #[prost(uint64, optional, tag = "31")]
    pub gas_price: ::core::option::Option<u64>,
    /// Staking pool for this validator.
    #[prost(message, optional, tag = "32")]
    pub staking_pool: ::core::option::Option<StakingPool>,
    /// Commission rate of the validator, in basis point.
    #[prost(uint64, optional, tag = "33")]
    pub commission_rate: ::core::option::Option<u64>,
    /// Total amount of stake that would be active in the next epoch.
    #[prost(uint64, optional, tag = "34")]
    pub next_epoch_stake: ::core::option::Option<u64>,
    /// This validator's gas price quote for the next epoch.
    #[prost(uint64, optional, tag = "35")]
    pub next_epoch_gas_price: ::core::option::Option<u64>,
    /// The commission rate of the validator starting the next epoch, in basis point.
    #[prost(uint64, optional, tag = "36")]
    pub next_epoch_commission_rate: ::core::option::Option<u64>,
    /// Any extra fields that's not defined statically.
    #[prost(message, optional, tag = "37")]
    pub extra_fields: ::core::option::Option<MoveTable>,
}
/// A staking pool embedded in each validator struct in the system state object.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StakingPool {
    /// UID of the StakingPool object
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    /// The epoch at which this pool became active.
    /// The value is `None` if the pool is pre-active and `Some(<epoch_number>)` if active or inactive.
    #[prost(uint64, optional, tag = "2")]
    pub activation_epoch: ::core::option::Option<u64>,
    /// The epoch at which this staking pool ceased to be active. `None` = {pre-active, active},
    /// `Some(<epoch_number>)` if in-active, and it was de-activated at epoch `<epoch_number>`.
    #[prost(uint64, optional, tag = "3")]
    pub deactivation_epoch: ::core::option::Option<u64>,
    /// The total number of SUI tokens in this pool, including the SUI in the rewards_pool, as well as in all the principal
    /// in the `StakedSui` object, updated at epoch boundaries.
    #[prost(uint64, optional, tag = "4")]
    pub sui_balance: ::core::option::Option<u64>,
    /// The epoch stake rewards will be added here at the end of each epoch.
    #[prost(uint64, optional, tag = "5")]
    pub rewards_pool: ::core::option::Option<u64>,
    /// Total number of pool tokens issued by the pool.
    #[prost(uint64, optional, tag = "6")]
    pub pool_token_balance: ::core::option::Option<u64>,
    /// Exchange rate history of previous epochs.
    ///
    /// The entries start from the `activation_epoch` of this pool and contains exchange rates at the beginning of each epoch,
    /// i.e., right after the rewards for the previous epoch have been deposited into the pool.
    ///
    /// key: u64 (epoch number), value: PoolTokenExchangeRate
    #[prost(message, optional, tag = "7")]
    pub exchange_rates: ::core::option::Option<MoveTable>,
    /// Pending stake amount for this epoch, emptied at epoch boundaries.
    #[prost(uint64, optional, tag = "8")]
    pub pending_stake: ::core::option::Option<u64>,
    /// Pending stake withdrawn during the current epoch, emptied at epoch boundaries.
    /// This includes both the principal and rewards SUI withdrawn.
    #[prost(uint64, optional, tag = "9")]
    pub pending_total_sui_withdraw: ::core::option::Option<u64>,
    /// Pending pool token withdrawn during the current epoch, emptied at epoch boundaries.
    #[prost(uint64, optional, tag = "10")]
    pub pending_pool_token_withdraw: ::core::option::Option<u64>,
    /// Any extra fields that's not defined statically.
    #[prost(message, optional, tag = "11")]
    pub extra_fields: ::core::option::Option<MoveTable>,
}
/// A transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
    /// This Transaction serialized as BCS.
    #[prost(message, optional, tag = "1")]
    pub bcs: ::core::option::Option<Bcs>,
    /// The digest of this Transaction.
    #[prost(string, optional, tag = "2")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of this Transaction.
    #[prost(int32, optional, tag = "3")]
    pub version: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "4")]
    pub kind: ::core::option::Option<TransactionKind>,
    #[prost(string, optional, tag = "5")]
    pub sender: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub gas_payment: ::core::option::Option<GasPayment>,
    #[prost(message, optional, tag = "7")]
    pub expiration: ::core::option::Option<TransactionExpiration>,
}
/// Payment information for executing a transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GasPayment {
    /// Set of gas objects to use for payment.
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<ObjectReference>,
    /// Owner of the gas objects, either the transaction sender or a sponsor.
    #[prost(string, optional, tag = "2")]
    pub owner: ::core::option::Option<::prost::alloc::string::String>,
    /// Gas unit price to use when charging for computation.
    ///
    /// Must be greater than or equal to the network's current RGP (reference gas price).
    #[prost(uint64, optional, tag = "3")]
    pub price: ::core::option::Option<u64>,
    /// Total budget willing to spend for the execution of a transaction.
    #[prost(uint64, optional, tag = "4")]
    pub budget: ::core::option::Option<u64>,
}
/// A TTL for a transaction.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TransactionExpiration {
    #[prost(
        enumeration = "transaction_expiration::TransactionExpirationKind",
        optional,
        tag = "1"
    )]
    pub kind: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "2")]
    pub epoch: ::core::option::Option<u64>,
}
/// Nested message and enum types in `TransactionExpiration`.
pub mod transaction_expiration {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TransactionExpirationKind {
        Unknown = 0,
        /// The transaction has no expiration.
        None = 1,
        /// Validators won't sign and execute transaction unless the expiration epoch
        /// is greater than or equal to the current epoch.
        Epoch = 2,
    }
    impl TransactionExpirationKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "TRANSACTION_EXPIRATION_KIND_UNKNOWN",
                Self::None => "NONE",
                Self::Epoch => "EPOCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRANSACTION_EXPIRATION_KIND_UNKNOWN" => Some(Self::Unknown),
                "NONE" => Some(Self::None),
                "EPOCH" => Some(Self::Epoch),
                _ => None,
            }
        }
    }
}
/// Transaction type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionKind {
    #[prost(
        oneof = "transaction_kind::Kind",
        tags = "2, 100, 101, 102, 103, 104, 105, 106, 107, 108"
    )]
    pub kind: ::core::option::Option<transaction_kind::Kind>,
}
/// Nested message and enum types in `TransactionKind`.
pub mod transaction_kind {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// A user transaction comprised of a list of native commands and Move calls.
        #[prost(message, tag = "2")]
        ProgrammableTransaction(super::ProgrammableTransaction),
        /// System transaction used to end an epoch.
        ///
        /// The `ChangeEpoch` variant is now deprecated (but the `ChangeEpoch` struct is still used by
        /// `EndOfEpochTransaction`).
        #[prost(message, tag = "100")]
        ChangeEpoch(super::ChangeEpoch),
        /// Transaction used to initialize the chain state.
        ///
        /// Only valid if in the genesis checkpoint (0) and if this is the very first transaction ever
        /// executed on the chain.
        #[prost(message, tag = "101")]
        Genesis(super::GenesisTransaction),
        /// V1 consensus commit update.
        #[prost(message, tag = "102")]
        ConsensusCommitPrologueV1(super::ConsensusCommitPrologue),
        /// Update set of valid JWKs used for zklogin.
        #[prost(message, tag = "103")]
        AuthenticatorStateUpdate(super::AuthenticatorStateUpdate),
        /// Set of operations to run at the end of the epoch to close out the current epoch and start
        /// the next one.
        #[prost(message, tag = "104")]
        EndOfEpoch(super::EndOfEpochTransaction),
        /// Randomness update.
        #[prost(message, tag = "105")]
        RandomnessStateUpdate(super::RandomnessStateUpdate),
        /// V2 consensus commit update.
        #[prost(message, tag = "106")]
        ConsensusCommitPrologueV2(super::ConsensusCommitPrologue),
        /// V3 consensus commit update.
        #[prost(message, tag = "107")]
        ConsensusCommitPrologueV3(super::ConsensusCommitPrologue),
        /// V4 consensus commit update.
        #[prost(message, tag = "108")]
        ConsensusCommitPrologueV4(super::ConsensusCommitPrologue),
    }
}
/// A user transaction.
///
/// Contains a series of native commands and Move calls where the results of one command can be
/// used in future commands.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProgrammableTransaction {
    /// Input objects or primitive values.
    #[prost(message, repeated, tag = "1")]
    pub inputs: ::prost::alloc::vec::Vec<Input>,
    /// The commands to be executed sequentially. A failure in any command
    /// results in the failure of the entire transaction.
    #[prost(message, repeated, tag = "2")]
    pub commands: ::prost::alloc::vec::Vec<Command>,
}
/// A single command in a programmable transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Command {
    #[prost(oneof = "command::Command", tags = "1, 2, 3, 4, 5, 6, 7")]
    pub command: ::core::option::Option<command::Command>,
}
/// Nested message and enum types in `Command`.
pub mod command {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Command {
        /// A call to either an entry or a public Move function.
        #[prost(message, tag = "1")]
        MoveCall(super::MoveCall),
        /// `(Vec<forall T:key+store. T>, address)`
        /// It sends n-objects to the specified address. These objects must have store
        /// (public transfer) and either the previous owner must be an address or the object must
        /// be newly created.
        #[prost(message, tag = "2")]
        TransferObjects(super::TransferObjects),
        /// `(&mut Coin<T>, Vec<u64>)` -> `Vec<Coin<T>>`
        /// It splits off some amounts into new coins with those amounts.
        #[prost(message, tag = "3")]
        SplitCoins(super::SplitCoins),
        /// `(&mut Coin<T>, Vec<Coin<T>>)`
        /// It merges n-coins into the first coin.
        #[prost(message, tag = "4")]
        MergeCoins(super::MergeCoins),
        /// Publishes a Move package. It takes the package bytes and a list of the package's transitive
        /// dependencies to link against on chain.
        #[prost(message, tag = "5")]
        Publish(super::Publish),
        /// `forall T: Vec<T> -> vector<T>`
        /// Given n-values of the same type, it constructs a vector. For non-objects or an empty vector,
        /// the type tag must be specified.
        #[prost(message, tag = "6")]
        MakeMoveVector(super::MakeMoveVector),
        /// Upgrades a Move package.
        /// Takes (in order):
        /// 1. A vector of serialized modules for the package.
        /// 2. A vector of object ids for the transitive dependencies of the new package.
        /// 3. The object ID of the package being upgraded.
        /// 4. An argument holding the `UpgradeTicket` that must have been produced from an earlier command in the same
        ///     programmable transaction.
        #[prost(message, tag = "7")]
        Upgrade(super::Upgrade),
    }
}
/// Command to call a Move function.
///
/// Functions that can be called by a `MoveCall` command are those that have a function signature
/// that is either `entry` or `public` (which don't have a reference return type).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveCall {
    /// The package containing the module and function.
    #[prost(string, optional, tag = "1")]
    pub package: ::core::option::Option<::prost::alloc::string::String>,
    /// The specific module in the package containing the function.
    #[prost(string, optional, tag = "2")]
    pub module: ::core::option::Option<::prost::alloc::string::String>,
    /// The function to be called.
    #[prost(string, optional, tag = "3")]
    pub function: ::core::option::Option<::prost::alloc::string::String>,
    /// The type arguments to the function.
    #[prost(string, repeated, tag = "4")]
    pub type_arguments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The arguments to the function.
    #[prost(message, repeated, tag = "5")]
    pub arguments: ::prost::alloc::vec::Vec<Argument>,
}
/// Command to transfer ownership of a set of objects to an address.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferObjects {
    /// Set of objects to transfer.
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<Argument>,
    /// The address to transfer ownership to.
    #[prost(message, optional, tag = "2")]
    pub address: ::core::option::Option<Argument>,
}
/// Command to split a single coin object into multiple coins.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SplitCoins {
    /// The coin to split.
    #[prost(message, optional, tag = "1")]
    pub coin: ::core::option::Option<Argument>,
    /// The amounts to split off.
    #[prost(message, repeated, tag = "2")]
    pub amounts: ::prost::alloc::vec::Vec<Argument>,
}
/// Command to merge multiple coins of the same type into a single coin.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeCoins {
    /// Coin to merge coins into.
    #[prost(message, optional, tag = "1")]
    pub coin: ::core::option::Option<Argument>,
    /// Set of coins to merge into `coin`.
    ///
    /// All listed coins must be of the same type and be the same type as `coin`
    #[prost(message, repeated, tag = "2")]
    pub coins_to_merge: ::prost::alloc::vec::Vec<Argument>,
}
/// Command to publish a new Move package.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Publish {
    /// The serialized Move modules.
    #[prost(bytes = "bytes", repeated, tag = "1")]
    pub modules: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    /// Set of packages that the to-be published package depends on.
    #[prost(string, repeated, tag = "2")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Command to build a Move vector out of a set of individual elements.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MakeMoveVector {
    /// Type of the individual elements.
    ///
    /// This is required to be set when the type can't be inferred, for example when the set of
    /// provided arguments are all pure input values.
    #[prost(string, optional, tag = "1")]
    pub element_type: ::core::option::Option<::prost::alloc::string::String>,
    /// The set individual elements to build the vector with.
    #[prost(message, repeated, tag = "2")]
    pub elements: ::prost::alloc::vec::Vec<Argument>,
}
/// Command to upgrade an already published package.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Upgrade {
    /// The serialized Move modules.
    #[prost(bytes = "bytes", repeated, tag = "1")]
    pub modules: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    /// Set of packages that the to-be published package depends on.
    #[prost(string, repeated, tag = "2")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Package ID of the package to upgrade.
    #[prost(string, optional, tag = "3")]
    pub package: ::core::option::Option<::prost::alloc::string::String>,
    /// Ticket authorizing the upgrade.
    #[prost(message, optional, tag = "4")]
    pub ticket: ::core::option::Option<Argument>,
}
/// Randomness update.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RandomnessStateUpdate {
    /// Epoch of the randomness state update transaction.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// Randomness round of the update.
    #[prost(uint64, optional, tag = "2")]
    pub randomness_round: ::core::option::Option<u64>,
    /// Updated random bytes.
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub random_bytes: ::core::option::Option<::prost::bytes::Bytes>,
    /// The initial version of the randomness object that it was shared at.
    #[prost(uint64, optional, tag = "4")]
    pub randomness_object_initial_shared_version: ::core::option::Option<u64>,
}
/// System transaction used to change the epoch.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeEpoch {
    /// The next (to become) epoch ID.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// The protocol version in effect in the new epoch.
    #[prost(uint64, optional, tag = "2")]
    pub protocol_version: ::core::option::Option<u64>,
    /// The total amount of gas charged for storage during the epoch.
    #[prost(uint64, optional, tag = "3")]
    pub storage_charge: ::core::option::Option<u64>,
    /// The total amount of gas charged for computation during the epoch.
    #[prost(uint64, optional, tag = "4")]
    pub computation_charge: ::core::option::Option<u64>,
    /// The amount of storage rebate refunded to the txn senders.
    #[prost(uint64, optional, tag = "5")]
    pub storage_rebate: ::core::option::Option<u64>,
    /// The non-refundable storage fee.
    #[prost(uint64, optional, tag = "6")]
    pub non_refundable_storage_fee: ::core::option::Option<u64>,
    /// Unix timestamp when epoch started.
    #[prost(message, optional, tag = "7")]
    pub epoch_start_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// System packages (specifically framework and Move stdlib) that are written before the new
    /// epoch starts. This tracks framework upgrades on chain. When executing the `ChangeEpoch` txn,
    /// the validator must write out the following modules.  Modules are provided with the version they
    /// will be upgraded to, their modules in serialized form (which include their package ID), and
    /// a list of their transitive dependencies.
    #[prost(message, repeated, tag = "8")]
    pub system_packages: ::prost::alloc::vec::Vec<SystemPackage>,
}
/// System package.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemPackage {
    /// Version of the package.
    #[prost(uint64, optional, tag = "1")]
    pub version: ::core::option::Option<u64>,
    /// Move modules.
    #[prost(bytes = "bytes", repeated, tag = "2")]
    pub modules: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    /// Package dependencies.
    #[prost(string, repeated, tag = "3")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The genesis transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisTransaction {
    /// Set of genesis objects.
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<Object>,
}
/// Consensus commit prologue system transaction.
///
/// This message can represent V1, V2, and V3 prologue types.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusCommitPrologue {
    /// Epoch of the commit prologue transaction.
    ///
    /// Present in V1, V2, V3, V4.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// Consensus round of the commit.
    ///
    /// Present in V1, V2, V3, V4.
    #[prost(uint64, optional, tag = "2")]
    pub round: ::core::option::Option<u64>,
    /// Unix timestamp from consensus.
    ///
    /// Present in V1, V2, V3, V4.
    #[prost(message, optional, tag = "3")]
    pub commit_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Digest of consensus output.
    ///
    /// Present in V2, V3, V4.
    #[prost(string, optional, tag = "4")]
    pub consensus_commit_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The sub DAG index of the consensus commit. This field is populated if there
    /// are multiple consensus commits per round.
    ///
    /// Present in V3, V4.
    #[prost(uint64, optional, tag = "5")]
    pub sub_dag_index: ::core::option::Option<u64>,
    /// Stores consensus handler determined shared object version assignments.
    ///
    /// Present in V3, V4.
    #[prost(message, optional, tag = "6")]
    pub consensus_determined_version_assignments: ::core::option::Option<
        ConsensusDeterminedVersionAssignments,
    >,
    /// Digest of any additional state computed by the consensus handler.
    /// Used to detect forking bugs as early as possible.
    ///
    /// Present in V4.
    #[prost(string, optional, tag = "7")]
    pub additional_state_digest: ::core::option::Option<::prost::alloc::string::String>,
}
/// Object version assignment from consensus.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VersionAssignment {
    /// `ObjectId` of the object.
    #[prost(string, optional, tag = "1")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// start version of the consensus stream for this object
    #[prost(uint64, optional, tag = "2")]
    pub start_version: ::core::option::Option<u64>,
    /// Assigned version.
    #[prost(uint64, optional, tag = "3")]
    pub version: ::core::option::Option<u64>,
}
/// A transaction that was canceled.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CanceledTransaction {
    /// Digest of the canceled transaction.
    #[prost(string, optional, tag = "1")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// List of object version assignments.
    #[prost(message, repeated, tag = "2")]
    pub version_assignments: ::prost::alloc::vec::Vec<VersionAssignment>,
}
/// Version assignments performed by consensus.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusDeterminedVersionAssignments {
    /// Version of this message
    #[prost(int32, optional, tag = "1")]
    pub version: ::core::option::Option<i32>,
    /// Canceled transaction version assignment.
    #[prost(message, repeated, tag = "3")]
    pub canceled_transactions: ::prost::alloc::vec::Vec<CanceledTransaction>,
}
/// Update the set of valid JWKs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticatorStateUpdate {
    /// Epoch of the authenticator state update transaction.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// Consensus round of the authenticator state update.
    #[prost(uint64, optional, tag = "2")]
    pub round: ::core::option::Option<u64>,
    /// Newly active JWKs.
    #[prost(message, repeated, tag = "3")]
    pub new_active_jwks: ::prost::alloc::vec::Vec<ActiveJwk>,
    /// The initial version of the authenticator object that it was shared at.
    #[prost(uint64, optional, tag = "4")]
    pub authenticator_object_initial_shared_version: ::core::option::Option<u64>,
}
/// A new JWK.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActiveJwk {
    /// Identifier used to uniquely identify a JWK.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<JwkId>,
    /// The JWK.
    #[prost(message, optional, tag = "2")]
    pub jwk: ::core::option::Option<Jwk>,
    /// Most recent epoch in which the JWK was validated.
    #[prost(uint64, optional, tag = "3")]
    pub epoch: ::core::option::Option<u64>,
}
/// Key to uniquely identify a JWK.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JwkId {
    /// The issuer or identity of the OIDC provider.
    #[prost(string, optional, tag = "1")]
    pub iss: ::core::option::Option<::prost::alloc::string::String>,
    /// A key ID used to uniquely identify a key from an OIDC provider.
    #[prost(string, optional, tag = "2")]
    pub kid: ::core::option::Option<::prost::alloc::string::String>,
}
/// A JSON web key.
///
/// Struct that contains info for a JWK. A list of them for different kinds can
/// be retrieved from the JWK endpoint (for example, <<https://www.googleapis.com/oauth2/v3/certs>>).
/// The JWK is used to verify the JWT token.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Jwk {
    /// Key type parameter, <https://datatracker.ietf.org/doc/html/rfc7517#section-4.1.>
    #[prost(string, optional, tag = "1")]
    pub kty: ::core::option::Option<::prost::alloc::string::String>,
    /// RSA public exponent, <https://datatracker.ietf.org/doc/html/rfc7517#section-9.3.>
    #[prost(string, optional, tag = "2")]
    pub e: ::core::option::Option<::prost::alloc::string::String>,
    /// RSA modulus, <https://datatracker.ietf.org/doc/html/rfc7517#section-9.3.>
    #[prost(string, optional, tag = "3")]
    pub n: ::core::option::Option<::prost::alloc::string::String>,
    /// Algorithm parameter, <https://datatracker.ietf.org/doc/html/rfc7517#section-4.4.>
    #[prost(string, optional, tag = "4")]
    pub alg: ::core::option::Option<::prost::alloc::string::String>,
}
/// Set of operations run at the end of the epoch to close out the current epoch
/// and start the next one.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndOfEpochTransaction {
    #[prost(message, repeated, tag = "1")]
    pub transactions: ::prost::alloc::vec::Vec<EndOfEpochTransactionKind>,
}
/// Operation run at the end of an epoch.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndOfEpochTransactionKind {
    #[prost(
        oneof = "end_of_epoch_transaction_kind::Kind",
        tags = "2, 3, 4, 200, 201, 202, 203, 204, 205"
    )]
    pub kind: ::core::option::Option<end_of_epoch_transaction_kind::Kind>,
}
/// Nested message and enum types in `EndOfEpochTransactionKind`.
pub mod end_of_epoch_transaction_kind {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// End the epoch and start the next one.
        #[prost(message, tag = "2")]
        ChangeEpoch(super::ChangeEpoch),
        /// Expire JWKs used for zklogin.
        #[prost(message, tag = "3")]
        AuthenticatorStateExpire(super::AuthenticatorStateExpire),
        /// Execution time observations from the committee to preserve cross epoch
        #[prost(message, tag = "4")]
        ExecutionTimeObservations(super::ExecutionTimeObservations),
        /// Create and initialize the authenticator object used for zklogin.
        #[prost(message, tag = "200")]
        AuthenticatorStateCreate(()),
        /// Create and initialize the randomness object.
        #[prost(message, tag = "201")]
        RandomnessStateCreate(()),
        /// Create and initialize the deny list object.
        #[prost(message, tag = "202")]
        DenyListStateCreate(()),
        /// Create and initialize the bridge object.
        #[prost(string, tag = "203")]
        BridgeStateCreate(::prost::alloc::string::String),
        /// Initialize the bridge committee.
        #[prost(uint64, tag = "204")]
        BridgeCommitteeInit(u64),
        /// Create the accumulator root object.
        #[prost(message, tag = "205")]
        AccumulatorRootCreate(()),
    }
}
/// Expire old JWKs.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AuthenticatorStateExpire {
    /// Expire JWKs that have a lower epoch than this.
    #[prost(uint64, optional, tag = "1")]
    pub min_epoch: ::core::option::Option<u64>,
    /// The initial version of the authenticator object that it was shared at.
    #[prost(uint64, optional, tag = "2")]
    pub authenticator_object_initial_shared_version: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionTimeObservations {
    /// Version of this ExecutionTimeObservations
    #[prost(int32, optional, tag = "1")]
    pub version: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "2")]
    pub observations: ::prost::alloc::vec::Vec<ExecutionTimeObservation>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionTimeObservation {
    #[prost(
        enumeration = "execution_time_observation::ExecutionTimeObservationKind",
        optional,
        tag = "1"
    )]
    pub kind: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub move_entry_point: ::core::option::Option<MoveCall>,
    #[prost(message, repeated, tag = "3")]
    pub validator_observations: ::prost::alloc::vec::Vec<
        ValidatorExecutionTimeObservation,
    >,
}
/// Nested message and enum types in `ExecutionTimeObservation`.
pub mod execution_time_observation {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExecutionTimeObservationKind {
        Unknown = 0,
        MoveEntryPoint = 1,
        TransferObjects = 2,
        SplitCoins = 3,
        MergeCoins = 4,
        Publish = 5,
        MakeMoveVector = 6,
        Upgrade = 7,
    }
    impl ExecutionTimeObservationKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "EXECUTION_TIME_OBSERVATION_KIND_UNKNOWN",
                Self::MoveEntryPoint => "MOVE_ENTRY_POINT",
                Self::TransferObjects => "TRANSFER_OBJECTS",
                Self::SplitCoins => "SPLIT_COINS",
                Self::MergeCoins => "MERGE_COINS",
                Self::Publish => "PUBLISH",
                Self::MakeMoveVector => "MAKE_MOVE_VECTOR",
                Self::Upgrade => "UPGRADE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXECUTION_TIME_OBSERVATION_KIND_UNKNOWN" => Some(Self::Unknown),
                "MOVE_ENTRY_POINT" => Some(Self::MoveEntryPoint),
                "TRANSFER_OBJECTS" => Some(Self::TransferObjects),
                "SPLIT_COINS" => Some(Self::SplitCoins),
                "MERGE_COINS" => Some(Self::MergeCoins),
                "PUBLISH" => Some(Self::Publish),
                "MAKE_MOVE_VECTOR" => Some(Self::MakeMoveVector),
                "UPGRADE" => Some(Self::Upgrade),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorExecutionTimeObservation {
    /// Bls12381 public key of the validator
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub validator: ::core::option::Option<::prost::bytes::Bytes>,
    /// Duration of an execution observation
    #[prost(message, optional, tag = "2")]
    pub duration: ::core::option::Option<::prost_types::Duration>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteTransactionRequest {
    /// The transaction to execute.
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<Transaction>,
    /// Set of `UserSiganture`s authorizing the execution of the provided
    /// transaction.
    #[prost(message, repeated, tag = "2")]
    pub signatures: ::prost::alloc::vec::Vec<UserSignature>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `finality`.
    #[prost(message, optional, tag = "3")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Response message for `NodeService.ExecuteTransaction`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteTransactionResponse {
    /// Indicates the finality of the executed transaction.
    #[prost(message, optional, tag = "1")]
    pub finality: ::core::option::Option<TransactionFinality>,
    #[prost(message, optional, tag = "2")]
    pub transaction: ::core::option::Option<ExecutedTransaction>,
}
/// Indicates the finality of the executed transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionFinality {
    #[prost(oneof = "transaction_finality::Finality", tags = "1, 2, 3")]
    pub finality: ::core::option::Option<transaction_finality::Finality>,
}
/// Nested message and enum types in `TransactionFinality`.
pub mod transaction_finality {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Finality {
        /// A quorum certificate certifying that a transaction is final but might not
        /// be included in a checkpoint yet.
        #[prost(message, tag = "1")]
        Certified(super::ValidatorAggregatedSignature),
        /// Sequence number of the checkpoint that includes the transaction.
        #[prost(uint64, tag = "2")]
        Checkpointed(u64),
        /// Indicates that a quorum of validators has executed the transaction but
        /// that it might not be included in a checkpoint yet.
        #[prost(message, tag = "3")]
        QuorumExecuted(()),
    }
}
/// Generated client implementations.
pub mod transaction_execution_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct TransactionExecutionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl TransactionExecutionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> TransactionExecutionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TransactionExecutionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            TransactionExecutionServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn execute_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::ExecuteTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExecuteTransactionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sui.rpc.v2beta2.TransactionExecutionService/ExecuteTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "sui.rpc.v2beta2.TransactionExecutionService",
                        "ExecuteTransaction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod transaction_execution_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with TransactionExecutionServiceServer.
    #[async_trait]
    pub trait TransactionExecutionService: std::marker::Send + std::marker::Sync + 'static {
        async fn execute_transaction(
            &self,
            request: tonic::Request<super::ExecuteTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExecuteTransactionResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct TransactionExecutionServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> TransactionExecutionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for TransactionExecutionServiceServer<T>
    where
        T: TransactionExecutionService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/sui.rpc.v2beta2.TransactionExecutionService/ExecuteTransaction" => {
                    #[allow(non_camel_case_types)]
                    struct ExecuteTransactionSvc<T: TransactionExecutionService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: TransactionExecutionService,
                    > tonic::server::UnaryService<super::ExecuteTransactionRequest>
                    for ExecuteTransactionSvc<T> {
                        type Response = super::ExecuteTransactionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExecuteTransactionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TransactionExecutionService>::execute_transaction(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ExecuteTransactionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for TransactionExecutionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "sui.rpc.v2beta2.TransactionExecutionService";
    impl<T> tonic::server::NamedService for TransactionExecutionServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
