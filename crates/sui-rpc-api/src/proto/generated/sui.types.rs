// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Address {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectId {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub object_id: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Digest {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub digest: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bcs {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub bcs: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Little-endian encoded u128
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct U128 {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub bytes: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Little-endian encoded i128
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct I128 {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub bytes: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Little-endian encoded u256
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct U256 {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub bytes: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointSummary {
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub sequence_number: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub total_network_transactions: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "4")]
    pub content_digest: ::core::option::Option<Digest>,
    #[prost(message, optional, tag = "5")]
    pub previous_digest: ::core::option::Option<Digest>,
    #[prost(message, optional, tag = "6")]
    pub epoch_rolling_gas_cost_summary: ::core::option::Option<GasCostSummary>,
    #[prost(uint64, optional, tag = "7")]
    pub timestamp_ms: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "8")]
    pub commitments: ::prost::alloc::vec::Vec<CheckpointCommitment>,
    #[prost(message, optional, tag = "9")]
    pub end_of_epoch_data: ::core::option::Option<EndOfEpochData>,
    #[prost(bytes = "bytes", optional, tag = "10")]
    pub version_specific_data: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointCommitment {
    #[prost(oneof = "checkpoint_commitment::Commitment", tags = "1")]
    pub commitment: ::core::option::Option<checkpoint_commitment::Commitment>,
}
/// Nested message and enum types in `CheckpointCommitment`.
pub mod checkpoint_commitment {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Commitment {
        #[prost(message, tag = "1")]
        EcmhLiveObjectSet(super::Digest),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndOfEpochData {
    #[prost(message, repeated, tag = "1")]
    pub next_epoch_committee: ::prost::alloc::vec::Vec<ValidatorCommitteeMember>,
    #[prost(uint64, optional, tag = "2")]
    pub next_epoch_protocol_version: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "3")]
    pub epoch_commitments: ::prost::alloc::vec::Vec<CheckpointCommitment>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointedTransactionInfo {
    /// TransactionDigest
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<Digest>,
    /// EffectsDigest
    #[prost(message, optional, tag = "2")]
    pub effects: ::core::option::Option<Digest>,
    #[prost(message, repeated, tag = "3")]
    pub signatures: ::prost::alloc::vec::Vec<UserSignature>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointContents {
    #[prost(oneof = "checkpoint_contents::Contents", tags = "1")]
    pub contents: ::core::option::Option<checkpoint_contents::Contents>,
}
/// Nested message and enum types in `CheckpointContents`.
pub mod checkpoint_contents {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct V1 {
        #[prost(message, repeated, tag = "1")]
        pub transactions: ::prost::alloc::vec::Vec<super::CheckpointedTransactionInfo>,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Contents {
        #[prost(message, tag = "1")]
        V1(V1),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionEvents {
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<Event>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    #[prost(message, optional, tag = "1")]
    pub package_id: ::core::option::Option<ObjectId>,
    #[prost(message, optional, tag = "2")]
    pub module: ::core::option::Option<Identifier>,
    #[prost(message, optional, tag = "3")]
    pub sender: ::core::option::Option<Address>,
    #[prost(message, optional, tag = "4")]
    pub event_type: ::core::option::Option<StructTag>,
    #[prost(bytes = "bytes", optional, tag = "5")]
    pub contents: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectReference {
    #[prost(message, optional, tag = "1")]
    pub object_id: ::core::option::Option<ObjectId>,
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "3")]
    pub digest: ::core::option::Option<Digest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MovePackage {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "3")]
    pub modules: ::prost::alloc::vec::Vec<MoveModule>,
    #[prost(message, repeated, tag = "4")]
    pub type_origin_table: ::prost::alloc::vec::Vec<TypeOrigin>,
    #[prost(message, repeated, tag = "5")]
    pub linkage_table: ::prost::alloc::vec::Vec<UpgradeInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveModule {
    #[prost(message, optional, tag = "1")]
    pub name: ::core::option::Option<Identifier>,
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub contents: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypeOrigin {
    #[prost(message, optional, tag = "1")]
    pub module_name: ::core::option::Option<Identifier>,
    #[prost(message, optional, tag = "2")]
    pub struct_name: ::core::option::Option<Identifier>,
    #[prost(message, optional, tag = "3")]
    pub package_id: ::core::option::Option<ObjectId>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpgradeInfo {
    #[prost(message, optional, tag = "1")]
    pub original_id: ::core::option::Option<ObjectId>,
    #[prost(message, optional, tag = "2")]
    pub upgraded_id: ::core::option::Option<ObjectId>,
    #[prost(uint64, optional, tag = "3")]
    pub upgraded_version: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Owner {
    #[prost(oneof = "owner::Kind", tags = "1, 2, 3, 4")]
    pub kind: ::core::option::Option<owner::Kind>,
}
/// Nested message and enum types in `Owner`.
pub mod owner {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        Address(super::Address),
        #[prost(message, tag = "2")]
        Object(super::ObjectId),
        #[prost(uint64, tag = "3")]
        Shared(u64),
        #[prost(message, tag = "4")]
        Immutable(()),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveStruct {
    #[prost(message, optional, tag = "1")]
    pub object_id: ::core::option::Option<ObjectId>,
    #[prost(message, optional, tag = "2")]
    pub object_type: ::core::option::Option<StructTag>,
    #[prost(bool, optional, tag = "3")]
    pub has_public_transfer: ::core::option::Option<bool>,
    #[prost(uint64, optional, tag = "4")]
    pub version: ::core::option::Option<u64>,
    #[prost(bytes = "bytes", optional, tag = "5")]
    pub contents: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Object {
    #[prost(message, optional, tag = "1")]
    pub object_id: ::core::option::Option<ObjectId>,
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "3")]
    pub owner: ::core::option::Option<Owner>,
    #[prost(message, optional, tag = "4")]
    pub object: ::core::option::Option<ObjectData>,
    #[prost(message, optional, tag = "5")]
    pub previous_transaction: ::core::option::Option<Digest>,
    #[prost(uint64, optional, tag = "6")]
    pub storage_rebate: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectData {
    #[prost(oneof = "object_data::Kind", tags = "1, 2")]
    pub kind: ::core::option::Option<object_data::Kind>,
}
/// Nested message and enum types in `ObjectData`.
pub mod object_data {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        Struct(super::MoveStruct),
        #[prost(message, tag = "2")]
        Package(super::MovePackage),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisObject {
    #[prost(message, optional, tag = "1")]
    pub object_id: ::core::option::Option<ObjectId>,
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "3")]
    pub owner: ::core::option::Option<Owner>,
    #[prost(message, optional, tag = "4")]
    pub object: ::core::option::Option<ObjectData>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GasCostSummary {
    #[prost(uint64, optional, tag = "1")]
    pub computation_cost: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub storage_cost: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub storage_rebate: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub non_refundable_storage_fee: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Identifier {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub identifier: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StructTag {
    #[prost(message, optional, tag = "1")]
    pub address: ::core::option::Option<Address>,
    #[prost(message, optional, tag = "2")]
    pub module: ::core::option::Option<Identifier>,
    #[prost(message, optional, tag = "3")]
    pub name: ::core::option::Option<Identifier>,
    #[prost(message, repeated, tag = "4")]
    pub type_parameters: ::prost::alloc::vec::Vec<TypeTag>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypeTag {
    #[prost(oneof = "type_tag::Tag", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11")]
    pub tag: ::core::option::Option<type_tag::Tag>,
}
/// Nested message and enum types in `TypeTag`.
pub mod type_tag {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Tag {
        #[prost(message, tag = "1")]
        U8(()),
        #[prost(message, tag = "2")]
        U16(()),
        #[prost(message, tag = "3")]
        U32(()),
        #[prost(message, tag = "4")]
        U64(()),
        #[prost(message, tag = "5")]
        U128(()),
        #[prost(message, tag = "6")]
        U256(()),
        #[prost(message, tag = "7")]
        Bool(()),
        #[prost(message, tag = "8")]
        Address(()),
        #[prost(message, tag = "9")]
        Signer(()),
        #[prost(message, tag = "10")]
        Vector(::prost::alloc::boxed::Box<super::TypeTag>),
        #[prost(message, tag = "11")]
        Struct(super::StructTag),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveStructValue {
    #[prost(message, optional, tag = "1")]
    pub struct_type: ::core::option::Option<StructTag>,
    #[prost(message, repeated, tag = "2")]
    pub fields: ::prost::alloc::vec::Vec<MoveField>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveField {
    #[prost(message, optional, tag = "1")]
    pub name: ::core::option::Option<Identifier>,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<MoveValue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveVariant {
    #[prost(message, optional, tag = "1")]
    pub enum_type: ::core::option::Option<StructTag>,
    #[prost(message, optional, tag = "2")]
    pub variant_name: ::core::option::Option<Identifier>,
    #[prost(uint32, optional, tag = "3")]
    pub tag: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "4")]
    pub fields: ::prost::alloc::vec::Vec<MoveField>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveValue {
    #[prost(oneof = "move_value::Kind", tags = "2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13")]
    pub kind: ::core::option::Option<move_value::Kind>,
}
/// Nested message and enum types in `MoveValue`.
pub mod move_value {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(bool, tag = "2")]
        Bool(bool),
        #[prost(uint32, tag = "3")]
        U8(u32),
        #[prost(uint32, tag = "4")]
        U16(u32),
        #[prost(uint32, tag = "5")]
        U32(u32),
        #[prost(uint64, tag = "6")]
        U64(u64),
        #[prost(message, tag = "7")]
        U128(super::U128),
        #[prost(message, tag = "8")]
        U256(super::U256),
        #[prost(message, tag = "9")]
        Address(super::Address),
        #[prost(message, tag = "10")]
        Vector(super::MoveVector),
        #[prost(message, tag = "11")]
        Struct(super::MoveStructValue),
        #[prost(message, tag = "12")]
        Signer(super::Address),
        #[prost(message, tag = "13")]
        Variant(super::MoveVariant),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveVector {
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<MoveValue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
    #[prost(oneof = "transaction::Version", tags = "1")]
    pub version: ::core::option::Option<transaction::Version>,
}
/// Nested message and enum types in `Transaction`.
pub mod transaction {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TransactionV1 {
        #[prost(message, optional, tag = "1")]
        pub kind: ::core::option::Option<super::TransactionKind>,
        #[prost(message, optional, tag = "2")]
        pub sender: ::core::option::Option<super::Address>,
        #[prost(message, optional, tag = "3")]
        pub gas_payment: ::core::option::Option<super::GasPayment>,
        #[prost(message, optional, tag = "4")]
        pub expiration: ::core::option::Option<super::TransactionExpiration>,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(TransactionV1),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GasPayment {
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<ObjectReference>,
    #[prost(message, optional, tag = "2")]
    pub owner: ::core::option::Option<Address>,
    #[prost(uint64, optional, tag = "3")]
    pub price: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub budget: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TransactionExpiration {
    #[prost(oneof = "transaction_expiration::Expiration", tags = "1, 2")]
    pub expiration: ::core::option::Option<transaction_expiration::Expiration>,
}
/// Nested message and enum types in `TransactionExpiration`.
pub mod transaction_expiration {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Expiration {
        #[prost(message, tag = "1")]
        None(()),
        #[prost(uint64, tag = "2")]
        Epoch(u64),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RandomnessStateUpdate {
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub randomness_round: ::core::option::Option<u64>,
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub random_bytes: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(uint64, optional, tag = "4")]
    pub randomness_object_initial_shared_version: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionKind {
    #[prost(oneof = "transaction_kind::Kind", tags = "1, 2, 200, 201, 3, 4, 5, 202, 6")]
    pub kind: ::core::option::Option<transaction_kind::Kind>,
}
/// Nested message and enum types in `TransactionKind`.
pub mod transaction_kind {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        ProgrammableTransaction(super::ProgrammableTransaction),
        #[prost(message, tag = "2")]
        ChangeEpoch(super::ChangeEpoch),
        #[prost(message, tag = "200")]
        Genesis(super::GenesisTransaction),
        #[prost(message, tag = "201")]
        ConsensusCommitPrologueV1(super::ConsensusCommitPrologue),
        #[prost(message, tag = "3")]
        AuthenticatorStateUpdate(super::AuthenticatorStateUpdate),
        #[prost(message, tag = "4")]
        EndOfEpoch(super::EndOfEpochTransaction),
        #[prost(message, tag = "5")]
        RandomnessStateUpdate(super::RandomnessStateUpdate),
        #[prost(message, tag = "202")]
        ConsensusCommitPrologueV2(super::ConsensusCommitPrologue),
        #[prost(message, tag = "6")]
        ConsensusCommitPrologueV3(super::ConsensusCommitPrologue),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProgrammableTransaction {
    #[prost(message, repeated, tag = "1")]
    pub inputs: ::prost::alloc::vec::Vec<Input>,
    #[prost(message, repeated, tag = "2")]
    pub commands: ::prost::alloc::vec::Vec<Command>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Input {
    #[prost(oneof = "input::Kind", tags = "1, 2, 3, 4")]
    pub kind: ::core::option::Option<input::Kind>,
}
/// Nested message and enum types in `Input`.
pub mod input {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(bytes, tag = "1")]
        Pure(::prost::bytes::Bytes),
        #[prost(message, tag = "2")]
        ImmutableOrOwned(super::ObjectReference),
        #[prost(message, tag = "3")]
        Shared(super::SharedObjectInput),
        #[prost(message, tag = "4")]
        Receiving(super::ObjectReference),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SharedObjectInput {
    #[prost(message, optional, tag = "1")]
    pub object_id: ::core::option::Option<ObjectId>,
    #[prost(uint64, optional, tag = "2")]
    pub initial_shared_version: ::core::option::Option<u64>,
    #[prost(bool, optional, tag = "3")]
    pub mutable: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Command {
    #[prost(oneof = "command::Command", tags = "1, 2, 3, 4, 5, 6, 7")]
    pub command: ::core::option::Option<command::Command>,
}
/// Nested message and enum types in `Command`.
pub mod command {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Command {
        #[prost(message, tag = "1")]
        MoveCall(super::MoveCall),
        #[prost(message, tag = "2")]
        TransferObjects(super::TransferObjects),
        #[prost(message, tag = "3")]
        SplitCoins(super::SplitCoins),
        #[prost(message, tag = "4")]
        MergeCoins(super::MergeCoins),
        #[prost(message, tag = "5")]
        Publish(super::Publish),
        #[prost(message, tag = "6")]
        MakeMoveVector(super::MakeMoveVector),
        #[prost(message, tag = "7")]
        Upgrade(super::Upgrade),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveCall {
    #[prost(message, optional, tag = "1")]
    pub package: ::core::option::Option<ObjectId>,
    #[prost(message, optional, tag = "2")]
    pub module: ::core::option::Option<Identifier>,
    #[prost(message, optional, tag = "3")]
    pub function: ::core::option::Option<Identifier>,
    #[prost(message, repeated, tag = "4")]
    pub type_arguments: ::prost::alloc::vec::Vec<TypeTag>,
    #[prost(message, repeated, tag = "5")]
    pub arguments: ::prost::alloc::vec::Vec<Argument>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferObjects {
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<Argument>,
    #[prost(message, optional, tag = "2")]
    pub address: ::core::option::Option<Argument>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SplitCoins {
    #[prost(message, optional, tag = "1")]
    pub coin: ::core::option::Option<Argument>,
    #[prost(message, repeated, tag = "2")]
    pub amounts: ::prost::alloc::vec::Vec<Argument>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeCoins {
    #[prost(message, optional, tag = "1")]
    pub coin: ::core::option::Option<Argument>,
    #[prost(message, repeated, tag = "2")]
    pub coins_to_merge: ::prost::alloc::vec::Vec<Argument>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Publish {
    #[prost(bytes = "bytes", repeated, tag = "1")]
    pub modules: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    #[prost(message, repeated, tag = "2")]
    pub dependencies: ::prost::alloc::vec::Vec<ObjectId>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MakeMoveVector {
    #[prost(message, optional, tag = "1")]
    pub element_type: ::core::option::Option<TypeTag>,
    #[prost(message, repeated, tag = "2")]
    pub elements: ::prost::alloc::vec::Vec<Argument>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Upgrade {
    #[prost(bytes = "bytes", repeated, tag = "1")]
    pub modules: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    #[prost(message, repeated, tag = "2")]
    pub dependencies: ::prost::alloc::vec::Vec<ObjectId>,
    #[prost(message, optional, tag = "3")]
    pub package: ::core::option::Option<ObjectId>,
    #[prost(message, optional, tag = "4")]
    pub ticket: ::core::option::Option<Argument>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Argument {
    #[prost(oneof = "argument::Kind", tags = "1, 2, 3, 4")]
    pub kind: ::core::option::Option<argument::Kind>,
}
/// Nested message and enum types in `Argument`.
pub mod argument {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        Gas(()),
        #[prost(uint32, tag = "2")]
        Input(u32),
        #[prost(uint32, tag = "3")]
        Result(u32),
        #[prost(message, tag = "4")]
        NestedResult(super::NestedResult),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NestedResult {
    #[prost(uint32, optional, tag = "1")]
    pub result: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub subresult: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeEpoch {
    /// The next (to become) epoch ID.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// The protocol version in effect in the new epoch.
    #[prost(uint64, optional, tag = "2")]
    pub protocol_version: ::core::option::Option<u64>,
    /// The total amount of gas charged for storage during the epoch.
    #[prost(uint64, optional, tag = "3")]
    pub storage_charge: ::core::option::Option<u64>,
    /// The total amount of gas charged for computation during the epoch.
    #[prost(uint64, optional, tag = "4")]
    pub computation_charge: ::core::option::Option<u64>,
    /// The amount of storage rebate refunded to the txn senders.
    #[prost(uint64, optional, tag = "5")]
    pub storage_rebate: ::core::option::Option<u64>,
    /// The non-refundable storage fee.
    #[prost(uint64, optional, tag = "6")]
    pub non_refundable_storage_fee: ::core::option::Option<u64>,
    /// Unix timestamp when epoch started
    #[prost(uint64, optional, tag = "7")]
    pub epoch_start_timestamp_ms: ::core::option::Option<u64>,
    /// System packages (specifically framework and move stdlib) that are written before the new
    /// epoch starts. This tracks framework upgrades on chain. When executing the ChangeEpoch txn,
    /// the validator must write out the modules below.  Modules are provided with the version they
    /// will be upgraded to, their modules in serialized form (which include their package ID), and
    /// a list of their transitive dependencies.
    #[prost(message, repeated, tag = "8")]
    pub system_packages: ::prost::alloc::vec::Vec<SystemPackage>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemPackage {
    #[prost(uint64, optional, tag = "1")]
    pub version: ::core::option::Option<u64>,
    #[prost(bytes = "bytes", repeated, tag = "2")]
    pub modules: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    #[prost(message, repeated, tag = "3")]
    pub dependencies: ::prost::alloc::vec::Vec<ObjectId>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisTransaction {
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<GenesisObject>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusCommitPrologue {
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub round: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub commit_timestamp_ms: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "4")]
    pub consensus_commit_digest: ::core::option::Option<Digest>,
    #[prost(uint64, optional, tag = "5")]
    pub sub_dag_index: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "6")]
    pub consensus_determined_version_assignments: ::core::option::Option<
        ConsensusDeterminedVersionAssignments,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VersionAssignment {
    #[prost(message, optional, tag = "1")]
    pub object_id: ::core::option::Option<ObjectId>,
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelledTransaction {
    #[prost(message, optional, tag = "1")]
    pub digest: ::core::option::Option<Digest>,
    #[prost(message, repeated, tag = "2")]
    pub version_assignments: ::prost::alloc::vec::Vec<VersionAssignment>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelledTransactions {
    #[prost(message, repeated, tag = "1")]
    pub cancelled_transactions: ::prost::alloc::vec::Vec<CancelledTransaction>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusDeterminedVersionAssignments {
    #[prost(oneof = "consensus_determined_version_assignments::Kind", tags = "1")]
    pub kind: ::core::option::Option<consensus_determined_version_assignments::Kind>,
}
/// Nested message and enum types in `ConsensusDeterminedVersionAssignments`.
pub mod consensus_determined_version_assignments {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        CancelledTransactions(super::CancelledTransactions),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticatorStateUpdate {
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub round: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "3")]
    pub new_active_jwks: ::prost::alloc::vec::Vec<ActiveJwk>,
    #[prost(uint64, optional, tag = "4")]
    pub authenticator_object_initial_shared_version: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActiveJwk {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<JwkId>,
    #[prost(message, optional, tag = "2")]
    pub jwk: ::core::option::Option<Jwk>,
    #[prost(uint64, optional, tag = "3")]
    pub epoch: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JwkId {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub iss: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub kid: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Jwk {
    /// Key type parameter, <<https://datatracker.ietf.org/doc/html/rfc7517#section-4.1>>
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub kty: ::core::option::Option<::prost::bytes::Bytes>,
    /// RSA public exponent, <<https://datatracker.ietf.org/doc/html/rfc7517#section-9.3>>
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub e: ::core::option::Option<::prost::bytes::Bytes>,
    /// RSA modulus, <<https://datatracker.ietf.org/doc/html/rfc7517#section-9.3>>
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub n: ::core::option::Option<::prost::bytes::Bytes>,
    /// Algorithm parameter, <<https://datatracker.ietf.org/doc/html/rfc7517#section-4.4>>
    #[prost(bytes = "bytes", optional, tag = "4")]
    pub alg: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndOfEpochTransaction {
    #[prost(message, repeated, tag = "1")]
    pub transactions: ::prost::alloc::vec::Vec<EndOfEpochTransactionKind>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndOfEpochTransactionKind {
    #[prost(
        oneof = "end_of_epoch_transaction_kind::Kind",
        tags = "1, 2, 200, 201, 202, 203, 204"
    )]
    pub kind: ::core::option::Option<end_of_epoch_transaction_kind::Kind>,
}
/// Nested message and enum types in `EndOfEpochTransactionKind`.
pub mod end_of_epoch_transaction_kind {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        ChangeEpoch(super::ChangeEpoch),
        #[prost(message, tag = "2")]
        AuthenticatorStateExpire(super::AuthenticatorStateExpire),
        /// Use higher field numbers for kinds which happen infrequently
        #[prost(message, tag = "200")]
        AuthenticatorStateCreate(()),
        #[prost(message, tag = "201")]
        RandomnessStateCreate(()),
        #[prost(message, tag = "202")]
        DenyListStateCreate(()),
        #[prost(message, tag = "203")]
        BridgeStateCreate(super::Digest),
        #[prost(uint64, tag = "204")]
        BridgeCommitteeInit(u64),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AuthenticatorStateExpire {
    #[prost(uint64, optional, tag = "1")]
    pub min_epoch: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub authenticator_object_initial_shared_version: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionEffects {
    #[prost(oneof = "transaction_effects::Version", tags = "1, 2")]
    pub version: ::core::option::Option<transaction_effects::Version>,
}
/// Nested message and enum types in `TransactionEffects`.
pub mod transaction_effects {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(super::TransactionEffectsV1),
        #[prost(message, tag = "2")]
        V2(super::TransactionEffectsV2),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionEffectsV1 {
    /// / The status of the execution
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<ExecutionStatus>,
    /// / The epoch when this transaction was executed.
    #[prost(uint64, optional, tag = "2")]
    pub epoch: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "3")]
    pub gas_used: ::core::option::Option<GasCostSummary>,
    /// / The version that every modified (mutated or deleted) object had before it was modified by
    /// / this transaction.
    #[prost(message, repeated, tag = "4")]
    pub modified_at_versions: ::prost::alloc::vec::Vec<ModifiedAtVersion>,
    /// / The object references of the shared objects used in this transaction. Empty if no shared objects were used.
    #[prost(message, repeated, tag = "5")]
    pub shared_objects: ::prost::alloc::vec::Vec<ObjectReference>,
    /// / The transaction digest
    #[prost(message, optional, tag = "6")]
    pub transaction_digest: ::core::option::Option<Digest>,
    /// / ObjectReference and owner of new objects created.
    #[prost(message, repeated, tag = "7")]
    pub created: ::prost::alloc::vec::Vec<ObjectReferenceWithOwner>,
    /// / ObjectReference and owner of mutated objects, including gas object.
    #[prost(message, repeated, tag = "8")]
    pub mutated: ::prost::alloc::vec::Vec<ObjectReferenceWithOwner>,
    /// / ObjectReference and owner of objects that are unwrapped in this transaction.
    /// / Unwrapped objects are objects that were wrapped into other objects in the past,
    /// / and just got extracted out.
    #[prost(message, repeated, tag = "9")]
    pub unwrapped: ::prost::alloc::vec::Vec<ObjectReferenceWithOwner>,
    /// / Object Refs of objects now deleted (the new refs).
    #[prost(message, repeated, tag = "10")]
    pub deleted: ::prost::alloc::vec::Vec<ObjectReference>,
    /// / Object refs of objects previously wrapped in other objects but now deleted.
    #[prost(message, repeated, tag = "11")]
    pub unwrapped_then_deleted: ::prost::alloc::vec::Vec<ObjectReference>,
    /// / Object refs of objects now wrapped in other objects.
    #[prost(message, repeated, tag = "12")]
    pub wrapped: ::prost::alloc::vec::Vec<ObjectReference>,
    /// / The updated gas object reference. Have a dedicated field for convenient access.
    /// / It's also included in mutated.
    #[prost(message, optional, tag = "13")]
    pub gas_object: ::core::option::Option<ObjectReferenceWithOwner>,
    /// / The digest of the events emitted during execution,
    /// / can be None if the transaction does not emit any event.
    #[prost(message, optional, tag = "14")]
    pub events_digest: ::core::option::Option<Digest>,
    /// / The set of transaction digests this transaction depends on.
    #[prost(message, repeated, tag = "15")]
    pub dependencies: ::prost::alloc::vec::Vec<Digest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectReferenceWithOwner {
    #[prost(message, optional, tag = "1")]
    pub reference: ::core::option::Option<ObjectReference>,
    #[prost(message, optional, tag = "2")]
    pub owner: ::core::option::Option<Owner>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModifiedAtVersion {
    #[prost(message, optional, tag = "1")]
    pub object_id: ::core::option::Option<ObjectId>,
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionEffectsV2 {
    /// / The status of the execution
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<ExecutionStatus>,
    /// / The epoch when this transaction was executed.
    #[prost(uint64, optional, tag = "2")]
    pub epoch: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "3")]
    pub gas_used: ::core::option::Option<GasCostSummary>,
    /// / The transaction digest
    #[prost(message, optional, tag = "4")]
    pub transaction_digest: ::core::option::Option<Digest>,
    /// / The updated gas object reference, as an index into the `changed_objects` vector.
    /// / Having a dedicated field for convenient access.
    /// / System transaction that don't require gas will leave this as None.
    #[prost(uint32, optional, tag = "5")]
    pub gas_object_index: ::core::option::Option<u32>,
    /// / The digest of the events emitted during execution,
    /// / can be None if the transaction does not emit any event.
    #[prost(message, optional, tag = "6")]
    pub events_digest: ::core::option::Option<Digest>,
    /// / The set of transaction digests this transaction depends on.
    #[prost(message, repeated, tag = "7")]
    pub dependencies: ::prost::alloc::vec::Vec<Digest>,
    /// / The version number of all the written Move objects by this transaction.
    #[prost(uint64, optional, tag = "8")]
    pub lamport_version: ::core::option::Option<u64>,
    /// / Objects whose state are changed in the object store.
    #[prost(message, repeated, tag = "9")]
    pub changed_objects: ::prost::alloc::vec::Vec<ChangedObject>,
    /// / Shared objects that are not mutated in this transaction. Unlike owned objects,
    /// / read-only shared objects' version are not committed in the transaction,
    /// / and in order for a node to catch up and execute it without consensus sequencing,
    /// / the version needs to be committed in the effects.
    #[prost(message, repeated, tag = "10")]
    pub unchanged_shared_objects: ::prost::alloc::vec::Vec<UnchangedSharedObject>,
    /// / Auxiliary data that are not protocol-critical, generated as part of the effects but are stored separately.
    /// / Storing it separately allows us to avoid bloating the effects with data that are not critical.
    /// / It also provides more flexibility on the format and type of the data.
    #[prost(message, optional, tag = "11")]
    pub auxiliary_data_digest: ::core::option::Option<Digest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangedObject {
    #[prost(message, optional, tag = "1")]
    pub object_id: ::core::option::Option<ObjectId>,
    #[prost(oneof = "changed_object::InputState", tags = "2, 3")]
    pub input_state: ::core::option::Option<changed_object::InputState>,
    #[prost(oneof = "changed_object::OutputState", tags = "4, 5, 6")]
    pub output_state: ::core::option::Option<changed_object::OutputState>,
    #[prost(oneof = "changed_object::IdOperation", tags = "7, 8, 9")]
    pub id_operation: ::core::option::Option<changed_object::IdOperation>,
}
/// Nested message and enum types in `ChangedObject`.
pub mod changed_object {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum InputState {
        #[prost(message, tag = "2")]
        NotExist(()),
        #[prost(message, tag = "3")]
        Exist(super::ObjectExist),
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum OutputState {
        #[prost(message, tag = "4")]
        Removed(()),
        #[prost(message, tag = "5")]
        ObjectWrite(super::ObjectWrite),
        #[prost(message, tag = "6")]
        PackageWrite(super::PackageWrite),
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum IdOperation {
        #[prost(message, tag = "7")]
        None(()),
        #[prost(message, tag = "8")]
        Created(()),
        #[prost(message, tag = "9")]
        Deleted(()),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectExist {
    #[prost(uint64, optional, tag = "1")]
    pub version: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "2")]
    pub digest: ::core::option::Option<Digest>,
    #[prost(message, optional, tag = "3")]
    pub owner: ::core::option::Option<Owner>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectWrite {
    #[prost(message, optional, tag = "2")]
    pub digest: ::core::option::Option<Digest>,
    #[prost(message, optional, tag = "3")]
    pub owner: ::core::option::Option<Owner>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackageWrite {
    #[prost(uint64, optional, tag = "1")]
    pub version: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "2")]
    pub digest: ::core::option::Option<Digest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnchangedSharedObject {
    #[prost(message, optional, tag = "1")]
    pub object_id: ::core::option::Option<ObjectId>,
    #[prost(oneof = "unchanged_shared_object::Kind", tags = "2, 3, 4, 5, 6")]
    pub kind: ::core::option::Option<unchanged_shared_object::Kind>,
}
/// Nested message and enum types in `UnchangedSharedObject`.
pub mod unchanged_shared_object {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "2")]
        ReadOnlyRoot(super::ReadOnlyRoot),
        #[prost(uint64, tag = "3")]
        MutateDeleted(u64),
        #[prost(uint64, tag = "4")]
        ReadDeleted(u64),
        #[prost(uint64, tag = "5")]
        Cancelled(u64),
        #[prost(message, tag = "6")]
        PerEpochConfig(()),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadOnlyRoot {
    #[prost(uint64, optional, tag = "1")]
    pub version: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "2")]
    pub digest: ::core::option::Option<Digest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionStatus {
    #[prost(bool, optional, tag = "1")]
    pub success: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "2")]
    pub status: ::core::option::Option<FailureStatus>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SizeError {
    #[prost(uint64, optional, tag = "1")]
    pub size: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub max_size: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveError {
    #[prost(message, optional, tag = "1")]
    pub location: ::core::option::Option<MoveLocation>,
    #[prost(uint64, optional, tag = "2")]
    pub abort_code: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailureStatus {
    #[prost(uint64, optional, tag = "1")]
    pub command: ::core::option::Option<u64>,
    #[prost(
        oneof = "failure_status::ExecutionError",
        tags = "2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38"
    )]
    pub execution_error: ::core::option::Option<failure_status::ExecutionError>,
}
/// Nested message and enum types in `FailureStatus`.
pub mod failure_status {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ExecutionError {
        /// / Insufficient Gas
        #[prost(message, tag = "2")]
        InsufficientGas(()),
        /// / Invalid Gas Object.
        #[prost(message, tag = "3")]
        InvalidGasObject(()),
        /// / Invariant Violation
        #[prost(message, tag = "4")]
        InvariantViolation(()),
        /// / Attempted to used feature that is not supported yet
        #[prost(message, tag = "5")]
        FeatureNotYetSupported(()),
        /// / Move object is larger than the maximum allowed size
        #[prost(message, tag = "6")]
        ObjectTooBig(super::SizeError),
        /// / Package is larger than the maximum allowed size
        #[prost(message, tag = "7")]
        PackageTooBig(super::SizeError),
        /// / Circular Object Ownership
        #[prost(message, tag = "8")]
        CircularObjectOwnership(super::ObjectId),
        ///
        /// Coin errors
        ///
        /// / Insufficient coin balance for requested operation
        #[prost(message, tag = "9")]
        InsufficientCoinBalance(()),
        /// / Coin balance overflowed an u64
        #[prost(message, tag = "10")]
        CoinBalanceOverflow(()),
        ///
        /// Publish/Upgrade errors
        ///
        /// / Publish Error, Non-zero Address.
        /// / The modules in the package must have their self-addresses set to zero.
        #[prost(message, tag = "11")]
        PublishErrorNonZeroAddress(()),
        /// / Sui Move Bytecode Verification Error.
        #[prost(message, tag = "12")]
        SuiMoveVerificationError(()),
        ///
        /// MoveVm Errors
        ///
        /// / Error from a non-abort instruction.
        /// / Possible causes:
        /// /     Arithmetic error, stack overflow, max value depth, etc."
        #[prost(message, tag = "13")]
        MovePrimitiveRuntimeError(super::MoveError),
        /// / Move runtime abort
        #[prost(message, tag = "14")]
        MoveAbort(super::MoveError),
        /// / Bytecode verification error.
        #[prost(message, tag = "15")]
        VmVerificationOrDeserializationError(()),
        /// / MoveVm invariant violation
        #[prost(message, tag = "16")]
        VmInvariantViolation(()),
        ///
        /// Programmable Transaction Errors
        ///
        /// / Function not found
        #[prost(message, tag = "17")]
        FunctionNotFound(()),
        /// / Arity mismatch for Move function.
        /// / The number of arguments does not match the number of parameters
        #[prost(message, tag = "18")]
        ArityMismatch(()),
        /// / Type arity mismatch for Move function.
        /// / Mismatch between the number of actual versus expected type arguments.
        #[prost(message, tag = "19")]
        TypeArityMismatch(()),
        /// / Non Entry Function Invoked. Move Call must start with an entry function.
        #[prost(message, tag = "20")]
        NonEntryFunctionInvoked(()),
        /// / Invalid command argument
        #[prost(message, tag = "21")]
        CommandArgumentError(super::CommandArgumentError),
        /// / Type argument error
        #[prost(message, tag = "22")]
        TypeArgumentError(super::TypeArgumentError),
        /// / Unused result without the drop ability.
        #[prost(message, tag = "23")]
        UnusedValueWithoutDrop(super::NestedResult),
        /// / Invalid public Move function signature.
        /// / Unsupported return type for return value
        #[prost(uint32, tag = "24")]
        InvalidPublicFunctionReturnType(u32),
        /// / Invalid Transfer Object, object does not have public transfer.
        #[prost(message, tag = "25")]
        InvalidTransferObject(()),
        ///
        /// Post-execution errors
        ///
        /// / Effects from the transaction are too large
        #[prost(message, tag = "26")]
        EffectsTooLarge(super::SizeError),
        /// / Publish or Upgrade is missing dependency
        #[prost(message, tag = "27")]
        PublishUpgradeMissingDependency(()),
        /// / Publish or Upgrade dependency downgrade.
        /// /
        /// / Indirect (transitive) dependency of published or upgraded package has been assigned an
        /// / on-chain version that is less than the version required by one of the package's
        /// / transitive dependencies.
        #[prost(message, tag = "28")]
        PublishUpgradeDependencyDowngrade(()),
        /// / Invalid package upgrade
        #[prost(message, tag = "29")]
        PackageUpgradeError(super::PackageUpgradeError),
        /// / Indicates the transaction tried to write objects too large to storage
        #[prost(message, tag = "30")]
        WrittenObjectsTooLarge(super::SizeError),
        /// / Certificate is on the deny list
        #[prost(message, tag = "31")]
        CertificateDenied(()),
        /// / Sui Move Bytecode verification timed out.
        #[prost(message, tag = "32")]
        SuiMoveVerificationTimedout(()),
        /// / The requested shared object operation is not allowed
        #[prost(message, tag = "33")]
        SharedObjectOperationNotAllowed(()),
        /// / Requested shared object has been deleted
        #[prost(message, tag = "34")]
        InputObjectDeleted(()),
        /// / Certificate is cancelled due to congestion on shared objects
        #[prost(message, tag = "35")]
        ExecutionCancelledDueToSharedObjectCongestion(super::CongestedObjectsError),
        /// / Address is denied for this coin type
        #[prost(message, tag = "36")]
        AddressDeniedForCoin(super::AddressDeniedForCoinError),
        /// / Coin type is globally paused for use
        #[prost(string, tag = "37")]
        CoinTypeGlobalPause(::prost::alloc::string::String),
        /// / Certificate is cancelled because randomness could not be generated this epoch
        #[prost(message, tag = "38")]
        ExecutionCancelledDueToRandomnessUnavailable(()),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddressDeniedForCoinError {
    #[prost(message, optional, tag = "1")]
    pub address: ::core::option::Option<Address>,
    #[prost(string, optional, tag = "2")]
    pub coin_type: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CongestedObjectsError {
    #[prost(message, repeated, tag = "1")]
    pub congested_objects: ::prost::alloc::vec::Vec<ObjectId>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveLocation {
    #[prost(message, optional, tag = "1")]
    pub package: ::core::option::Option<ObjectId>,
    #[prost(message, optional, tag = "2")]
    pub module: ::core::option::Option<Identifier>,
    #[prost(uint32, optional, tag = "3")]
    pub function: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub instruction: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "5")]
    pub function_name: ::core::option::Option<Identifier>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CommandArgumentError {
    #[prost(uint32, optional, tag = "1")]
    pub argument: ::core::option::Option<u32>,
    #[prost(
        oneof = "command_argument_error::Kind",
        tags = "2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13"
    )]
    pub kind: ::core::option::Option<command_argument_error::Kind>,
}
/// Nested message and enum types in `CommandArgumentError`.
pub mod command_argument_error {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// / The type of the value does not match the expected type
        #[prost(message, tag = "2")]
        TypeMismatch(()),
        /// / The argument cannot be deserialized into a value of the specified type
        #[prost(message, tag = "3")]
        InvalidBcsBytes(()),
        /// / The argument cannot be instantiated from raw bytes
        #[prost(message, tag = "4")]
        InvalidUsageOfPureArgument(()),
        /// / Invalid argument to private entry function.
        /// / Private entry functions cannot take arguments from other Move functions.
        #[prost(message, tag = "5")]
        InvalidArgumentToPrivateEntryFunction(()),
        /// / Out of bounds access to input or results
        #[prost(uint32, tag = "6")]
        IndexOutOfBounds(u32),
        /// / Out of bounds access to subresult
        #[prost(message, tag = "7")]
        SecondaryIndexOutOfBounds(super::NestedResult),
        /// / Invalid usage of result.
        /// / Expected a single result but found either no return value or multiple.
        #[prost(uint32, tag = "8")]
        InvalidResultArity(u32),
        /// / Invalid usage of Gas coin.
        /// / The Gas coin can only be used by-value with a TransferObjects command.
        #[prost(message, tag = "9")]
        InvalidGasCoinUsage(()),
        /// / Invalid usage of move value.
        ///      Mutably borrowed values require unique usage.
        ///      Immutably borrowed values cannot be taken or borrowed mutably.
        ///      Taken values cannot be used again.
        #[prost(message, tag = "10")]
        InvalidValueUsage(()),
        /// / Immutable objects cannot be passed by-value.
        #[prost(message, tag = "11")]
        InvalidObjectByValue(()),
        /// / Immutable objects cannot be passed by mutable reference, &mut.
        #[prost(message, tag = "12")]
        InvalidObjectByMutRef(()),
        /// / Shared object operations such a wrapping, freezing, or converting to owned are not
        /// / allowed.
        #[prost(message, tag = "13")]
        SharedObjectOperationNotAllowed(()),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackageUpgradeError {
    #[prost(oneof = "package_upgrade_error::Kind", tags = "2, 3, 4, 5, 6, 7")]
    pub kind: ::core::option::Option<package_upgrade_error::Kind>,
}
/// Nested message and enum types in `PackageUpgradeError`.
pub mod package_upgrade_error {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "2")]
        UnableToFetchPackage(super::ObjectId),
        #[prost(message, tag = "3")]
        NotAPackage(super::ObjectId),
        #[prost(message, tag = "4")]
        IncompatibleUpgrade(()),
        #[prost(message, tag = "5")]
        DigetsDoesNotMatch(super::Digest),
        #[prost(uint32, tag = "6")]
        UnknownUpgradePolicy(u32),
        #[prost(message, tag = "7")]
        PackageIdDoesNotMatch(super::PackageIdDoesNotMatch),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackageIdDoesNotMatch {
    #[prost(message, optional, tag = "1")]
    pub package_id: ::core::option::Option<ObjectId>,
    #[prost(message, optional, tag = "2")]
    pub object_id: ::core::option::Option<ObjectId>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TypeArgumentError {
    #[prost(uint32, optional, tag = "1")]
    pub type_argument: ::core::option::Option<u32>,
    #[prost(oneof = "type_argument_error::Kind", tags = "2, 3")]
    pub kind: ::core::option::Option<type_argument_error::Kind>,
}
/// Nested message and enum types in `TypeArgumentError`.
pub mod type_argument_error {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "2")]
        TypeNotFound(()),
        #[prost(message, tag = "3")]
        ConstraintNotSatisfied(()),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserSignature {
    #[prost(oneof = "user_signature::Signature", tags = "1, 2, 3, 4")]
    pub signature: ::core::option::Option<user_signature::Signature>,
}
/// Nested message and enum types in `UserSignature`.
pub mod user_signature {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Signature {
        #[prost(message, tag = "1")]
        Simple(super::SimpleSignature),
        #[prost(message, tag = "2")]
        Multisig(super::MultisigAggregatedSignature),
        #[prost(message, tag = "3")]
        Zklogin(super::ZkLoginAuthenticator),
        #[prost(message, tag = "4")]
        Passkey(super::PasskeyAuthenticator),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimpleSignature {
    #[prost(enumeration = "SignatureScheme", optional, tag = "1")]
    pub scheme: ::core::option::Option<i32>,
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub signature: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub public_key: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginPublicIdentifier {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub iss: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(message, optional, tag = "2")]
    pub address_seed: ::core::option::Option<Bn254FieldElement>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigMemberPublicKey {
    #[prost(oneof = "multisig_member_public_key::Scheme", tags = "1, 2, 3, 4")]
    pub scheme: ::core::option::Option<multisig_member_public_key::Scheme>,
}
/// Nested message and enum types in `MultisigMemberPublicKey`.
pub mod multisig_member_public_key {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Scheme {
        #[prost(bytes, tag = "1")]
        Ed25519(::prost::bytes::Bytes),
        #[prost(bytes, tag = "2")]
        Secp256k1(::prost::bytes::Bytes),
        #[prost(bytes, tag = "3")]
        Secp256r1(::prost::bytes::Bytes),
        #[prost(message, tag = "4")]
        Zklogin(super::ZkLoginPublicIdentifier),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigMember {
    #[prost(message, optional, tag = "1")]
    pub public_key: ::core::option::Option<MultisigMemberPublicKey>,
    #[prost(uint32, optional, tag = "2")]
    pub weight: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigCommittee {
    #[prost(message, repeated, tag = "1")]
    pub members: ::prost::alloc::vec::Vec<MultisigMember>,
    #[prost(uint32, optional, tag = "2")]
    pub threshold: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigAggregatedSignature {
    #[prost(message, repeated, tag = "1")]
    pub signatures: ::prost::alloc::vec::Vec<MultisigMemberSignature>,
    #[prost(uint32, optional, tag = "2")]
    pub bitmap: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "3")]
    pub legacy_bitmap: ::core::option::Option<RoaringBitmap>,
    #[prost(message, optional, tag = "4")]
    pub committee: ::core::option::Option<MultisigCommittee>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigMemberSignature {
    #[prost(oneof = "multisig_member_signature::Signature", tags = "1, 2, 3, 4")]
    pub signature: ::core::option::Option<multisig_member_signature::Signature>,
}
/// Nested message and enum types in `MultisigMemberSignature`.
pub mod multisig_member_signature {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Signature {
        #[prost(bytes, tag = "1")]
        Ed25519(::prost::bytes::Bytes),
        #[prost(bytes, tag = "2")]
        Secp256k1(::prost::bytes::Bytes),
        #[prost(bytes, tag = "3")]
        Secp256r1(::prost::bytes::Bytes),
        #[prost(message, tag = "4")]
        Zklogin(super::ZkLoginAuthenticator),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginAuthenticator {
    #[prost(message, optional, tag = "1")]
    pub inputs: ::core::option::Option<ZkLoginInputs>,
    #[prost(uint64, optional, tag = "2")]
    pub max_epoch: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<SimpleSignature>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginInputs {
    #[prost(message, optional, tag = "1")]
    pub proof_points: ::core::option::Option<ZkLoginProof>,
    #[prost(message, optional, tag = "2")]
    pub iss_base64_details: ::core::option::Option<ZkLoginClaim>,
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub header_base64: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(message, optional, tag = "4")]
    pub address_seed: ::core::option::Option<Bn254FieldElement>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginProof {
    #[prost(message, optional, tag = "1")]
    pub a: ::core::option::Option<CircomG1>,
    #[prost(message, optional, tag = "2")]
    pub b: ::core::option::Option<CircomG2>,
    #[prost(message, optional, tag = "3")]
    pub c: ::core::option::Option<CircomG1>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginClaim {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub value: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(uint32, optional, tag = "2")]
    pub index_mod_4: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CircomG1 {
    #[prost(message, optional, tag = "1")]
    pub e0: ::core::option::Option<Bn254FieldElement>,
    #[prost(message, optional, tag = "2")]
    pub e1: ::core::option::Option<Bn254FieldElement>,
    #[prost(message, optional, tag = "3")]
    pub e2: ::core::option::Option<Bn254FieldElement>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CircomG2 {
    #[prost(message, optional, tag = "1")]
    pub e00: ::core::option::Option<Bn254FieldElement>,
    #[prost(message, optional, tag = "2")]
    pub e01: ::core::option::Option<Bn254FieldElement>,
    #[prost(message, optional, tag = "3")]
    pub e10: ::core::option::Option<Bn254FieldElement>,
    #[prost(message, optional, tag = "4")]
    pub e11: ::core::option::Option<Bn254FieldElement>,
    #[prost(message, optional, tag = "5")]
    pub e20: ::core::option::Option<Bn254FieldElement>,
    #[prost(message, optional, tag = "6")]
    pub e21: ::core::option::Option<Bn254FieldElement>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bn254FieldElement {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub element: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PasskeyAuthenticator {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub authenticator_data: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub client_data_json: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<SimpleSignature>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorCommittee {
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "2")]
    pub members: ::prost::alloc::vec::Vec<ValidatorCommitteeMember>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorCommitteeMember {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub public_key: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(uint64, optional, tag = "2")]
    pub stake: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorAggregatedSignature {
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub signature: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(message, optional, tag = "3")]
    pub bitmap: ::core::option::Option<RoaringBitmap>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoaringBitmap {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub bitmap: ::core::option::Option<::prost::bytes::Bytes>,
}
/// note: values do not match their bcs serialized values
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SignatureScheme {
    Unknown = 0,
    Ed25519 = 1,
    Secp256k1 = 2,
    Secp256r1 = 3,
    Multisig = 4,
    Bls12381 = 5,
    Zklogin = 6,
    Passkey = 7,
}
impl SignatureScheme {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "SIGNATURE_SCHEME_UNKNOWN",
            Self::Ed25519 => "SIGNATURE_SCHEME_ED25519",
            Self::Secp256k1 => "SIGNATURE_SCHEME_SECP256K1",
            Self::Secp256r1 => "SIGNATURE_SCHEME_SECP256R1",
            Self::Multisig => "SIGNATURE_SCHEME_MULTISIG",
            Self::Bls12381 => "SIGNATURE_SCHEME_BLS12381",
            Self::Zklogin => "SIGNATURE_SCHEME_ZKLOGIN",
            Self::Passkey => "SIGNATURE_SCHEME_PASSKEY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIGNATURE_SCHEME_UNKNOWN" => Some(Self::Unknown),
            "SIGNATURE_SCHEME_ED25519" => Some(Self::Ed25519),
            "SIGNATURE_SCHEME_SECP256K1" => Some(Self::Secp256k1),
            "SIGNATURE_SCHEME_SECP256R1" => Some(Self::Secp256r1),
            "SIGNATURE_SCHEME_MULTISIG" => Some(Self::Multisig),
            "SIGNATURE_SCHEME_BLS12381" => Some(Self::Bls12381),
            "SIGNATURE_SCHEME_ZKLOGIN" => Some(Self::Zklogin),
            "SIGNATURE_SCHEME_PASSKEY" => Some(Self::Passkey),
            _ => None,
        }
    }
}
