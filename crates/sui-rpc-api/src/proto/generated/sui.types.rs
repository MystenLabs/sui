// This file is @generated by prost-build.
/// Flag use to disambiguate the signature schemes supported by Sui.
///
/// Note: the enum values defined by this proto message exactly match their
/// expected BCS serialized values when serialized as a u8. See
/// [enum.SignatureScheme](<https://mystenlabs.github.io/sui-rust-sdk/sui_sdk_types/enum.SignatureScheme.html>)
/// for more information about signature schemes.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SignatureScheme {
    Ed25519 = 0,
    Secp256k1 = 1,
    Secp256r1 = 2,
    Multisig = 3,
    Bls12381 = 4,
    Zklogin = 5,
    Passkey = 6,
}
impl SignatureScheme {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Ed25519 => "ED25519",
            Self::Secp256k1 => "SECP256K1",
            Self::Secp256r1 => "SECP256R1",
            Self::Multisig => "MULTISIG",
            Self::Bls12381 => "BLS12381",
            Self::Zklogin => "ZKLOGIN",
            Self::Passkey => "PASSKEY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ED25519" => Some(Self::Ed25519),
            "SECP256K1" => Some(Self::Secp256k1),
            "SECP256R1" => Some(Self::Secp256r1),
            "MULTISIG" => Some(Self::Multisig),
            "BLS12381" => Some(Self::Bls12381),
            "ZKLOGIN" => Some(Self::Zklogin),
            "PASSKEY" => Some(Self::Passkey),
            _ => None,
        }
    }
}
/// Unique identifier for an account on the Sui blockchain.
///
/// An `Address` is a 32-byte pseudonymous identifier used to uniquely identify an account and
/// asset-ownership on the Sui blockchain. Often, human-readable addresses are encoded in
/// hexadecimal with a `0x` prefix. For example, this is a valid Sui address:
/// `0x02a212de6a9dfa3a69e22387acfbafbb1a9e591bd9d636e7895dcfc8de05f331`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Address {
    /// Required. 32-byte address.
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Unique identifier for an object on the Sui blockchain.
///
/// An `ObjectId` is a 32-byte identifier used to uniquely identify an object on the Sui
/// blockchain.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectId {
    /// Required. 32-byte object-id.
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub object_id: ::core::option::Option<::prost::bytes::Bytes>,
}
/// 32-byte output of hashing a Sui structure using the Blake2b256 hash function.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Digest {
    /// Required. 32-byte hash.
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub digest: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Message that represents a type that is serialized and encoded using the
/// [BCS](<https://mystenlabs.github.io/sui-rust-sdk/sui_sdk_types/index.html#bcs>)
/// format.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bcs {
    /// Required. Bytes of a BCS encoded value.
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub bcs: ::core::option::Option<::prost::bytes::Bytes>,
}
/// An unsigned 128-bit integer encoded in little-endian using 16-bytes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct U128 {
    /// Required. 16-byte little-endian bytes.
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub bytes: ::core::option::Option<::prost::bytes::Bytes>,
}
/// A signed 128-bit integer encoded in little-endian using 16-bytes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct I128 {
    /// Required. 16-byte little-endian bytes.
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub bytes: ::core::option::Option<::prost::bytes::Bytes>,
}
/// An unsigned 256-bit integer encoded in little-endian using 32-bytes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct U256 {
    /// Required. 16-byte little-endian bytes.
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub bytes: ::core::option::Option<::prost::bytes::Bytes>,
}
/// A header for a checkpoint on the Sui blockchain.
///
/// On the Sui network, checkpoints define the history of the blockchain. They are quite similar to
/// the concept of blocks used by other blockchains like Bitcoin or Ethereum. The Sui blockchain,
/// however, forms checkpoints after transaction execution has already happened to provide a
/// certified history of the chain, instead of being formed before execution.
///
/// Checkpoints commit to a variety of state, including but not limited to:
/// - The hash of the previous checkpoint.
/// - The set of transaction digests, their corresponding effects digests, as well as the set of
///    user signatures that authorized its execution.
/// - The objects produced by a transaction.
/// - The set of live objects that make up the current state of the chain.
/// - On epoch transitions, the next validator committee.
///
/// `CheckpointSummary`s themselves don't directly include all of the previous information but they
/// are the top-level type by which all the information is committed to transitively via cryptographic
/// hashes included in the summary. `CheckpointSummary`s are signed and certified by a quorum of
/// the validator committee in a given epoch to allow verification of the chain's state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointSummary {
    /// Epoch that this checkpoint belongs to.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// The height of this checkpoint.
    #[prost(uint64, optional, tag = "2")]
    pub sequence_number: ::core::option::Option<u64>,
    /// Total number of transactions committed since genesis, including those in this
    /// checkpoint.
    #[prost(uint64, optional, tag = "3")]
    pub total_network_transactions: ::core::option::Option<u64>,
    /// The hash of the `CheckpointContents` for this checkpoint.
    #[prost(message, optional, tag = "4")]
    pub content_digest: ::core::option::Option<Digest>,
    /// The hash of the previous `CheckpointSummary`.
    ///
    /// This will be `None` only for the first, or genesis, checkpoint.
    #[prost(message, optional, tag = "5")]
    pub previous_digest: ::core::option::Option<Digest>,
    /// The running total gas costs of all transactions included in the current epoch so far
    /// until this checkpoint.
    #[prost(message, optional, tag = "6")]
    pub epoch_rolling_gas_cost_summary: ::core::option::Option<GasCostSummary>,
    /// Timestamp of the checkpoint - number of milliseconds from the Unix epoch
    /// Checkpoint timestamps are monotonic, but not strongly monotonic - subsequent
    /// checkpoints can have the same timestamp if they originate from the same underlining consensus commit.
    #[prost(uint64, optional, tag = "7")]
    pub timestamp_ms: ::core::option::Option<u64>,
    /// Commitments to checkpoint-specific state.
    #[prost(message, repeated, tag = "8")]
    pub commitments: ::prost::alloc::vec::Vec<CheckpointCommitment>,
    /// Extra data only present in the final checkpoint of an epoch.
    #[prost(message, optional, tag = "9")]
    pub end_of_epoch_data: ::core::option::Option<EndOfEpochData>,
    /// `CheckpointSummary` is not an evolvable structure - it must be readable by any version of
    /// the code. Therefore, to allow extensions to be added to `CheckpointSummary`,
    /// opaque data can be added to checkpoints, which can be deserialized based on the current
    /// protocol version.
    #[prost(bytes = "bytes", optional, tag = "10")]
    pub version_specific_data: ::core::option::Option<::prost::bytes::Bytes>,
}
/// A commitment made by a checkpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointCommitment {
    #[prost(oneof = "checkpoint_commitment::Commitment", tags = "1")]
    pub commitment: ::core::option::Option<checkpoint_commitment::Commitment>,
}
/// Nested message and enum types in `CheckpointCommitment`.
pub mod checkpoint_commitment {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Commitment {
        /// An elliptic curve multiset hash attesting to the set of objects that comprise the live
        /// state of the Sui blockchain.
        #[prost(message, tag = "1")]
        EcmhLiveObjectSet(super::Digest),
    }
}
/// Data, which when included in a `CheckpointSummary`, signals the end of an `Epoch`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndOfEpochData {
    /// The set of validators that will be in the `ValidatorCommittee` for the next epoch.
    #[prost(message, repeated, tag = "1")]
    pub next_epoch_committee: ::prost::alloc::vec::Vec<ValidatorCommitteeMember>,
    /// The protocol version that is in effect during the next epoch.
    #[prost(uint64, optional, tag = "2")]
    pub next_epoch_protocol_version: ::core::option::Option<u64>,
    /// Commitments to epoch specific state (live object set)
    #[prost(message, repeated, tag = "3")]
    pub epoch_commitments: ::prost::alloc::vec::Vec<CheckpointCommitment>,
}
/// Transaction information committed to in a checkpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointedTransactionInfo {
    /// Digest of the transaction.
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<Digest>,
    /// Digest of the effects.
    #[prost(message, optional, tag = "2")]
    pub effects: ::core::option::Option<Digest>,
    /// Set of user signatures that authorized the transaction.
    #[prost(message, repeated, tag = "3")]
    pub signatures: ::prost::alloc::vec::Vec<UserSignature>,
}
/// The committed to contents of a checkpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointContents {
    #[prost(oneof = "checkpoint_contents::Contents", tags = "1")]
    pub contents: ::core::option::Option<checkpoint_contents::Contents>,
}
/// Nested message and enum types in `CheckpointContents`.
pub mod checkpoint_contents {
    /// Version 1 of `CheckpointContents`.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct V1 {
        #[prost(message, repeated, tag = "1")]
        pub transactions: ::prost::alloc::vec::Vec<super::CheckpointedTransactionInfo>,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Contents {
        #[prost(message, tag = "1")]
        V1(V1),
    }
}
/// Events emitted during the successful execution of a transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionEvents {
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<Event>,
}
/// An event.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    /// Package ID of the top-level function invoked by a `MoveCall` command that triggered this
    /// event to be emitted.
    #[prost(message, optional, tag = "1")]
    pub package_id: ::core::option::Option<ObjectId>,
    /// Module name of the top-level function invoked by a `MoveCall` command that triggered this
    /// event to be emitted.
    #[prost(message, optional, tag = "2")]
    pub module: ::core::option::Option<Identifier>,
    /// Address of the account that sent the transaction where this event was emitted.
    #[prost(message, optional, tag = "3")]
    pub sender: ::core::option::Option<Address>,
    /// The type of the event emitted.
    #[prost(message, optional, tag = "4")]
    pub event_type: ::core::option::Option<StructTag>,
    /// BCS serialized bytes of the event.
    #[prost(bytes = "bytes", optional, tag = "5")]
    pub contents: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Reference to an object.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectReference {
    /// The object ID of this object.
    #[prost(message, optional, tag = "1")]
    pub object_id: ::core::option::Option<ObjectId>,
    /// The version of this object.
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
    /// The digest of this object.
    #[prost(message, optional, tag = "3")]
    pub digest: ::core::option::Option<Digest>,
}
/// A Move package.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MovePackage {
    /// Address or ID of this package.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    /// Version of the package.
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
    /// Set of modules defined by this package.
    #[prost(message, repeated, tag = "3")]
    pub modules: ::prost::alloc::vec::Vec<MoveModule>,
    /// Maps struct/module to a package version where it was first defined, stored as a vector for
    /// simple serialization and deserialization.
    #[prost(message, repeated, tag = "4")]
    pub type_origin_table: ::prost::alloc::vec::Vec<TypeOrigin>,
    /// For each dependency, maps original package ID to the info about the (upgraded) dependency
    /// version that this package is using.
    #[prost(message, repeated, tag = "5")]
    pub linkage_table: ::prost::alloc::vec::Vec<UpgradeInfo>,
}
/// Module defined by a package.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveModule {
    /// Name of the module.
    #[prost(message, optional, tag = "1")]
    pub name: ::core::option::Option<Identifier>,
    /// Serialized bytecode of the module.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub contents: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Identifies a struct and the module it was defined in.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypeOrigin {
    #[prost(message, optional, tag = "1")]
    pub module_name: ::core::option::Option<Identifier>,
    #[prost(message, optional, tag = "2")]
    pub struct_name: ::core::option::Option<Identifier>,
    #[prost(message, optional, tag = "3")]
    pub package_id: ::core::option::Option<ObjectId>,
}
/// / Upgraded package info for the linkage table.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpgradeInfo {
    /// ID of the original package.
    #[prost(message, optional, tag = "1")]
    pub original_id: ::core::option::Option<ObjectId>,
    /// ID of the upgraded package.
    #[prost(message, optional, tag = "2")]
    pub upgraded_id: ::core::option::Option<ObjectId>,
    /// Version of the upgraded package.
    #[prost(uint64, optional, tag = "3")]
    pub upgraded_version: ::core::option::Option<u64>,
}
/// Enum of different types of ownership for an object.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Owner {
    #[prost(oneof = "owner::Kind", tags = "1, 2, 3, 4")]
    pub kind: ::core::option::Option<owner::Kind>,
}
/// Nested message and enum types in `Owner`.
pub mod owner {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// Object is exclusively owned by a single address, and is mutable.
        #[prost(message, tag = "1")]
        Address(super::Address),
        /// Object is exclusively owned by a single object, and is mutable.
        #[prost(message, tag = "2")]
        Object(super::ObjectId),
        /// Object is shared, can be used by any address, and is mutable.
        #[prost(uint64, tag = "3")]
        Shared(u64),
        /// Object is immutable, and hence ownership doesn't matter.
        #[prost(message, tag = "4")]
        Immutable(()),
    }
}
/// A Move struct.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveStruct {
    /// `ObjectId` for this object.
    #[prost(message, optional, tag = "1")]
    pub object_id: ::core::option::Option<ObjectId>,
    /// The type of this object.
    #[prost(message, optional, tag = "2")]
    pub object_type: ::core::option::Option<StructTag>,
    /// DEPRECATED this field is no longer used to determine whether a tx can transfer this
    /// object. Instead, it is always calculated from the objects type when loaded in execution.
    #[prost(bool, optional, tag = "3")]
    pub has_public_transfer: ::core::option::Option<bool>,
    /// Version of the object.
    #[prost(uint64, optional, tag = "4")]
    pub version: ::core::option::Option<u64>,
    /// BCS bytes of a Move struct value.
    #[prost(bytes = "bytes", optional, tag = "5")]
    pub contents: ::core::option::Option<::prost::bytes::Bytes>,
}
/// An object on the Sui blockchain.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Object {
    /// `ObjectId` for this object.
    #[prost(message, optional, tag = "1")]
    pub object_id: ::core::option::Option<ObjectId>,
    /// Version of the object.
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
    /// Owner of the object.
    #[prost(message, optional, tag = "3")]
    pub owner: ::core::option::Option<Owner>,
    #[prost(message, optional, tag = "4")]
    pub object: ::core::option::Option<ObjectData>,
    /// The digest of the transaction that created or last mutated this object
    #[prost(message, optional, tag = "5")]
    pub previous_transaction: ::core::option::Option<Digest>,
    /// The amount of SUI to rebate if this object gets deleted.
    /// This number is re-calculated each time the object is mutated based on
    /// the present storage gas price.
    #[prost(uint64, optional, tag = "6")]
    pub storage_rebate: ::core::option::Option<u64>,
}
/// Object data, either a package or struct.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectData {
    #[prost(oneof = "object_data::Kind", tags = "1, 2")]
    pub kind: ::core::option::Option<object_data::Kind>,
}
/// Nested message and enum types in `ObjectData`.
pub mod object_data {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        Struct(super::MoveStruct),
        #[prost(message, tag = "2")]
        Package(super::MovePackage),
    }
}
/// An object part of the initial chain state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisObject {
    #[prost(message, optional, tag = "1")]
    pub object_id: ::core::option::Option<ObjectId>,
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "3")]
    pub owner: ::core::option::Option<Owner>,
    #[prost(message, optional, tag = "4")]
    pub object: ::core::option::Option<ObjectData>,
}
/// Summary of gas charges.
///
/// Storage is charged independently of computation.
/// There are three parts to the storage charges:
/// - `storage_cost`: the charge of storage at the time the transaction is executed.
///                  The cost of storage is the number of bytes of the objects being mutated
///                  multiplied by a variable storage cost per byte.
/// - `storage_rebate`: the amount a user gets back when manipulating an object.
///                    The `storage_rebate` is the `storage_cost` for an object minus fees.
/// - `non_refundable_storage_fee`: not all the value of the object storage cost is
///                                given back to user and there is a small fraction that
///                                is kept by the system. This value tracks that charge.
///
/// When looking at a gas cost summary the amount charged to the user is
/// `computation_cost + storage_cost - storage_rebate`
/// and that is the amount that is deducted from the gas coins.
/// `non_refundable_storage_fee` is collected from the objects being mutated/deleted
/// and it is tracked by the system in storage funds.
///
/// Objects deleted, including the older versions of objects mutated, have the storage field
/// on the objects added up to a pool of "potential rebate". This rebate then is reduced
/// by the "nonrefundable rate" such that:
/// `potential_rebate(storage cost of deleted/mutated objects) =
/// storage_rebate + non_refundable_storage_fee`
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GasCostSummary {
    /// Cost of computation/execution.
    #[prost(uint64, optional, tag = "1")]
    pub computation_cost: ::core::option::Option<u64>,
    /// Storage cost, it's the sum of all storage cost for all objects created or mutated.
    #[prost(uint64, optional, tag = "2")]
    pub storage_cost: ::core::option::Option<u64>,
    /// The amount of storage cost refunded to the user for all objects deleted or mutated in the
    /// transaction.
    #[prost(uint64, optional, tag = "3")]
    pub storage_rebate: ::core::option::Option<u64>,
    /// The fee for the rebate. The portion of the storage rebate kept by the system.
    #[prost(uint64, optional, tag = "4")]
    pub non_refundable_storage_fee: ::core::option::Option<u64>,
}
/// A Move identifier.
///
/// Identifiers are only valid if they conform to the following ABNF:
///
/// ```text
/// identifier = (ALPHA *127(ALPHA / DIGIT / UNDERSCORE)) /
///               (UNDERSCORE 1*127(ALPHA / DIGIT / UNDERSCORE))
/// UNDERSCORE = %x95
/// ```
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Identifier {
    #[prost(string, optional, tag = "1")]
    pub identifier: ::core::option::Option<::prost::alloc::string::String>,
}
/// Type information for a Move struct.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StructTag {
    /// Address of the package where this type was defined.
    #[prost(message, optional, tag = "1")]
    pub address: ::core::option::Option<Address>,
    /// Name of the module where this type was defined.
    #[prost(message, optional, tag = "2")]
    pub module: ::core::option::Option<Identifier>,
    /// Name of the type itself.
    #[prost(message, optional, tag = "3")]
    pub name: ::core::option::Option<Identifier>,
    /// List of type parameters, if any.
    #[prost(message, repeated, tag = "4")]
    pub type_parameters: ::prost::alloc::vec::Vec<TypeTag>,
}
/// Type of a Move value.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypeTag {
    #[prost(oneof = "type_tag::Tag", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11")]
    pub tag: ::core::option::Option<type_tag::Tag>,
}
/// Nested message and enum types in `TypeTag`.
pub mod type_tag {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Tag {
        #[prost(message, tag = "1")]
        U8(()),
        #[prost(message, tag = "2")]
        U16(()),
        #[prost(message, tag = "3")]
        U32(()),
        #[prost(message, tag = "4")]
        U64(()),
        #[prost(message, tag = "5")]
        U128(()),
        #[prost(message, tag = "6")]
        U256(()),
        #[prost(message, tag = "7")]
        Bool(()),
        #[prost(message, tag = "8")]
        Address(()),
        #[prost(message, tag = "9")]
        Signer(()),
        #[prost(message, tag = "10")]
        Vector(::prost::alloc::boxed::Box<super::TypeTag>),
        #[prost(message, tag = "11")]
        Struct(super::StructTag),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveStructValue {
    #[prost(message, optional, tag = "1")]
    pub struct_type: ::core::option::Option<StructTag>,
    #[prost(message, repeated, tag = "2")]
    pub fields: ::prost::alloc::vec::Vec<MoveField>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveField {
    #[prost(message, optional, tag = "1")]
    pub name: ::core::option::Option<Identifier>,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<MoveValue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveVariant {
    #[prost(message, optional, tag = "1")]
    pub enum_type: ::core::option::Option<StructTag>,
    #[prost(message, optional, tag = "2")]
    pub variant_name: ::core::option::Option<Identifier>,
    #[prost(uint32, optional, tag = "3")]
    pub tag: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "4")]
    pub fields: ::prost::alloc::vec::Vec<MoveField>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveValue {
    #[prost(oneof = "move_value::Kind", tags = "2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13")]
    pub kind: ::core::option::Option<move_value::Kind>,
}
/// Nested message and enum types in `MoveValue`.
pub mod move_value {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(bool, tag = "2")]
        Bool(bool),
        #[prost(uint32, tag = "3")]
        U8(u32),
        #[prost(uint32, tag = "4")]
        U16(u32),
        #[prost(uint32, tag = "5")]
        U32(u32),
        #[prost(uint64, tag = "6")]
        U64(u64),
        #[prost(message, tag = "7")]
        U128(super::U128),
        #[prost(message, tag = "8")]
        U256(super::U256),
        #[prost(message, tag = "9")]
        Address(super::Address),
        #[prost(message, tag = "10")]
        Vector(super::MoveVector),
        #[prost(message, tag = "11")]
        Struct(super::MoveStructValue),
        #[prost(message, tag = "12")]
        Signer(super::Address),
        #[prost(message, tag = "13")]
        Variant(super::MoveVariant),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveVector {
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<MoveValue>,
}
/// A transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
    #[prost(oneof = "transaction::Version", tags = "1")]
    pub version: ::core::option::Option<transaction::Version>,
}
/// Nested message and enum types in `Transaction`.
pub mod transaction {
    /// Version 1 of `Transaction`.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TransactionV1 {
        #[prost(message, optional, tag = "1")]
        pub kind: ::core::option::Option<super::TransactionKind>,
        #[prost(message, optional, tag = "2")]
        pub sender: ::core::option::Option<super::Address>,
        #[prost(message, optional, tag = "3")]
        pub gas_payment: ::core::option::Option<super::GasPayment>,
        #[prost(message, optional, tag = "4")]
        pub expiration: ::core::option::Option<super::TransactionExpiration>,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(TransactionV1),
    }
}
/// Payment information for executing a transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GasPayment {
    /// Set of gas objects to use for payment.
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<ObjectReference>,
    /// Owner of the gas objects, either the transaction sender or a sponsor.
    #[prost(message, optional, tag = "2")]
    pub owner: ::core::option::Option<Address>,
    /// Gas unit price to use when charging for computation.
    ///
    /// Must be greater than or equal to the network's current RGP (reference gas price).
    #[prost(uint64, optional, tag = "3")]
    pub price: ::core::option::Option<u64>,
    /// Total budget willing to spend for the execution of a transaction.
    #[prost(uint64, optional, tag = "4")]
    pub budget: ::core::option::Option<u64>,
}
/// A TTL for a transaction.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TransactionExpiration {
    #[prost(oneof = "transaction_expiration::Expiration", tags = "1, 2")]
    pub expiration: ::core::option::Option<transaction_expiration::Expiration>,
}
/// Nested message and enum types in `TransactionExpiration`.
pub mod transaction_expiration {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Expiration {
        /// The transaction has no expiration.
        #[prost(message, tag = "1")]
        None(()),
        /// Validators won't sign and execute transaction unless the expiration epoch
        /// is greater than or equal to the current epoch.
        #[prost(uint64, tag = "2")]
        Epoch(u64),
    }
}
/// Randomness update.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RandomnessStateUpdate {
    /// Epoch of the randomness state update transaction.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// Randomness round of the update.
    #[prost(uint64, optional, tag = "2")]
    pub randomness_round: ::core::option::Option<u64>,
    /// Updated random bytes.
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub random_bytes: ::core::option::Option<::prost::bytes::Bytes>,
    /// The initial version of the randomness object that it was shared at.
    #[prost(uint64, optional, tag = "4")]
    pub randomness_object_initial_shared_version: ::core::option::Option<u64>,
}
/// Transaction type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionKind {
    #[prost(oneof = "transaction_kind::Kind", tags = "1, 2, 200, 201, 3, 4, 5, 202, 6")]
    pub kind: ::core::option::Option<transaction_kind::Kind>,
}
/// Nested message and enum types in `TransactionKind`.
pub mod transaction_kind {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// A user transaction comprised of a list of native commands and Move calls.
        #[prost(message, tag = "1")]
        ProgrammableTransaction(super::ProgrammableTransaction),
        /// System transaction used to end an epoch.
        ///
        /// The `ChangeEpoch` variant is now deprecated (but the `ChangeEpoch` struct is still used by
        /// `EndOfEpochTransaction`).
        #[prost(message, tag = "2")]
        ChangeEpoch(super::ChangeEpoch),
        /// Transaction used to initialize the chain state.
        ///
        /// Only valid if in the genesis checkpoint (0) and if this is the very first transaction ever
        /// executed on the chain.
        #[prost(message, tag = "200")]
        Genesis(super::GenesisTransaction),
        /// V1 consensus commit update.
        #[prost(message, tag = "201")]
        ConsensusCommitPrologueV1(super::ConsensusCommitPrologue),
        /// Update set of valid JWKs used for zklogin.
        #[prost(message, tag = "3")]
        AuthenticatorStateUpdate(super::AuthenticatorStateUpdate),
        /// Set of operations to run at the end of the epoch to close out the current epoch and start
        /// the next one.
        #[prost(message, tag = "4")]
        EndOfEpoch(super::EndOfEpochTransaction),
        /// Randomness update.
        #[prost(message, tag = "5")]
        RandomnessStateUpdate(super::RandomnessStateUpdate),
        /// V2 consensus commit update.
        #[prost(message, tag = "202")]
        ConsensusCommitPrologueV2(super::ConsensusCommitPrologue),
        /// V3 consensus commit update.
        #[prost(message, tag = "6")]
        ConsensusCommitPrologueV3(super::ConsensusCommitPrologue),
    }
}
/// A user transaction.
///
/// Contains a series of native commands and Move calls where the results of one command can be
/// used in future commands.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProgrammableTransaction {
    /// Input objects or primitive values.
    #[prost(message, repeated, tag = "1")]
    pub inputs: ::prost::alloc::vec::Vec<Input>,
    /// The commands to be executed sequentially. A failure in any command
    /// results in the failure of the entire transaction.
    #[prost(message, repeated, tag = "2")]
    pub commands: ::prost::alloc::vec::Vec<Command>,
}
/// An input to a user transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Input {
    #[prost(oneof = "input::Kind", tags = "1, 2, 3, 4")]
    pub kind: ::core::option::Option<input::Kind>,
}
/// Nested message and enum types in `Input`.
pub mod input {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// A move value serialized as BCS.
        ///
        /// For normal operations this is required to be a move primitive type and not contain structs
        /// or objects.
        #[prost(bytes, tag = "1")]
        Pure(::prost::bytes::Bytes),
        /// A Move object that is either immutable or address owned.
        #[prost(message, tag = "2")]
        ImmutableOrOwned(super::ObjectReference),
        /// A Move object whose owner is "Shared".
        #[prost(message, tag = "3")]
        Shared(super::SharedObjectInput),
        /// A Move object that is attempted to be received in this transaction.
        #[prost(message, tag = "4")]
        Receiving(super::ObjectReference),
    }
}
/// A shared object input.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SharedObjectInput {
    /// `ObjectId` of the shared object.
    #[prost(message, optional, tag = "1")]
    pub object_id: ::core::option::Option<ObjectId>,
    /// Initial version of the object when it was shared.
    #[prost(uint64, optional, tag = "2")]
    pub initial_shared_version: ::core::option::Option<u64>,
    /// Controls whether the caller asks for a mutable reference to the shared object.
    #[prost(bool, optional, tag = "3")]
    pub mutable: ::core::option::Option<bool>,
}
/// A single command in a programmable transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Command {
    #[prost(oneof = "command::Command", tags = "1, 2, 3, 4, 5, 6, 7")]
    pub command: ::core::option::Option<command::Command>,
}
/// Nested message and enum types in `Command`.
pub mod command {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Command {
        /// A call to either an entry or a public Move function.
        #[prost(message, tag = "1")]
        MoveCall(super::MoveCall),
        /// `(Vec<forall T:key+store. T>, address)`
        /// It sends n-objects to the specified address. These objects must have store
        /// (public transfer) and either the previous owner must be an address or the object must
        /// be newly created.
        #[prost(message, tag = "2")]
        TransferObjects(super::TransferObjects),
        /// `(&mut Coin<T>, Vec<u64>)` -> `Vec<Coin<T>>`
        /// It splits off some amounts into new coins with those amounts.
        #[prost(message, tag = "3")]
        SplitCoins(super::SplitCoins),
        /// `(&mut Coin<T>, Vec<Coin<T>>)`
        /// It merges n-coins into the first coin.
        #[prost(message, tag = "4")]
        MergeCoins(super::MergeCoins),
        /// Publishes a Move package. It takes the package bytes and a list of the package's transitive
        /// dependencies to link against on chain.
        #[prost(message, tag = "5")]
        Publish(super::Publish),
        /// `forall T: Vec<T> -> vector<T>`
        /// Given n-values of the same type, it constructs a vector. For non-objects or an empty vector,
        /// the type tag must be specified.
        #[prost(message, tag = "6")]
        MakeMoveVector(super::MakeMoveVector),
        /// Upgrades a Move package.
        /// Takes (in order):
        /// 1. A vector of serialized modules for the package.
        /// 2. A vector of object ids for the transitive dependencies of the new package.
        /// 3. The object ID of the package being upgraded.
        /// 4. An argument holding the `UpgradeTicket` that must have been produced from an earlier command in the same
        ///     programmable transaction.
        #[prost(message, tag = "7")]
        Upgrade(super::Upgrade),
    }
}
/// Command to call a Move function.
///
/// Functions that can be called by a `MoveCall` command are those that have a function signature
/// that is either `entry` or `public` (which don't have a reference return type).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveCall {
    /// The package containing the module and function.
    #[prost(message, optional, tag = "1")]
    pub package: ::core::option::Option<ObjectId>,
    /// The specific module in the package containing the function.
    #[prost(message, optional, tag = "2")]
    pub module: ::core::option::Option<Identifier>,
    /// The function to be called.
    #[prost(message, optional, tag = "3")]
    pub function: ::core::option::Option<Identifier>,
    /// The type arguments to the function.
    #[prost(message, repeated, tag = "4")]
    pub type_arguments: ::prost::alloc::vec::Vec<TypeTag>,
    /// The arguments to the function.
    #[prost(message, repeated, tag = "5")]
    pub arguments: ::prost::alloc::vec::Vec<Argument>,
}
/// Command to transfer ownership of a set of objects to an address.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferObjects {
    /// Set of objects to transfer.
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<Argument>,
    /// The address to transfer ownership to.
    #[prost(message, optional, tag = "2")]
    pub address: ::core::option::Option<Argument>,
}
/// Command to split a single coin object into multiple coins.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SplitCoins {
    /// The coin to split.
    #[prost(message, optional, tag = "1")]
    pub coin: ::core::option::Option<Argument>,
    /// The amounts to split off.
    #[prost(message, repeated, tag = "2")]
    pub amounts: ::prost::alloc::vec::Vec<Argument>,
}
/// Command to merge multiple coins of the same type into a single coin.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeCoins {
    /// Coin to merge coins into.
    #[prost(message, optional, tag = "1")]
    pub coin: ::core::option::Option<Argument>,
    /// Set of coins to merge into `coin`.
    ///
    /// All listed coins must be of the same type and be the same type as `coin`
    #[prost(message, repeated, tag = "2")]
    pub coins_to_merge: ::prost::alloc::vec::Vec<Argument>,
}
/// Command to publish a new Move package.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Publish {
    /// The serialized Move modules.
    #[prost(bytes = "bytes", repeated, tag = "1")]
    pub modules: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    /// Set of packages that the to-be published package depends on.
    #[prost(message, repeated, tag = "2")]
    pub dependencies: ::prost::alloc::vec::Vec<ObjectId>,
}
/// Command to build a Move vector out of a set of individual elements.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MakeMoveVector {
    /// Type of the individual elements.
    ///
    /// This is required to be set when the type can't be inferred, for example when the set of
    /// provided arguments are all pure input values.
    #[prost(message, optional, tag = "1")]
    pub element_type: ::core::option::Option<TypeTag>,
    /// The set individual elements to build the vector with.
    #[prost(message, repeated, tag = "2")]
    pub elements: ::prost::alloc::vec::Vec<Argument>,
}
/// Command to upgrade an already published package.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Upgrade {
    /// The serialized Move modules.
    #[prost(bytes = "bytes", repeated, tag = "1")]
    pub modules: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    /// Set of packages that the to-be published package depends on.
    #[prost(message, repeated, tag = "2")]
    pub dependencies: ::prost::alloc::vec::Vec<ObjectId>,
    /// Package ID of the package to upgrade.
    #[prost(message, optional, tag = "3")]
    pub package: ::core::option::Option<ObjectId>,
    /// Ticket authorizing the upgrade.
    #[prost(message, optional, tag = "4")]
    pub ticket: ::core::option::Option<Argument>,
}
/// An argument to a programmable transaction command.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Argument {
    #[prost(oneof = "argument::Kind", tags = "1, 2, 3, 4")]
    pub kind: ::core::option::Option<argument::Kind>,
}
/// Nested message and enum types in `Argument`.
pub mod argument {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// The gas coin. The gas coin can only be used by-ref, except for with
        /// `TransferObjects`, which can use it by-value.
        #[prost(message, tag = "1")]
        Gas(()),
        /// One of the input objects or primitive values (from
        /// `ProgrammableTransaction` inputs).
        #[prost(uint32, tag = "2")]
        Input(u32),
        /// The result of another command (from `ProgrammableTransaction` commands).
        #[prost(uint32, tag = "3")]
        Result(u32),
        /// Like a `Result` but it accesses a nested result. Currently, the only usage
        /// of this is to access a value from a Move call with multiple return values.
        #[prost(message, tag = "4")]
        NestedResult(super::NestedResult),
    }
}
/// An argument type for a nested result.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NestedResult {
    /// The command index.
    #[prost(uint32, optional, tag = "1")]
    pub result: ::core::option::Option<u32>,
    /// The index into the command's output.
    #[prost(uint32, optional, tag = "2")]
    pub subresult: ::core::option::Option<u32>,
}
/// System transaction used to change the epoch.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeEpoch {
    /// The next (to become) epoch ID.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// The protocol version in effect in the new epoch.
    #[prost(uint64, optional, tag = "2")]
    pub protocol_version: ::core::option::Option<u64>,
    /// The total amount of gas charged for storage during the epoch.
    #[prost(uint64, optional, tag = "3")]
    pub storage_charge: ::core::option::Option<u64>,
    /// The total amount of gas charged for computation during the epoch.
    #[prost(uint64, optional, tag = "4")]
    pub computation_charge: ::core::option::Option<u64>,
    /// The amount of storage rebate refunded to the txn senders.
    #[prost(uint64, optional, tag = "5")]
    pub storage_rebate: ::core::option::Option<u64>,
    /// The non-refundable storage fee.
    #[prost(uint64, optional, tag = "6")]
    pub non_refundable_storage_fee: ::core::option::Option<u64>,
    /// Unix timestamp when epoch started.
    #[prost(uint64, optional, tag = "7")]
    pub epoch_start_timestamp_ms: ::core::option::Option<u64>,
    /// System packages (specifically framework and Move stdlib) that are written before the new
    /// epoch starts. This tracks framework upgrades on chain. When executing the `ChangeEpoch` txn,
    /// the validator must write out the following modules.  Modules are provided with the version they
    /// will be upgraded to, their modules in serialized form (which include their package ID), and
    /// a list of their transitive dependencies.
    #[prost(message, repeated, tag = "8")]
    pub system_packages: ::prost::alloc::vec::Vec<SystemPackage>,
}
/// System package.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemPackage {
    /// Version of the package.
    #[prost(uint64, optional, tag = "1")]
    pub version: ::core::option::Option<u64>,
    /// Move modules.
    #[prost(bytes = "bytes", repeated, tag = "2")]
    pub modules: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    /// Package dependencies.
    #[prost(message, repeated, tag = "3")]
    pub dependencies: ::prost::alloc::vec::Vec<ObjectId>,
}
/// The genesis transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisTransaction {
    /// Set of genesis objects.
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<GenesisObject>,
}
/// Consensus commit prologue system transaction.
///
/// This message can represent V1, V2, and V3 prologue types.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusCommitPrologue {
    /// Epoch of the commit prologue transaction.
    ///
    /// Present in V1, V2, and V3.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// Consensus round of the commit.
    ///
    /// Present in V1, V2, and V3.
    #[prost(uint64, optional, tag = "2")]
    pub round: ::core::option::Option<u64>,
    /// Unix timestamp from consensus.
    ///
    /// Present in V1, V2, and V3.
    #[prost(uint64, optional, tag = "3")]
    pub commit_timestamp_ms: ::core::option::Option<u64>,
    /// Digest of consensus output.
    ///
    /// Present in V2 and V3.
    #[prost(message, optional, tag = "4")]
    pub consensus_commit_digest: ::core::option::Option<Digest>,
    /// The sub DAG index of the consensus commit. This field is populated if there
    /// are multiple consensus commits per round.
    ///
    /// Present in V3.
    #[prost(uint64, optional, tag = "5")]
    pub sub_dag_index: ::core::option::Option<u64>,
    /// Stores consensus handler determined shared object version assignments.
    ///
    /// Present in V3.
    #[prost(message, optional, tag = "6")]
    pub consensus_determined_version_assignments: ::core::option::Option<
        ConsensusDeterminedVersionAssignments,
    >,
}
/// Object version assignment from consensus.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VersionAssignment {
    /// `ObjectId` of the object.
    #[prost(message, optional, tag = "1")]
    pub object_id: ::core::option::Option<ObjectId>,
    /// Assigned version.
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
}
/// A transaction that was cancelled.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelledTransaction {
    /// Digest of the cancelled transaction.
    #[prost(message, optional, tag = "1")]
    pub digest: ::core::option::Option<Digest>,
    /// List of object version assignments.
    #[prost(message, repeated, tag = "2")]
    pub version_assignments: ::prost::alloc::vec::Vec<VersionAssignment>,
}
/// Set of cancelled transactions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelledTransactions {
    #[prost(message, repeated, tag = "1")]
    pub cancelled_transactions: ::prost::alloc::vec::Vec<CancelledTransaction>,
}
/// Version assignments performed by consensus.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusDeterminedVersionAssignments {
    #[prost(oneof = "consensus_determined_version_assignments::Kind", tags = "1")]
    pub kind: ::core::option::Option<consensus_determined_version_assignments::Kind>,
}
/// Nested message and enum types in `ConsensusDeterminedVersionAssignments`.
pub mod consensus_determined_version_assignments {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// Cancelled transaction version assignment.
        #[prost(message, tag = "1")]
        CancelledTransactions(super::CancelledTransactions),
    }
}
/// Update the set of valid JWKs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticatorStateUpdate {
    /// Epoch of the authenticator state update transaction.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// Consensus round of the authenticator state update.
    #[prost(uint64, optional, tag = "2")]
    pub round: ::core::option::Option<u64>,
    /// Newly active JWKs.
    #[prost(message, repeated, tag = "3")]
    pub new_active_jwks: ::prost::alloc::vec::Vec<ActiveJwk>,
    /// The initial version of the authenticator object that it was shared at.
    #[prost(uint64, optional, tag = "4")]
    pub authenticator_object_initial_shared_version: ::core::option::Option<u64>,
}
/// A new JWK.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActiveJwk {
    /// Identifier used to uniquely identify a JWK.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<JwkId>,
    /// The JWK.
    #[prost(message, optional, tag = "2")]
    pub jwk: ::core::option::Option<Jwk>,
    /// Most recent epoch in which the JWK was validated.
    #[prost(uint64, optional, tag = "3")]
    pub epoch: ::core::option::Option<u64>,
}
/// Key to uniquely identify a JWK.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JwkId {
    /// The issuer or identity of the OIDC provider.
    #[prost(string, optional, tag = "1")]
    pub iss: ::core::option::Option<::prost::alloc::string::String>,
    /// A key ID used to uniquely identify a key from an OIDC provider.
    #[prost(string, optional, tag = "2")]
    pub kid: ::core::option::Option<::prost::alloc::string::String>,
}
/// A JSON web key.
///
/// Struct that contains info for a JWK. A list of them for different kinds can
/// be retrieved from the JWK endpoint (for example, <<https://www.googleapis.com/oauth2/v3/certs>>).
/// The JWK is used to verify the JWT token.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Jwk {
    /// Key type parameter, <https://datatracker.ietf.org/doc/html/rfc7517#section-4.1.>
    #[prost(string, optional, tag = "1")]
    pub kty: ::core::option::Option<::prost::alloc::string::String>,
    /// RSA public exponent, <https://datatracker.ietf.org/doc/html/rfc7517#section-9.3.>
    #[prost(string, optional, tag = "2")]
    pub e: ::core::option::Option<::prost::alloc::string::String>,
    /// RSA modulus, <https://datatracker.ietf.org/doc/html/rfc7517#section-9.3.>
    #[prost(string, optional, tag = "3")]
    pub n: ::core::option::Option<::prost::alloc::string::String>,
    /// Algorithm parameter, <https://datatracker.ietf.org/doc/html/rfc7517#section-4.4.>
    #[prost(string, optional, tag = "4")]
    pub alg: ::core::option::Option<::prost::alloc::string::String>,
}
/// Set of operations run at the end of the epoch to close out the current epoch
/// and start the next one.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndOfEpochTransaction {
    #[prost(message, repeated, tag = "1")]
    pub transactions: ::prost::alloc::vec::Vec<EndOfEpochTransactionKind>,
}
/// Operation run at the end of an epoch.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndOfEpochTransactionKind {
    #[prost(
        oneof = "end_of_epoch_transaction_kind::Kind",
        tags = "1, 2, 200, 201, 202, 203, 204"
    )]
    pub kind: ::core::option::Option<end_of_epoch_transaction_kind::Kind>,
}
/// Nested message and enum types in `EndOfEpochTransactionKind`.
pub mod end_of_epoch_transaction_kind {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// End the epoch and start the next one.
        #[prost(message, tag = "1")]
        ChangeEpoch(super::ChangeEpoch),
        /// Expire JWKs used for zklogin.
        #[prost(message, tag = "2")]
        AuthenticatorStateExpire(super::AuthenticatorStateExpire),
        /// Create and initialize the authenticator object used for zklogin.
        #[prost(message, tag = "200")]
        AuthenticatorStateCreate(()),
        /// Create and initialize the randomness object.
        #[prost(message, tag = "201")]
        RandomnessStateCreate(()),
        /// Create and initialize the deny list object.
        #[prost(message, tag = "202")]
        DenyListStateCreate(()),
        /// Create and initialize the bridge object.
        #[prost(message, tag = "203")]
        BridgeStateCreate(super::Digest),
        /// Initialize the bridge committee.
        #[prost(uint64, tag = "204")]
        BridgeCommitteeInit(u64),
    }
}
/// Expire old JWKs.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AuthenticatorStateExpire {
    /// Expire JWKs that have a lower epoch than this.
    #[prost(uint64, optional, tag = "1")]
    pub min_epoch: ::core::option::Option<u64>,
    /// The initial version of the authenticator object that it was shared at.
    #[prost(uint64, optional, tag = "2")]
    pub authenticator_object_initial_shared_version: ::core::option::Option<u64>,
}
/// The output or effects of executing a transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionEffects {
    #[prost(oneof = "transaction_effects::Version", tags = "1, 2")]
    pub version: ::core::option::Option<transaction_effects::Version>,
}
/// Nested message and enum types in `TransactionEffects`.
pub mod transaction_effects {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(super::TransactionEffectsV1),
        #[prost(message, tag = "2")]
        V2(super::TransactionEffectsV2),
    }
}
/// Version 1 of `TransactionEffects`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionEffectsV1 {
    /// The status of the execution.
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<ExecutionStatus>,
    /// The epoch when this transaction was executed.
    #[prost(uint64, optional, tag = "2")]
    pub epoch: ::core::option::Option<u64>,
    /// The gas used by this transaction.
    #[prost(message, optional, tag = "3")]
    pub gas_used: ::core::option::Option<GasCostSummary>,
    /// The version that every modified (mutated or deleted) object had before it was modified by
    /// this transaction.
    #[prost(message, repeated, tag = "4")]
    pub modified_at_versions: ::prost::alloc::vec::Vec<ModifiedAtVersion>,
    /// The object references of the shared objects used in this transaction. Empty if no shared objects were used.
    #[prost(message, repeated, tag = "5")]
    pub shared_objects: ::prost::alloc::vec::Vec<ObjectReference>,
    /// The transaction digest.
    #[prost(message, optional, tag = "6")]
    pub transaction_digest: ::core::option::Option<Digest>,
    /// `ObjectReference` and owner of new objects created.
    #[prost(message, repeated, tag = "7")]
    pub created: ::prost::alloc::vec::Vec<ObjectReferenceWithOwner>,
    /// `ObjectReference` and owner of mutated objects, including gas object.
    #[prost(message, repeated, tag = "8")]
    pub mutated: ::prost::alloc::vec::Vec<ObjectReferenceWithOwner>,
    /// `ObjectReference` and owner of objects that are unwrapped in this transaction.
    /// Unwrapped objects are objects that were wrapped into other objects in the past,
    /// and just got extracted out.
    #[prost(message, repeated, tag = "9")]
    pub unwrapped: ::prost::alloc::vec::Vec<ObjectReferenceWithOwner>,
    /// Object refs of objects now deleted (the new refs).
    #[prost(message, repeated, tag = "10")]
    pub deleted: ::prost::alloc::vec::Vec<ObjectReference>,
    /// Object refs of objects previously wrapped in other objects but now deleted.
    #[prost(message, repeated, tag = "11")]
    pub unwrapped_then_deleted: ::prost::alloc::vec::Vec<ObjectReference>,
    /// Object refs of objects now wrapped in other objects.
    #[prost(message, repeated, tag = "12")]
    pub wrapped: ::prost::alloc::vec::Vec<ObjectReference>,
    /// The updated gas object reference. Have a dedicated field for convenient access.
    /// It's also included in mutated.
    #[prost(message, optional, tag = "13")]
    pub gas_object: ::core::option::Option<ObjectReferenceWithOwner>,
    /// The digest of the events emitted during execution,
    /// can be `None` if the transaction does not emit any event.
    #[prost(message, optional, tag = "14")]
    pub events_digest: ::core::option::Option<Digest>,
    /// The set of transaction digests this transaction depends on.
    #[prost(message, repeated, tag = "15")]
    pub dependencies: ::prost::alloc::vec::Vec<Digest>,
}
/// An object reference with owner information.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectReferenceWithOwner {
    /// Required. `ObjectReference`.
    #[prost(message, optional, tag = "1")]
    pub reference: ::core::option::Option<ObjectReference>,
    /// Required. `Owner`.
    #[prost(message, optional, tag = "2")]
    pub owner: ::core::option::Option<Owner>,
}
/// Indicates that an object was modified at a specific version.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModifiedAtVersion {
    /// Required. `ObjectId` of the object.
    #[prost(message, optional, tag = "1")]
    pub object_id: ::core::option::Option<ObjectId>,
    /// Required. Version of the object prior to this transaction.
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
}
/// Version 2 of `TransactionEffects`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionEffectsV2 {
    /// The status of the execution.
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<ExecutionStatus>,
    /// The epoch when this transaction was executed.
    #[prost(uint64, optional, tag = "2")]
    pub epoch: ::core::option::Option<u64>,
    /// The gas used by this transaction.
    #[prost(message, optional, tag = "3")]
    pub gas_used: ::core::option::Option<GasCostSummary>,
    /// The transaction digest.
    #[prost(message, optional, tag = "4")]
    pub transaction_digest: ::core::option::Option<Digest>,
    /// The updated gas object reference, as an index into the `changed_objects` vector.
    /// Having a dedicated field for convenient access.
    /// System transaction that don't require gas will leave this as `None`.
    #[prost(uint32, optional, tag = "5")]
    pub gas_object_index: ::core::option::Option<u32>,
    /// The digest of the events emitted during execution,
    /// can be `None` if the transaction does not emit any event.
    #[prost(message, optional, tag = "6")]
    pub events_digest: ::core::option::Option<Digest>,
    /// The set of transaction digests this transaction depends on.
    #[prost(message, repeated, tag = "7")]
    pub dependencies: ::prost::alloc::vec::Vec<Digest>,
    /// The version number of all the written Move objects by this transaction.
    #[prost(uint64, optional, tag = "8")]
    pub lamport_version: ::core::option::Option<u64>,
    /// Objects whose state are changed in the object store.
    #[prost(message, repeated, tag = "9")]
    pub changed_objects: ::prost::alloc::vec::Vec<ChangedObject>,
    /// Shared objects that are not mutated in this transaction. Unlike owned objects,
    /// read-only shared objects' version are not committed in the transaction,
    /// and in order for a node to catch up and execute it without consensus sequencing,
    /// the version needs to be committed in the effects.
    #[prost(message, repeated, tag = "10")]
    pub unchanged_shared_objects: ::prost::alloc::vec::Vec<UnchangedSharedObject>,
    /// Auxiliary data that are not protocol-critical, generated as part of the effects but are stored separately.
    /// Storing it separately allows us to avoid bloating the effects with data that are not critical.
    /// It also provides more flexibility on the format and type of the data.
    #[prost(message, optional, tag = "11")]
    pub auxiliary_data_digest: ::core::option::Option<Digest>,
}
/// / Input/output state of an object that was changed during execution.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangedObject {
    /// Required. ID of the object.
    #[prost(message, optional, tag = "1")]
    pub object_id: ::core::option::Option<ObjectId>,
    /// Required. State of the object in the store prior to this transaction.
    #[prost(oneof = "changed_object::InputState", tags = "2, 3")]
    pub input_state: ::core::option::Option<changed_object::InputState>,
    /// Required. State of the object in the store after this transaction.
    #[prost(oneof = "changed_object::OutputState", tags = "4, 5, 6")]
    pub output_state: ::core::option::Option<changed_object::OutputState>,
    /// Required. What happened to an `ObjectId` during execution.
    #[prost(oneof = "changed_object::IdOperation", tags = "7, 8, 9")]
    pub id_operation: ::core::option::Option<changed_object::IdOperation>,
}
/// Nested message and enum types in `ChangedObject`.
pub mod changed_object {
    /// Required. State of the object in the store prior to this transaction.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum InputState {
        /// Object did not exist prior to this transaction.
        #[prost(message, tag = "2")]
        NotExist(()),
        /// Object existed prior to this transaction.
        #[prost(message, tag = "3")]
        Exist(super::ObjectExist),
    }
    /// Required. State of the object in the store after this transaction.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum OutputState {
        /// Object was removed from the store due to this transaction.
        #[prost(message, tag = "4")]
        Removed(()),
        /// Object was written, including all of mutated, created, unwrapped.
        #[prost(message, tag = "5")]
        ObjectWrite(super::ObjectWrite),
        /// Package was written.
        #[prost(message, tag = "6")]
        PackageWrite(super::PackageWrite),
    }
    /// Required. What happened to an `ObjectId` during execution.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum IdOperation {
        #[prost(message, tag = "7")]
        None(()),
        #[prost(message, tag = "8")]
        Created(()),
        #[prost(message, tag = "9")]
        Deleted(()),
    }
}
/// Information about the old version of the object.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectExist {
    /// Required. Version of the object.
    #[prost(uint64, optional, tag = "1")]
    pub version: ::core::option::Option<u64>,
    /// Required. Digest of the object.
    #[prost(message, optional, tag = "2")]
    pub digest: ::core::option::Option<Digest>,
    /// Required. Owner of the object.
    #[prost(message, optional, tag = "3")]
    pub owner: ::core::option::Option<Owner>,
}
/// Object write, including all of mutated, created, unwrapped.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectWrite {
    /// Required. Digest of the new version of the object.
    #[prost(message, optional, tag = "2")]
    pub digest: ::core::option::Option<Digest>,
    /// Required. Owner of the new version of the object.
    #[prost(message, optional, tag = "3")]
    pub owner: ::core::option::Option<Owner>,
}
/// Package write.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackageWrite {
    /// Version of the new package.
    #[prost(uint64, optional, tag = "1")]
    pub version: ::core::option::Option<u64>,
    /// Required. Digest of the new package.
    #[prost(message, optional, tag = "2")]
    pub digest: ::core::option::Option<Digest>,
}
/// A shared object that wasn't changed during execution.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnchangedSharedObject {
    /// Required. ObjectId of the shared object.
    #[prost(message, optional, tag = "1")]
    pub object_id: ::core::option::Option<ObjectId>,
    #[prost(oneof = "unchanged_shared_object::Kind", tags = "2, 3, 4, 5, 6")]
    pub kind: ::core::option::Option<unchanged_shared_object::Kind>,
}
/// Nested message and enum types in `UnchangedSharedObject`.
pub mod unchanged_shared_object {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// Read-only shared object from the input.
        #[prost(message, tag = "2")]
        ReadOnlyRoot(super::ReadOnlyRoot),
        /// Deleted shared objects that appear mutably/owned in the input.
        #[prost(uint64, tag = "3")]
        MutateDeleted(u64),
        /// Deleted shared objects that appear as read-only in the input.
        #[prost(uint64, tag = "4")]
        ReadDeleted(u64),
        /// Shared objects that was congested and resulted in this transaction being
        /// cancelled.
        #[prost(uint64, tag = "5")]
        Cancelled(u64),
        /// Read of a per-epoch config object that should remain the same during an epoch.
        #[prost(message, tag = "6")]
        PerEpochConfig(()),
    }
}
/// Read-only shared object from the input.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadOnlyRoot {
    /// Required. Version of the shared object.
    #[prost(uint64, optional, tag = "1")]
    pub version: ::core::option::Option<u64>,
    /// Required. Digest of the shared object.
    #[prost(message, optional, tag = "2")]
    pub digest: ::core::option::Option<Digest>,
}
/// / The status of an executed transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionStatus {
    /// Required. Indicates if the transaction was successful or not.
    #[prost(bool, optional, tag = "1")]
    pub success: ::core::option::Option<bool>,
    /// Optional. The error if `success` is false.
    #[prost(message, optional, tag = "2")]
    pub status: ::core::option::Option<FailureStatus>,
}
/// A size error.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SizeError {
    /// Required. The offending size.
    #[prost(uint64, optional, tag = "1")]
    pub size: ::core::option::Option<u64>,
    /// Required. The maximum allowable size.
    #[prost(uint64, optional, tag = "2")]
    pub max_size: ::core::option::Option<u64>,
}
/// Error that occurred in Move.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveError {
    /// Location in Move where the error occurred.
    #[prost(message, optional, tag = "1")]
    pub location: ::core::option::Option<MoveLocation>,
    /// Abort code from Move.
    #[prost(uint64, optional, tag = "2")]
    pub abort_code: ::core::option::Option<u64>,
}
/// An error that can occur during the execution of a transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailureStatus {
    /// The command, if any, during which the error occurred.
    #[prost(uint64, optional, tag = "1")]
    pub command: ::core::option::Option<u64>,
    #[prost(
        oneof = "failure_status::ExecutionError",
        tags = "2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38"
    )]
    pub execution_error: ::core::option::Option<failure_status::ExecutionError>,
}
/// Nested message and enum types in `FailureStatus`.
pub mod failure_status {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ExecutionError {
        /// Insufficient gas.
        #[prost(message, tag = "2")]
        InsufficientGas(()),
        /// Invalid `Gas` object.
        #[prost(message, tag = "3")]
        InvalidGasObject(()),
        /// Invariant violation.
        #[prost(message, tag = "4")]
        InvariantViolation(()),
        /// Attempted to use feature that is not supported yet.
        #[prost(message, tag = "5")]
        FeatureNotYetSupported(()),
        /// Move object is larger than the maximum allowed size.
        #[prost(message, tag = "6")]
        ObjectTooBig(super::SizeError),
        /// Package is larger than the maximum allowed size.
        #[prost(message, tag = "7")]
        PackageTooBig(super::SizeError),
        /// Circular object ownership.
        #[prost(message, tag = "8")]
        CircularObjectOwnership(super::ObjectId),
        ///
        /// Coin errors.
        ///
        /// Insufficient coin balance for requested operation.
        #[prost(message, tag = "9")]
        InsufficientCoinBalance(()),
        /// Coin balance overflowed an u64.
        #[prost(message, tag = "10")]
        CoinBalanceOverflow(()),
        ///
        /// Publish/Upgrade errors.
        ///
        /// Publish error, non-zero address.
        /// The modules in the package must have their self-addresses set to zero.
        #[prost(message, tag = "11")]
        PublishErrorNonZeroAddress(()),
        /// Sui Move bytecode verification error.
        #[prost(message, tag = "12")]
        SuiMoveVerificationError(()),
        ///
        /// MoveVm errors.
        ///
        /// Error from a non-abort instruction.
        /// Possible causes:
        ///      Arithmetic error, stack overflow, max value depth, or similar.
        #[prost(message, tag = "13")]
        MovePrimitiveRuntimeError(super::MoveError),
        /// Move runtime abort.
        #[prost(message, tag = "14")]
        MoveAbort(super::MoveError),
        /// Bytecode verification error.
        #[prost(message, tag = "15")]
        VmVerificationOrDeserializationError(()),
        /// MoveVm invariant violation.
        #[prost(message, tag = "16")]
        VmInvariantViolation(()),
        ///
        /// Programmable transaction errors.
        ///
        /// Function not found.
        #[prost(message, tag = "17")]
        FunctionNotFound(()),
        /// Parity mismatch for Move function.
        /// The number of arguments does not match the number of parameters.
        #[prost(message, tag = "18")]
        ArityMismatch(()),
        /// Type parity mismatch for Move function.
        /// Mismatch between the number of actual versus expected type arguments.
        #[prost(message, tag = "19")]
        TypeArityMismatch(()),
        /// Non-entry function invoked. Move Call must start with an entry function.
        #[prost(message, tag = "20")]
        NonEntryFunctionInvoked(()),
        /// Invalid command argument.
        #[prost(message, tag = "21")]
        CommandArgumentError(super::CommandArgumentError),
        /// Type argument error.
        #[prost(message, tag = "22")]
        TypeArgumentError(super::TypeArgumentError),
        /// Unused result without the drop ability.
        #[prost(message, tag = "23")]
        UnusedValueWithoutDrop(super::NestedResult),
        /// Invalid public Move function signature.
        /// Unsupported return type for return value.
        #[prost(uint32, tag = "24")]
        InvalidPublicFunctionReturnType(u32),
        /// Invalid transfer object, object does not have public transfer.
        #[prost(message, tag = "25")]
        InvalidTransferObject(()),
        ///
        /// Post-execution errors.
        ///
        /// Effects from the transaction are too large.
        #[prost(message, tag = "26")]
        EffectsTooLarge(super::SizeError),
        /// Publish or Upgrade is missing dependency.
        #[prost(message, tag = "27")]
        PublishUpgradeMissingDependency(()),
        /// Publish or upgrade dependency downgrade.
        ///
        /// Indirect (transitive) dependency of published or upgraded package has been assigned an
        /// on-chain version that is less than the version required by one of the package's
        /// transitive dependencies.
        #[prost(message, tag = "28")]
        PublishUpgradeDependencyDowngrade(()),
        /// Invalid package upgrade.
        #[prost(message, tag = "29")]
        PackageUpgradeError(super::PackageUpgradeError),
        /// Indicates the transaction tried to write objects too large to storage.
        #[prost(message, tag = "30")]
        WrittenObjectsTooLarge(super::SizeError),
        /// Certificate is on the deny list.
        #[prost(message, tag = "31")]
        CertificateDenied(()),
        /// Sui Move bytecode verification timed out.
        #[prost(message, tag = "32")]
        SuiMoveVerificationTimedout(()),
        /// The requested shared object operation is not allowed.
        #[prost(message, tag = "33")]
        SharedObjectOperationNotAllowed(()),
        /// Requested shared object has been deleted.
        #[prost(message, tag = "34")]
        InputObjectDeleted(()),
        /// Certificate is cancelled due to congestion on shared objects.
        #[prost(message, tag = "35")]
        ExecutionCancelledDueToSharedObjectCongestion(super::CongestedObjectsError),
        /// Address is denied for this coin type.
        #[prost(message, tag = "36")]
        AddressDeniedForCoin(super::AddressDeniedForCoinError),
        /// Coin type is globally paused for use.
        #[prost(string, tag = "37")]
        CoinTypeGlobalPause(::prost::alloc::string::String),
        /// Certificate is cancelled because randomness could not be generated this epoch.
        #[prost(message, tag = "38")]
        ExecutionCancelledDueToRandomnessUnavailable(()),
    }
}
/// Address is denied for this coin type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddressDeniedForCoinError {
    /// Required. Denied address.
    #[prost(message, optional, tag = "1")]
    pub address: ::core::option::Option<Address>,
    /// Required. Coin type.
    #[prost(string, optional, tag = "2")]
    pub coin_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Set of objects that were congested, leading to the transaction's cancellation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CongestedObjectsError {
    /// Set of congested objects.
    #[prost(message, repeated, tag = "1")]
    pub congested_objects: ::prost::alloc::vec::Vec<ObjectId>,
}
/// / Location in Move bytecode where an error occurred.s
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveLocation {
    /// Required. The package ID.
    #[prost(message, optional, tag = "1")]
    pub package: ::core::option::Option<ObjectId>,
    /// Required. The module name.
    #[prost(message, optional, tag = "2")]
    pub module: ::core::option::Option<Identifier>,
    /// Required. The function index.
    #[prost(uint32, optional, tag = "3")]
    pub function: ::core::option::Option<u32>,
    /// Required. Offset of the instruction where the error occurred.
    #[prost(uint32, optional, tag = "4")]
    pub instruction: ::core::option::Option<u32>,
    /// Optional. The name of the function, if available.
    #[prost(message, optional, tag = "5")]
    pub function_name: ::core::option::Option<Identifier>,
}
/// An error with an argument to a command.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CommandArgumentError {
    /// Required. Position of the problematic argument.
    #[prost(uint32, optional, tag = "1")]
    pub argument: ::core::option::Option<u32>,
    #[prost(
        oneof = "command_argument_error::Kind",
        tags = "2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13"
    )]
    pub kind: ::core::option::Option<command_argument_error::Kind>,
}
/// Nested message and enum types in `CommandArgumentError`.
pub mod command_argument_error {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// The type of the value does not match the expected type.
        #[prost(message, tag = "2")]
        TypeMismatch(()),
        /// The argument cannot be deserialized into a value of the specified type.
        #[prost(message, tag = "3")]
        InvalidBcsBytes(()),
        /// The argument cannot be instantiated from raw bytes.
        #[prost(message, tag = "4")]
        InvalidUsageOfPureArgument(()),
        /// Invalid argument to private entry function.
        /// Private entry functions cannot take arguments from other Move functions.
        #[prost(message, tag = "5")]
        InvalidArgumentToPrivateEntryFunction(()),
        /// Out of bounds access to input or results.
        #[prost(uint32, tag = "6")]
        IndexOutOfBounds(u32),
        /// Out of bounds access to subresult.
        #[prost(message, tag = "7")]
        SecondaryIndexOutOfBounds(super::NestedResult),
        /// Invalid usage of result.
        /// Expected a single result but found either no return value or multiple.
        #[prost(uint32, tag = "8")]
        InvalidResultArity(u32),
        /// Invalid usage of gas coin.
        /// The gas coin can only be used by-value with a `TransferObject` command.
        #[prost(message, tag = "9")]
        InvalidGasCoinUsage(()),
        /// Invalid usage of Move value.
        ///     - Mutably borrowed values require unique usage.
        ///     - Immutably borrowed values cannot be taken or borrowed mutably.
        ///     - Taken values cannot be used again.
        #[prost(message, tag = "10")]
        InvalidValueUsage(()),
        /// Immutable objects cannot be passed by-value.
        #[prost(message, tag = "11")]
        InvalidObjectByValue(()),
        /// Immutable objects cannot be passed by mutable reference, `&mut`.
        #[prost(message, tag = "12")]
        InvalidObjectByMutRef(()),
        /// Shared object operations such as wrapping, freezing, or converting to owned are not
        /// allowed.
        #[prost(message, tag = "13")]
        SharedObjectOperationNotAllowed(()),
    }
}
/// An error with a upgrading a package.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackageUpgradeError {
    #[prost(oneof = "package_upgrade_error::Kind", tags = "2, 3, 4, 5, 6, 7")]
    pub kind: ::core::option::Option<package_upgrade_error::Kind>,
}
/// Nested message and enum types in `PackageUpgradeError`.
pub mod package_upgrade_error {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// Unable to fetch package.
        #[prost(message, tag = "2")]
        UnableToFetchPackage(super::ObjectId),
        /// Object is not a package.
        #[prost(message, tag = "3")]
        NotAPackage(super::ObjectId),
        /// Package upgrade is incompatible with previous version.
        #[prost(message, tag = "4")]
        IncompatibleUpgrade(()),
        /// Digest in upgrade ticket and computed digest differ.
        #[prost(message, tag = "5")]
        DigetsDoesNotMatch(super::Digest),
        /// Upgrade policy is not valid.
        #[prost(uint32, tag = "6")]
        UnknownUpgradePolicy(u32),
        /// Package ID does not match `PackageId` in upgrade ticket.
        #[prost(message, tag = "7")]
        PackageIdDoesNotMatch(super::PackageIdDoesNotMatch),
    }
}
/// Package ID does not match `PackageId` in upgrade ticket.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackageIdDoesNotMatch {
    /// Required. The package ID.
    #[prost(message, optional, tag = "1")]
    pub package_id: ::core::option::Option<ObjectId>,
    /// Required. The ticket ID.
    #[prost(message, optional, tag = "2")]
    pub ticket_id: ::core::option::Option<ObjectId>,
}
/// Type argument error.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TypeArgumentError {
    /// Required. Index of the problematic type argument.
    #[prost(uint32, optional, tag = "1")]
    pub type_argument: ::core::option::Option<u32>,
    #[prost(oneof = "type_argument_error::Kind", tags = "2, 3")]
    pub kind: ::core::option::Option<type_argument_error::Kind>,
}
/// Nested message and enum types in `TypeArgumentError`.
pub mod type_argument_error {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// A type was not found in the module specified.
        #[prost(message, tag = "2")]
        TypeNotFound(()),
        /// A type provided did not match the specified constraint.
        #[prost(message, tag = "3")]
        ConstraintNotSatisfied(()),
    }
}
/// A signature from a user.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserSignature {
    #[prost(oneof = "user_signature::Signature", tags = "1, 2, 3, 4")]
    pub signature: ::core::option::Option<user_signature::Signature>,
}
/// Nested message and enum types in `UserSignature`.
pub mod user_signature {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Signature {
        #[prost(message, tag = "1")]
        Simple(super::SimpleSignature),
        #[prost(message, tag = "2")]
        Multisig(super::MultisigAggregatedSignature),
        #[prost(message, tag = "3")]
        Zklogin(super::ZkLoginAuthenticator),
        #[prost(message, tag = "4")]
        Passkey(super::PasskeyAuthenticator),
    }
}
/// A basic signature.
///
/// Can either be an ed25519, secp256k1, or secp256r1 signature with
/// corresponding public key.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimpleSignature {
    /// The signature scheme of the signautre and public key, which should be an
    /// enum value of [sui.types.SignatureScheme][sui.types.SignatureScheme]
    #[prost(int32, optional, tag = "1")]
    pub scheme: ::core::option::Option<i32>,
    /// Signature bytes.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub signature: ::core::option::Option<::prost::bytes::Bytes>,
    /// Public key bytes.
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub public_key: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Public key equivalent for zklogin authenticators.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginPublicIdentifier {
    /// Required.
    #[prost(string, optional, tag = "1")]
    pub iss: ::core::option::Option<::prost::alloc::string::String>,
    /// Required.
    #[prost(message, optional, tag = "2")]
    pub address_seed: ::core::option::Option<Bn254FieldElement>,
}
/// Set of valid public keys for multisig committee members.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigMemberPublicKey {
    #[prost(oneof = "multisig_member_public_key::Scheme", tags = "1, 2, 3, 4")]
    pub scheme: ::core::option::Option<multisig_member_public_key::Scheme>,
}
/// Nested message and enum types in `MultisigMemberPublicKey`.
pub mod multisig_member_public_key {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Scheme {
        /// An ed25519 public key
        #[prost(bytes, tag = "1")]
        Ed25519(::prost::bytes::Bytes),
        /// A secp256k1 public key
        #[prost(bytes, tag = "2")]
        Secp256k1(::prost::bytes::Bytes),
        /// A secp256r1 public key
        #[prost(bytes, tag = "3")]
        Secp256r1(::prost::bytes::Bytes),
        /// A zklogin public identifier
        #[prost(message, tag = "4")]
        Zklogin(super::ZkLoginPublicIdentifier),
    }
}
/// A member in a multisig committee.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigMember {
    /// Required. The public key of the committee member.
    #[prost(message, optional, tag = "1")]
    pub public_key: ::core::option::Option<MultisigMemberPublicKey>,
    /// Required. The weight of this member's signature.
    #[prost(uint32, optional, tag = "2")]
    pub weight: ::core::option::Option<u32>,
}
/// A multisig committee.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigCommittee {
    /// A list of committee members and their corresponding weight.
    #[prost(message, repeated, tag = "1")]
    pub members: ::prost::alloc::vec::Vec<MultisigMember>,
    /// Required. The threshold of signatures needed to validate a signature from
    /// this committee.
    #[prost(uint32, optional, tag = "2")]
    pub threshold: ::core::option::Option<u32>,
}
/// Aggregated signature from members of a multisig committee.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigAggregatedSignature {
    /// The plain signatures encoded with signature scheme.
    ///
    /// The signatures must be in the same order as they are listed in the committee.
    #[prost(message, repeated, tag = "1")]
    pub signatures: ::prost::alloc::vec::Vec<MultisigMemberSignature>,
    /// Required. Bitmap indicating which committee members contributed to the
    /// signature.
    #[prost(uint32, optional, tag = "2")]
    pub bitmap: ::core::option::Option<u32>,
    /// Optional. If present, means this signature's on-chain format uses the old
    /// legacy multisig format.
    #[prost(message, optional, tag = "3")]
    pub legacy_bitmap: ::core::option::Option<RoaringBitmap>,
    /// Required. The committee to use to validate this signature.
    #[prost(message, optional, tag = "4")]
    pub committee: ::core::option::Option<MultisigCommittee>,
}
/// A signature from a member of a multisig committee.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigMemberSignature {
    #[prost(oneof = "multisig_member_signature::Signature", tags = "1, 2, 3, 4")]
    pub signature: ::core::option::Option<multisig_member_signature::Signature>,
}
/// Nested message and enum types in `MultisigMemberSignature`.
pub mod multisig_member_signature {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Signature {
        /// An ed25519 signature.
        #[prost(bytes, tag = "1")]
        Ed25519(::prost::bytes::Bytes),
        /// A secp256k1 signature.
        #[prost(bytes, tag = "2")]
        Secp256k1(::prost::bytes::Bytes),
        /// A secp256r1 signature.
        #[prost(bytes, tag = "3")]
        Secp256r1(::prost::bytes::Bytes),
        /// A zklogin signature.
        #[prost(message, tag = "4")]
        Zklogin(super::ZkLoginAuthenticator),
    }
}
/// A zklogin authenticator.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginAuthenticator {
    /// Required. Zklogin proof and inputs required to perform proof verification.
    #[prost(message, optional, tag = "1")]
    pub inputs: ::core::option::Option<ZkLoginInputs>,
    /// Required. Maximum epoch for which the proof is valid.
    #[prost(uint64, optional, tag = "2")]
    pub max_epoch: ::core::option::Option<u64>,
    /// Required. User signature with the public key attested to by the provided proof.
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<SimpleSignature>,
}
/// A zklogin groth16 proof and the required inputs to perform proof verification.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginInputs {
    /// Required.
    #[prost(message, optional, tag = "1")]
    pub proof_points: ::core::option::Option<ZkLoginProof>,
    /// Required.
    #[prost(message, optional, tag = "2")]
    pub iss_base64_details: ::core::option::Option<ZkLoginClaim>,
    /// Required.
    #[prost(string, optional, tag = "3")]
    pub header_base64: ::core::option::Option<::prost::alloc::string::String>,
    /// Required.
    #[prost(message, optional, tag = "4")]
    pub address_seed: ::core::option::Option<Bn254FieldElement>,
}
/// A zklogin groth16 proof.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginProof {
    /// Required.
    #[prost(message, optional, tag = "1")]
    pub a: ::core::option::Option<CircomG1>,
    /// Required.
    #[prost(message, optional, tag = "2")]
    pub b: ::core::option::Option<CircomG2>,
    /// Required.
    #[prost(message, optional, tag = "3")]
    pub c: ::core::option::Option<CircomG1>,
}
/// A claim of the iss in a zklogin proof.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginClaim {
    /// Required.
    #[prost(string, optional, tag = "1")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
    /// Required.
    #[prost(uint32, optional, tag = "2")]
    pub index_mod_4: ::core::option::Option<u32>,
}
/// A G1 point.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CircomG1 {
    /// Required.
    #[prost(message, optional, tag = "1")]
    pub e0: ::core::option::Option<Bn254FieldElement>,
    /// Required.
    #[prost(message, optional, tag = "2")]
    pub e1: ::core::option::Option<Bn254FieldElement>,
    /// Required.
    #[prost(message, optional, tag = "3")]
    pub e2: ::core::option::Option<Bn254FieldElement>,
}
/// A G2 point.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CircomG2 {
    /// Required.
    #[prost(message, optional, tag = "1")]
    pub e00: ::core::option::Option<Bn254FieldElement>,
    /// Required.
    #[prost(message, optional, tag = "2")]
    pub e01: ::core::option::Option<Bn254FieldElement>,
    /// Required.
    #[prost(message, optional, tag = "3")]
    pub e10: ::core::option::Option<Bn254FieldElement>,
    /// Required.
    #[prost(message, optional, tag = "4")]
    pub e11: ::core::option::Option<Bn254FieldElement>,
    /// Required.
    #[prost(message, optional, tag = "5")]
    pub e20: ::core::option::Option<Bn254FieldElement>,
    /// Required.
    #[prost(message, optional, tag = "6")]
    pub e21: ::core::option::Option<Bn254FieldElement>,
}
/// A point on the BN254 elliptic curve.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bn254FieldElement {
    /// Required. 32-byte big-endian field element.
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub element: ::core::option::Option<::prost::bytes::Bytes>,
}
/// A passkey authenticator.
///
/// See
/// [struct.PasskeyAuthenticator](<https://mystenlabs.github.io/sui-rust-sdk/sui_sdk_types/struct.PasskeyAuthenticator.html#bcs>)
/// for more information on the requirements on the shape of the
/// `client_data_json` field.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PasskeyAuthenticator {
    /// Required. Opaque authenticator data for this passkey signature.
    ///
    /// See [Authenticator Data](<https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data>) for
    /// more information on this field.
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub authenticator_data: ::core::option::Option<::prost::bytes::Bytes>,
    /// Required. Structured, unparsed, JSON for this passkey signature.
    ///
    /// See [CollectedClientData](<https://www.w3.org/TR/webauthn-2/#dictdef-collectedclientdata>)
    /// for more information on this field.
    #[prost(string, optional, tag = "2")]
    pub client_data_json: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. A secp256r1 signature.
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<SimpleSignature>,
}
/// The validator set for a particular epoch.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorCommittee {
    /// Required. The epoch where this committee governs.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// The committee members.
    #[prost(message, repeated, tag = "2")]
    pub members: ::prost::alloc::vec::Vec<ValidatorCommitteeMember>,
}
/// A member of a validator committee.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorCommitteeMember {
    /// Required. The 96-byte Bls12381 public key for this validator.
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub public_key: ::core::option::Option<::prost::bytes::Bytes>,
    /// Required. Stake weight this validator possesses.
    #[prost(uint64, optional, tag = "2")]
    pub stake: ::core::option::Option<u64>,
}
/// / An aggregated signature from multiple validators.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorAggregatedSignature {
    /// Required. The epoch when this signature was produced.
    ///
    /// This can be used to lookup the `ValidatorCommittee` from this epoch
    /// to verify this signature.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// Required. The 48-byte Bls12381 aggregated signature.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub signature: ::core::option::Option<::prost::bytes::Bytes>,
    /// Required. Bitmap indicating which members of the committee contributed to
    /// this signature.
    #[prost(message, optional, tag = "3")]
    pub bitmap: ::core::option::Option<RoaringBitmap>,
}
/// A RoaringBitmap. See
/// [RoaringFormatSpec](<https://github.com/RoaringBitmap/RoaringFormatSpec>) for the
/// specification for the serialized format of `RoaringBitmap`s.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoaringBitmap {
    /// Required. Serialized `RoaringBitmap`.
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub bitmap: ::core::option::Option<::prost::bytes::Bytes>,
}
