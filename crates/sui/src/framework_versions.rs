// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

use std::{collections::BTreeMap, sync::LazyLock};

use anyhow::{bail, Context};
use sui_protocol_config::ProtocolVersion;

pub struct FrameworkVersion {
    git_revision: String,
    framework_package_names: Vec<String>,
}

impl FrameworkVersion {
    pub fn git_revision(&self) -> &String {
        &self.git_revision
    }

    pub fn framework_package_names(&self) -> &Vec<String> {
        &self.framework_package_names
    }
}

/// Static mapping from protocol versions to the metadata for the framework
// Generated by [generate_framework_version_table] in build.rs
static VERSION_TABLE: LazyLock<BTreeMap<ProtocolVersion, FrameworkVersion>> =
    LazyLock::new(|| BTreeMap::from(include!(concat!(env!("OUT_DIR"), "/version_table.rs"))));

/// Return the framework snapshot for the latest known protocol version
pub fn latest_framework() -> &'static FrameworkVersion {
    VERSION_TABLE
        .last_key_value()
        .expect("known framework version table should be nonempty")
        .1
}

/// Return the best commit hash for the given protocol version. Returns an error if [version]
/// is newer than the maximum protocol version or older than the first known framework.
pub fn framework_for_protocol(
    version: ProtocolVersion,
) -> anyhow::Result<&'static FrameworkVersion> {
    if version > ProtocolVersion::MAX {
        bail!("Protocol version {version:?} is newer than this CLI.");
    }

    // There are gaps in the manifest when multiple protocol versions use the same framework
    // version. Therefore, we return the newest framework version that is not newer than the requested
    // protocol version. Note that it's possible that there is no such version if the requested
    // version is older than the oldest framework; we return an error in this case.
    Ok(VERSION_TABLE
        .range(..=version)
        .next_back()
        .context(format!("Unrecognized protocol version {version:?}"))?
        .1)
}

#[test]
/// There is at least one known framework version
fn test_nonempty_version_table() {
    assert!(!VERSION_TABLE.is_empty());
}

#[test]
/// the hash for a specific version that we have one for is corretly returned
fn test_hash_exact() {
    let framework = framework_for_protocol(4.into()).unwrap();
    assert_eq!(
        framework.git_revision(),
        "f5d26f1b3ae89f68cb66f3a007e90065e5286905"
    );
    assert!(framework
        .framework_package_names
        .contains(&"Sui".to_string()));
}

#[test]
/// we get the right hash for a version that we don't have an exact entry for
fn test_hash_gap() {
    // versions 56 and 57 are missing in the manifest; version 55 should be returned
    assert_eq!(
        framework_for_protocol(56.into()).unwrap().git_revision(),
        framework_for_protocol(55.into()).unwrap().git_revision(),
    );
    assert_eq!(
        framework_for_protocol(57.into()).unwrap().git_revision(),
        framework_for_protocol(55.into()).unwrap().git_revision(),
    );
    // version 58 is present though!
    assert_ne!(
        framework_for_protocol(58.into()).unwrap().git_revision(),
        framework_for_protocol(55.into()).unwrap().git_revision(),
    );
}

#[test]
/// we get the correct hash for the latest known protocol version
fn test_hash_latest() {
    assert_eq!(
        framework_for_protocol(ProtocolVersion::MAX)
            .unwrap()
            .git_revision(),
        latest_framework().git_revision()
    );
}

#[test]
/// we get an error if the protocol version is too small or too large
fn test_hash_errors() {
    assert!(framework_for_protocol(0.into()).is_err());
    assert!(framework_for_protocol(ProtocolVersion::MAX + 1).is_err());
}
