---
title: Nautilus Design
description: Overview of the design aspects of Nautilus, including its trust model.
---

![image](../images/flows.png)

## dApp developer actions

1. Create a Nautilus off-chain server with a reproducible build using the [provided template](https://github.com/MystenLabs/nautilus).
2. Publish the server code to a public repository like GitHub to ensure transparency and verifiability.
3. Register the instance's platform configuration registers (PCRs) - measurements of the trusted computing base - using a Sui smart contract.
4. Deploy the server to an AWS Nitro Enclave.
5. Register the deployed enclave using a Sui smart contract and attestation document, including the enclave's ephemeral public key for signing responses.

To reduce the trusted computing base, you should route access to the enclave through backend services that handle load balancing, rate limiting, and other related aspects.

:::tip
Verify attestation documents on-chain only during enclave registration due to high gas costs. After registration, use the enclave key for more efficient message verification.
:::

## dApp user / client actions

1. (Optional) Verify the Nautilus off-chain server code by building it locally and confirming that the generated PCRs match the on-chain records.
2. Send a request to the deployed enclave and receive a signed response.
3. Submit the signed response on chain for verification before executing the corresponding application logic.

## Trust model

The attestation document from an AWS Nitro Enclave includes a certificate chain that can be verified on chain using AWS as the root certificate authority. This verification confirms the following:

- The enclave instance is running unmodified software, as validated by its PCR values.
- Users can independently verify that the instanceâ€™s computation aligns with the published source code, ensuring transparency and trust.

Reproducible builds allow builders and users to optionally verify that the binary running inside an enclave instance matches a specific version of the source code. This approach provides the following benefits:

- Anyone can build and compare the binary to confirm consistency with the published source code.
- Any changes to the software result in different PCR values, making unauthorized modifications detectable.
- Reproducible builds shift the trust from runtime to build time, strengthening the overall security posture of the dApp.

:::important

Reproducible builds might not apply to all use cases, such as when the source code is not public.

:::
