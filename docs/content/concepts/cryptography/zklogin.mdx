---
title: zkLogin
description: zkLogin is a Sui primitive that enables you to send transactions from a Sui address using an OAuth credential without publicly linking the two.
---

zkLogin is a Sui primitive that allows you to send transactions from a Sui address using an OAuth credential without publicly linking the two.

zkLogin is designed with the following goals:

- **Streamlined onboarding:** zkLogin enables you to transact on Sui using the familiar OAuth login flow, removing the need to handle cryptographic keys or remember mnemonics.
- **Self-custody:** A zkLogin transaction requires user approval through the standard OAuth login process. The OAuth provider cannot transact on your behalf.
- **Security:** zkLogin is a two-factor authentication scheme. Sending a transaction requires both a credential from a recent OAuth login and a salt not managed by the OAuth provider. An attacker who compromises an OAuth account cannot transact from your Sui address unless they also compromise the salt.
- **Privacy:** Zero-knowledge proofs prevent third parties from linking a Sui address with its corresponding OAuth identifier.
- **Optional verified identity:** You can opt in to verify the OAuth identifier used to derive a particular Sui address. This creates the foundation for a verifiable on-chain identity layer.
- **Accessibility:** zkLogin integrates with other Sui primitives, such as sponsored transactions and multisig.
- **Rigor:** The code for zkLogin has been independently [audited](https://github.com/sui-foundation/security-audits/blob/main/docs/zksecurity_zklogin-circuits.pdf) by two firms specializing in zero-knowledge. The public zkLogin ceremony for creating the common reference string included contributions from more than 100 participants.

The key differentiators that zkLogin brings to Sui are:

1. Native support in Sui: Unlike other solutions that are blockchain agnostic, zkLogin is deployed just for Sui. This means a zkLogin transaction can be combined with multisig and sponsored transactions seamlessly.

1. Self-custodial without additional trust: Sui leverages the nonce field in JWT to commit to ephemeral public key, so no persistent private key management is required with any trusted parties. The JWK itself is an oracle agreed upon by the quorum of stakes by the validators without trusting any source of authority.

1. Full privacy: Nothing is required to submit on-chain except the zero-knowledge proof and the ephemeral signature.

1. Compatible with existing identity providers: zkLogin is compatible with providers that adopt OpenID Connect, meaning you do no need to trust any intermediate identity issuers or verifiers other than the OAuth providers themselves.

If you are a builder who wants to integrate zkLogin into your application or wallet, see the [zkLogin integration guide](/guides/developer/cryptography/zklogin-integration.mdx).

## OpenID providers

<ImportContent source="openid-providers.mdx" mode="snippet" />

## Terminology and notations

This section describes relevant OpenID terminology defined in [the OpenID specification](https://openid.net/specs/openid-connect-core-1_0.html#Terminology) and how they are used in zkLogin, along with definitions for protocol details.

### OpenID provider (OP)

An OpenID provider is an OAuth 2.0 authorization server that is capable of authenticating an end-user and providing claims to a relying party about the authentication event and the end-user. This is identified in the `iss` field in JSON web token payload. Check the [table of available OPs](#openid-providers) for the entities zkLogin currently supports.

### Relying party (RP) or client

A relying party is an OAuth 2.0 client application that requires end-user authentication and claims from an OpenID provider. This is assigned by an OP when you create an application. This is identified in the `aud` field in JWT payload and refers to any zkLogin enabled wallet or application.

### Subject identifier (sub)

The subject identifier is a locally unique identifier within the issuer for the end user, which the RP is intended to consume. Sui uses this as the key claim to derive a user address.

### JSON Web Key (JWK)

A JSON Web Key is a JSON data structure that represents a set of public keys for an OP. A public endpoint (as in https://www.googleapis.com/oauth2/v3/certs) can be queried to retrieve the valid public keys corresponding to `kid` for the provider. Upon matching with the `kid` in the header of a JWT, the JWT can be verified against the payload and its corresponding JWK. In Sui, all authorities call the JWK endpoints independently, and the latest view of JWKs for all supported providers is updated during protocol upgrades. The correctness of JWKs is guaranteed by the quorum (2f+1) of validator stake.

### JSON Web Token (JWT)

A JSON Web Token is in the redirect URI to the RP after you complete the OAuth login flow (as in `https://redirect.com?id_token=$JWT_TOKEN`). The JWT contains a `header`, `payload`, and a `signature`. The signature is an RSA signature verified against `jwt_message = header + . + payload` and its JWK identified by `kid`. The `payload` contains a JSON of many claims that is a name-value pair. 

**Header**

| Name | Example Value                            | Usage                                                     |
| ---- | ---------------------------------------- | --------------------------------------------------------- |
| `alg`  | RS256                                    | zkLogin only supports RS256 (RSA + SHA-256).            |
| `kid`  | c3afe7a9bda46bae6ef97e46c95cda48912e5979 | Identifies the JWK that should be used to verify the JWT. |
| `typ`  | JWT                                      | zkLogin only supports JWT.                              |

**Payload**

| Name  | Example Value                                                            | Usage                                                                                                                                                      |
| ----- | ------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `iss`   | https://accounts.google.com                                              | A unique identifier assigned to the OAuth provider.                                                                                                        |
| `aud`   | 575519200000-msop9ep45u2uo98hapqmngv8d8000000.apps.googleusercontent.com | A unique identifier assigned to the relying party by the OAuth provider.                                                                                   |
| `nonce` | hTPpgF7XAKbW37rEUS6pEVZqmoI                                              | A value set by the relying party. The zkLogin enabled wallet is required to set this to the hash of ephemeral public key, an expiry time and a randomness. |
| `sub`   | 110463452167303000000                                                    | A unique identifier assigned to the user.                                                                                                                  |

For a zkLogin transaction, the `iat` and `exp` claims (timestamp) are not used. Instead, the `nonce` specifies expiry times.

### Key claim

The key claim used to derive your address, such as `sub` or `email`. Naturally, it's ideal to use claims that are fixed once and never changed again. zkLogin currently supports `sub` as the key claim because the OpenID specification mandates that providers do not change this identifier. 

### Notations

1. `(eph_sk, eph_pk)`: The private and public key pair used to produce ephemeral signatures. The signing mechanism is the same as traditional transaction signing, but it is ephemeral because it is only stored for a short session and can be refreshed upon new OAuth sessions. The ephemeral public key is used to compute the `nonce`.

2. `nonce`: An application-defined field embedded in the JWT payload, computed as the hash of the ephemeral public key, JWT randomness, and the maximum epoch (Sui's defined expiry epoch). Specifically, a zkLogin compatible nonce is required to passed in as `nonce = ToBase64URL(Poseidon_BN254([ext_eph_pk_bigint / 2^128, ext_eph_pk_bigint % 2^128, max_epoch, jwt_randomness]).to_bytes()[len - 20..])` where `ext_eph_pk_bigint` is the BigInt representation of `ext_eph_pk`.

3. `ext_eph_pk`: The byte representation of an ephemeral public key (`flag || eph_pk`). Size varies depending on the choice of the signature scheme (denoted by the flag, defined in [Signatures](/concepts/transactions/transaction-auth.mdx)).

4. `user_salt`: A value introduced to unlink the OAuth identifier with the on-chain address.

5. `max_epoch`: The epoch at which the JWT expires. This is `u64` used in Sui.

6. `kc_name`: The key claim name, for example `sub`.

7. `kc_value`: The key claim value, for example `110463452167303000000`.

8. `hashBytesToField(str, maxLen)`: Hashes the ASCII string to a field element using the [Poseidon hash](https://eprint.iacr.org/2019/458.pdf).

## Entities

1. Application frontend: This describes the wallet or frontend application that supports zkLogin. The frontend is responsible for storing the ephemeral private key, directing you to complete the OAuth login flow, and creating and signing a zkLogin transaction.

2. Salt backup service: This is a backend service responsible for returning a salt per unique user. See [zkLogin Integration Guide](/guides/developer/cryptography/zklogin-integration.mdx) for other strategies to maintain salt.

3. Zero-knowledge proving service: This is a backend service responsible for generating zero-knowledge proofs based on JWT, JWT randomness, user salt, and max epoch. This proof is submitted on-chain along with the ephemeral signature for a zkLogin transaction.

## How zkLogin works {#how-zklogin-works}

At a high level, the zkLogin protocol works as follows:

1. A JWT is a signed payload from OAuth providers that includes a user-defined field named nonce. zkLogin uses [the OpenID Connect OAuth flow](https://openid.net/developers/how-connect-works/) by defining the nonce as a public key and an expiry epoch.

2. The wallet stores an ephemeral key pair, where the ephemeral public key is defined in the nonce. The ephemeral private key signs transactions for a short session. A Groth16 zero-knowledge proof is generated from the JWT, which conceals sensitive fields.

3. A transaction is submitted on-chain with the ephemeral signature and the zero-knowledge proof. Sui authorities execute the transaction after verifying the ephemeral signature and the proof.

4. Instead of deriving the Sui address based on a public key, the zkLogin address is derived from `sub` (user identifier), `iss` (provider), `aud` (application), and `user_salt` (a value that unlinks the OAuth identifier from the on-chain address).

![zkLogin flow diagram](images/zklogin-flow.png 'zkLogin complete flow')

#### Step 0: zkLogin uses Groth16 for zkSNARK instantiation, which requires a common reference string (CRS) linked to the circuit.

A ceremony generates the CRS, which is used to produce the proving key in the proving service and the verifying key in Sui authorities. See [ceremony](#ceremony) for details.

#### Steps 1-3: Login to an OpenID provider (OP) to obtain a JWT containing a nonce.

An ephemeral key pair `(eph_sk, eph_pk)` is generated and`eph_pk`, expiry times (`max_epoch`), and randomness (`jwt_randomness`) are embedded into the nonce. After login, the JWT appears in the redirect URL in the application.

#### Steps 4-5: The application frontend sends the JWT to a salt service. The service returns the unique `user_salt` based on `iss`, `aud`, and `sub`.

#### Steps 6-7: Send the JWT, user salt, ephemeral public key, JWT randomness, and key claim name (for example, `sub`) to the proving service.

The proving service generates a zero-knowledge proof that:

- Confirms the nonce is derived correctly.

- Confirms the key claim value matches the corresponding JWT field.

- Verifies the RSA signature from the provider on the JWT.

- Confirms the address is consistent with the key claim and user salt.

#### Step 8: The application computes your address based on `iss`, `aud`, and `sub`.

#### Steps 9-10: Sign the transaction with the ephemeral private key and submit it with the ephemeral signature, ZK proof, and other inputs to Sui.

After Step 10, Sui authorities verify the ZK proof against the provider's JWKs (stored by consensus) and the ephemeral signature.

## Address definition

The address is computed on the following inputs:

1. The address flag: `zk_login_flag = 0x05` for zkLogin address. This serves as a domain separator.

1. `kc_name_F = hashBytesToField(kc_name, maxKCNameLen)`: Name of the key claim, for example `sub`. The sequence of bytes is mapped to a field element in BN254 using `hashBytesToField` (defined below).

1. `kc_value_F = hashBytesToField(kc_value, maxKCValueLen)`: The value of the key claim mapped using `hashBytesToField`.

1. `aud_F = hashBytesToField(aud, maxAudValueLen)`: The relying party (RP) identifier.

1. `iss`: The OpenID Provider (OP) identifier.

1. `user_salt`: A value introduced to unlink the OAuth identifier with the on-chain address.

Finally, Sui derives `zk_login_address = Blake2b_256(zk_login_flag, iss_L, iss, addr_seed)` where `addr_seed = Poseidon_BN254(kc_name_F, kc_value_F, aud_F, Poseidon_BN254(user_salt))`.

## Ceremony

To preserve privacy of the OAuth artifacts, a zero-knowledge proof of possession is provided. zkLogin employs the Groth16 [zkSNARK](https://en.wikipedia.org/wiki/Non-interactive_zero-knowledge_proof) to instantiate the zero-knowledge proofs, as it is the most efficient general-purpose zkSNARK in terms of proof size and verification efficiency.

However, Groth16 needs a computation-specific common reference string (CRS) to be setup by a trusted party. With zkLogin expected to ensure the safe-keeping of high value transactions and the integrity of critical smart contracts, you cannot base the security of the system on the honesty of a single entity. Hence, to generate the CRS for the zkLogin circuit, it is vital to run a protocol which bases its security on the assumed honesty of a small fraction of a large number of parties.

The Sui zkLogin ceremony is a cryptographic multi-party computation (MPC) performed by a diverse group of participants to generate the CRS. The ceremony follows the MPC protocol [MMORPG](https://eprint.iacr.org/2017/1050.pdf) described by Bowe, Gabizon and Miers. The protocol proceeds in 2 phases. The first phase results in a series of powers of a secret quantity tau in the exponent of an elliptic curve element. Since this phase is circuit-agnostic, the ceremony adopts the result of the existing community contributed [perpetual powers of tau](https://github.com/privacy-scaling-explorations/perpetualpowersoftau/tree/master). The ceremony is the second phase, which is specific to the zkLogin circuit.

The MMORPG protocol is a sequential protocol, which allows an indefinite number of parties to participate in sequence, without the need of any prior synchronization or ordering. Each party needs to download the output of the previous party, generate entropy of its own and then layer it on top of the received result, producing its own contribution which is then relayed to the next party. The protocol guarantees security if at least 1 of the participants follows the protocol faithfully, generates strong entropy, and discards it reliably.

### How was the ceremony performed?

Invitations were sent to more than 100 people with diverse backgrounds and affiliations: Sui validators, cryptographers, Web3 experts, world-renowned academicians, and business leaders. The ceremony was planned to take place on the dates September 12-18, 2023, but allowed participants to join when they wanted with no fixed slots.

Since the MPC is sequential, each contributor needed to wait until the previous contributor finished in order to receive the previous contribution, follow the MPC steps and produce their own contribution. Due to this structure, a queue was provisioned where participants waited, while those who joined before them finished. To authenticate participants, a unique activation code was sent to each of them. The activation code was the secret key of a signing key pair, which had a dual purpose: it allowed the coordination server to associate the participant's email with the contribution, and to verify the contribution with the corresponding public key.

Participants could contribute through a browser or Docker. The browser option was more user-friendly for contributors to participate as everything happens in the browser. The Docker option required Docker setup but was more transparent because the Dockerfile and contributor source code are open source and the whole process is verifiable. Moreover, the browser option utilizes [snarkjs](https://github.com/iden3/snarkjs) while the Docker option utilizes [Kobi's implementation](https://github.com/iseriohn/phase2-bn254). This provided software variety and contributors could choose to contribute by whichever method they trusted. In addition, participants could generate entropy through entering random text or making random cursor movements.

The zkLogin circuit and the ceremony client [code](https://github.com/sui-foundation/zk-ceremony-client) were made open source and the links were made available to the participants to review before the ceremony. In addition, the developer documentation and an [audit report](https://github.com/sui-foundation/security-audits/blob/main/docs/zksecurity_zklogin-circuits.pdf) on the circuit from zkSecurity were posted. The ceremony adopted [challenge #0081](https://pse-trusted-setup-ppot.s3.eu-central-1.amazonaws.com/challenge_0081) (resulting from 80 community contributions) from [perpetual powers of tau](https://github.com/privacy-scaling-explorations/perpetualpowersoftau/tree/master/0080_carter_response) in phase 1, which is circuit agnostic. The output of the [Drand](http://drand.love) random beacon at epoch #3298000 was applied to remove bias. For phase 2, the ceremony had 111 contributions, 82 from browser and 29 from docker. Finally, the output of the Drand random beacon at epoch #3320606 was applied to remove bias from contributions. All intermediate files can be reproduced following instructions for [phase 1](https://github.com/sui-foundation/zklogin-ceremony-contributions/blob/main/phase1/README.md) and [phase 2](https://github.com/sui-foundation/zklogin-ceremony-contributions/blob/main/phase2/README.md).

The final CRS along with the transcript of contribution of every participant is available in a public repository. Contributors received both the hash of the previous contribution they were working on and the resulting hash after their contribution, displayed on-screen and sent through email. They can compare these hashes with the transcripts publicly available on the ceremony site. In addition, anyone is able to check that the hashes are computed correctly and each contribution is properly incorporated in the finalized parameters.

Eventually, the final CRS was used to generate the proving key and verifying key. The proving key is used to generate zero-knowledge proof for zkLogin, stored with the zero-knowledge proving service. The verifying key was [deployed](https://github.com/MystenLabs/sui/pull/13822) as part of the validator software (protocol version 25 in [release 1.10.1](https://github.com/MystenLabs/sui/releases/tag/mainnet-v1.10.1)) that is used to verify the zkLogin transaction on Sui.

## Security and privacy

The following sections walk through all zkLogin artifacts, their security assumptions, and the consequences of loss or exposure.

### JWT

The JWT's validity is scoped on the client ID (`aud`) to prevent phishing attacks. The same origin policy for the proof prevents the JWT obtained for a malicious application from being used for zkLogin. The JWT for the client ID is sent directly to the application frontend through the redirect URL. A leaked JWT for the specific client ID can compromise user privacy, as these tokens frequently hold sensitive information like usernames and emails. Furthermore, if a backend salt server is responsible for user salt management, the JWT could potentially be exploited to retrieve your salt, which introduces additional risks.

However, a JWT leak does not mean loss of funds as long as the corresponding ephemeral private key is safe.

### User salt

The user salt is required to get access to the zkLogin wallet. This value is essential for both ZK proof generation and zkLogin address derivation.

The leak of user salt does not mean loss of funds, but it enables the attacker to associate your subject identifier (for example, `sub`) with the Sui address. This can be problematic depending on whether pairwise or public subject identifiers are in use. In particular, there is no problem if pairwise IDs are used (for example, Facebook) as the subject identifier is unique for each RP. However, with public reusable IDs (for example, Google and Twitch), the globally unique `sub` value can be used to identify users.

### Ephemeral private key

The ephemeral private key's lifespan is tied to the maximum epoch specified in the nonce for creating a valid zero-knowledge proof. Should it be misplaced, a new ephemeral private key can be generated for transaction signing, accompanied by a freshly generated zero-knowledge proof using a new nonce. However, if the ephemeral private key is compromised, acquiring the user salt and the valid zero-knowledge proof would be necessary to move funds.

### Proof

Obtaining the proof itself cannot create a valid zkLogin transaction because an ephemeral signature over the transaction is also needed.

### Privacy

By default, there is no link between the OAuth subject identifier (for example, `sub`) and a Sui address. This is the purpose of the user salt. 

The JWT is not published on-chain by default. The revealed values include `iss`, `aud` and `kid` so that the public input hash can be computed, any sensitive fields such as `sub` are used as private inputs when generating the proof.

The ZK proving service and the salt service (if maintained) can link the user identity since the user salt and JWT are known, but the 2 services are stateless by design.

## FAQ

#### What providers is zkLogin compatible with?

- zkLogin can support providers that work with OpenID Connect built on top of the OAuth 2.0 framework. This is a subset of OAuth 2.0 compatible providers. See [latest table](#openid-providers) for all enabled providers. Other compatible providers are enabled through protocol upgrades in the future.

#### How is a zkLogin Wallet different from a traditional private key wallet?

- Traditional private key wallets demand you to consistently recall mnemonics and passphrases, requiring secure storage to prevent private key compromise. On the other hand, a zkLogin wallet only requires an ephemeral private key storage with session expiry and the OAuth login flow with expiry. Forgetting an ephemeral key does not result in loss of funds, because you can always sign in again to generate a new ephemeral key and a new ZK proof.

#### How is zkLogin different from MPC or multisig wallets?

- Multi-Party Computation (MPC) and multisig wallets rely on multiple keys or distributing multiple key shares and then defining a threshold value for accepting a signature. zkLogin does not split any individual private keys, but ephemeral private keys are registered using a fresh nonce when you authenticate with the OAuth provider. The primary advantage of zkLogin is that you do not need to manage any persistent private key anywhere, not even with any private keys management techniques like MPC or multisig. You can think of zkLogin as a 2FA scheme for an address, where the first part is your OAuth account and the second is your salt. Furthermore, because Sui natively supports multisig wallets, you can always include one or more zkLogin signers inside a multisig wallet for additional security, such as using the zkLogin part as 2FA in k-of-N settings.

#### If a OAuth account is compromised, what happens to the zkLogin address?

- Because zkLogin is a 2FA system, an attacker that has compromised your OAuth account cannot access your zkLogin address unless they have separately compromised your salt.

#### If you lose access to my OAuth account, do you lose access to the zkLogin address?

- Yes. You must be able to log into your OAuth account and produce a current JWT in order to use zkLogin.

#### Does losing an OAuth credential mean the loss of funds in the zkLogin wallet?

- A forgotten OAuth credential can typically be recovered by resetting the password in that provider. In the unfortunate event where your OAuth credentials are compromised, an adversary still requires the `user_salt`, but also learns which wallet is used in order to take over that account. Modern `user_salt` providers might have additional 2FA security measures in place to prevent provision of user salt even to entities that present a valid, non-expired JWT. It is also important to highlight that due to the fact that zkLogin addresses do not expose any information about the user identity or wallet used, targeted attacks by just monitoring the blockchain are more difficult. In the event where you lose access to your OAuth account permanently, access to that wallet is lost. If recovery from a lost OAuth account is desired, a good suggestion for wallet providers is to support the native Sui multisig functionality and add a backup method. It is even possible to have a multisig wallet that all signers are using zkLogin, such as a 1-of-2 multisig zkLogin wallet where the first part is Google and the second Facebook OAuth, respectively.

#### Canyou convert or merge a traditional private key wallet into a zkLogin one, or the reverse?

- No. The zkLogin wallet address is derived differently compared to a private key address.

#### Does my zkLogin address ever change?

- zkLogin address is derived from `sub`, `iss`, `aud`, and `user_salt`. The address does not change if you log in to the same wallet with the same OAuth provider, since `sub`, `iss`, `aud`, and `user_salt` remain unchanged in the JWT, even though the JWT itself might look different every time you log in. However, if you log in with different OAuth providers, your address changes because the `iss` and `aud` are defined distinctly per provider. In addition, each wallet or application maintains its own `user_salt`, so logging with the same provider for different wallets might also result in different addresses.

#### Can you have multiple addresses with the same OAuth provider?

- Yes, this is possible by using a different wallet provider or different `user_salt` for each account. This is useful for separating funds between different accounts.

#### Is a zkLogin Wallet custodial?

- A zkLogin wallet is a non-custodial or unhosted wallet. A custodial or hosted wallet is where a third party (the custodian) controls the private keys on behalf of a wallet user. No such third party exists for zkLogin wallets. Instead, a zkLogin wallet can be viewed as a 2-of-2 multisig where the 2 credentials are your OAuth credentials and the salt. Neither the OAuth provider, the wallet vendor, the ZK proving service, or the salt service provider is a custodian.

#### Generating a zero-knowledge proof is expensive, is a new proof required to be generated for every transaction?

- No. Proof generation is only required when ephemeral key pair expires. Since the nonce is defined by the ephemeral public key (`eph_pk`) and expiry (`max_epoch`), the zero-knowledge proof is valid until what the expiry is committed to the nonce in the JWT. The zero-knowledge proof can be cached and the same ephemeral key can be used to sign transactions until it expires.

#### Does zkLogin work on mobile?

- zkLogin is a Sui native primitive and not a feature of a particular application or wallet. It can be used by any Sui developer, including on mobile.

#### Is account recovery possible if you lose the OAuth credentials?

- Yes, you can follow the OAuth providers recovery flow. The ephemeral private key can be refreshed and after completing a new OAuth login flow, you can obtain new zero-knowledge proof and sign transactions with the refreshed key.

#### What are some assumptions for the zkLogin circuit?

- Due to the way Groth16 works, Sui imposes length restrictions on several fields in the JWT. Some of the fields that are length-restricted include `aud`, `iss`, the JWT header, and the payload. For example, zkLogin can currently only work with `aud` values of up to length 120. In general, Sui tries to make sure that the restrictions are as generous as possible. Sui has decided on these values after looking at as many JWTs that could be obtained.

#### How is zkLogin different from other solutions that support social login?

- While providing social login with Web2 credentials for a Web3 wallet is not a new concept, the existing solutions have one or more of the trust assumptions:

1. Trust a different network or parties to verify Web2 credentials other than the blockchain itself, usually involving a JWK oracle posted on-chain by a trusted party.
1. Trust some parties to manage a persistent private key, whether it uses MPC, threshold cryptography, or secure enclaves.
1. Rely on smart contracts to verify the JWT on-chain with revealing privacy fields, or to verify zero-knowledge proofs on-chain, which can be expensive.

- Some of the existing deployed solutions rely on some of these assumptions. [Web3Auth](https://web3auth.io/) and [Auth0 social login](https://auth0.com/learn/social-login) requires deployment of custom OAuth verifiers to [Web3auth Auth Network](https://github.com/web3auth) nodes to verify the JWT. [Magic Wallet](https://wallet.magic.link/) and [Privy](https://privy.io/) also require custom OAuth identity issuer and verifiers to adopt the [DID standard](https://www.w3.org/TR/did-1.0/). All of the solutions still require persistent private key management, either with trusted parties like AWS through delegation, Shamir Secret Sharing, or MPC.

#### How to verify a zkLogin signature off-chain?

- The following options support a zkLogin signature over either transaction data or personal message using the JWK state on Sui and current epoch.

1. Use [Sui TypeScript SDK](https://sdk.mystenlabs.com/typescript). This initializes a [GraphQL client](/references/sui-graphql.mdx) and calls the endpoint under the hood.

1. Use the GraphQL endpoint directly: `https://sui-[network].mystenlabs.com/graphql`, changing `[network]` to the appropriate value. See the <UnsafeLink href="/references/sui-api/sui-graphql/beta/reference/operations/queries/verify-zk-login-signature.mdx">GraphQL documentation</UnsafeLink> for more details. This is recommended if you do not plan to run any servers or handle any JWK rotations.

1. Use the [Sui Keytool CLI](/references/cli/keytool.mdx). This is recommended for debug usage.

   ```sh
   $ sui keytool zk-login-sig-verify --sig $ZKLOGIN_SIG --bytes $BYTES --intent-scope 3 --network devnet --curr-epoch 3
   ```

1. Use a self-hosted server endpoint and call this endpoint, as described in [`zklogin-verifier`](https://github.com/MystenLabs/zklogin-verifier). This provides logic flexibility.

#### Can I use zkLogin inside a multisig wallet?

- Yes. See the [Multisig guide](https://sdk.mystenlabs.com/typescript/cryptography/multisig#multisig-with-zklogin) for more details.

## Related links

<RelatedLink to="/guides/developer/cryptography/zklogin-integration.mdx" />
<RelatedLink to="/guides/developer/cryptography/zklogin-integration/zklogin-example.mdx" />