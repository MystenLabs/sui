---
title: gRPC
description: Learn about gRPC and how it provides fast, type-safe access to Sui network data.
keywords: [ grpc, g rpc, RPC, sui full node grpc, full node rpc, what is grpc, grpc on sui ]
---

The [Sui Full Node gRPC API](/references/fullnode-protocol.mdx) provides a fast, type-safe, and efficient interface for interacting with the Sui blockchain. Designed for power users, indexers, explorers, and decentralized apps, this API enables access to Sui data with high performance and low latency.

:::info

<ImportContent source="json-rpc-deprecation.mdx" mode="snippet" />

<ImportContent source="data-serving-msg.mdx" mode="snippet" />

:::

## What is gRPC?

gRPC offers a high-performance, efficient communication protocol that uses [Protocol Buffers](https://protobuf.dev/overview/) for fast, compact data serialization. Its strongly typed interfaces reduce runtime errors and simplify client and server development across multiple languages. With built-in support for code generation, you can scaffold clients in TypeScript, Go, Rust, and more. This makes it ideal for scalable backend systems like indexers, blockchain explorers, and data-intensive decentralized apps.

In addition to request-response calls, gRPC supports server-side streaming, enabling real-time data delivery without constant polling. This is especially useful in environments where you need to track events and transactions live. gRPC's binary format is significantly faster and lighter than JSON, saving bandwidth and improving latency.

## gRPC services on Sui

Protocol buffers define the gRPC interface. You can find the relevant `.proto` files at [`sui-apis` on Github](https://github.com/MystenLabs/sui-apis/tree/main/proto), which apart from the gRPC messages (request and response payloads), include the following services:

| Service | `.proto` file | Purpose |
| --- | --- | --- |
| `TransactionExecutionService` | `sui/rpc/v2/transaction_execution_service.proto` | Submit and execute signed transactions on the Sui network. Wallets and apps use this service to send user actions to the network. |
| `LedgerService` | `sui/rpc/v2/ledger_service.proto` | Lookup specific checkpoints, transactions, objects, and more from the current state and recent history of the Sui network. History refers to the recent past, limited to what a full node retains. |
| `StateService` | `sui/rpc/v2/state_service.proto` | Query up-to-date on-chain data like balances, coin metadata, dynamic fields, or owned objects. It also supports dry-run simulations for transactions. |
| `SubscriptionService` | `sui/rpc/v2/subscription_service.proto` | Stream live updates for checkpoints. Ideal for building reactive systems such as indexers, bots, and dashboards. Refer to [Subscriptions for streaming data](#subscriptions-for-streaming-data). |
| `MovePackageService` | `sui/rpc/v2/move_package_service.proto` | Access metadata and the content of Move packages deployed on the Sui network. Useful for tooling, analysis, and smart contract introspection. |
| `SignatureVerificationService` | `sui/rpc/v2/signature_verification_service.proto` | Validate signatures outside transaction execution. Helps pre-verify payloads that might include [zklogin](/concepts/cryptography/zklogin.mdx) or other signatures, simulate authentication, or build custom signing workflows. |
| `NameService` | `sui/rpc/v2/name_service.proto` | Resolve human-readable SuiNS names to their underlying name records, and perform reverse lookups from Sui addresses back to linked names. |

Use these definitions to generate client libraries in various programming languages.

:::info 

If you were using the `v2beta2` `.proto` files previously, the latest definitions are now under the `v2` version. Also, the `LiveDataService` has been renamed to `StateService`, and the `SimulateTransaction` API has been moved to the `TransactionExecutionService`.

:::

### Field masks

A [`FieldMask` in protocol buffers](https://protobuf.dev/reference/protobuf/google.protobuf/#field-mask) is a mechanism used to specify a subset of fields within a message that should be read, updated, or returned. Instead of retrieving the entire object, a client can request only the specific fields they need by providing a list of field paths. This improves performance and reduces unnecessary data transfer.

In the Sui gRPC API, `FieldMask`s are used in requests like `GetTransaction`, `GetObject`, and so on to control which parts are included in the response (like the `effects` and `events` of a transaction).

Field masks are defined using `google.protobuf.FieldMask` and typically appear in the request message as `read_mask`. You can pass an explicit value of `*` to request all fields.

If you omit `read_mask`, it defaults to `*` (all fields), unless documented otherwise.

- Each field path in the mask must match the field structure of the response proto message. Nested fields are supported using dot notation.

- In batch APIs, only the top-level `read_mask` is respected. The API ignores any masks inside sub-requests.

- In some cases, non-terminal repeated fields might be supported in the mask, even if this is atypical per standard `FieldMask` behavior.

### Field presence

When using gRPC with Sui, it's important to understand how [field presence](https://github.com/protocolbuffers/protobuf/blob/main/docs/field_presence.md) works, especially when dealing with `proto3` syntax. In `proto3`, primitive fields like numbers, booleans, and strings are always initialized to a default value if not present in the message. This means you can't tell whether a value is explicitly set or just left out. To give you that distinction, Sui marks all fields as `optional`, even if they're required by the API.

As a user of the API, this lets you detect whether a field value is actually provided or just defaulted and write clients that can perform partial updates or simulate intent like distinguishing between an explicitly empty input versus a missing one.

:::info

If a field is marked `optional` in the proto, it might still be **required** for the request to be valid. This is a protobuf quirk, not an indication of actual business logic.

:::

### Encoding

In the Sui gRPC API, identifiers with standard human-readable formats are represented as `string`s in the proto schema:

- `Address` and `ObjectId`: Represented as 64 hexadecimal characters with a leading `0x`.

- `Digest`s: Represented as [Base58](https://learnmeabitcoin.com/technical/keys/base58/).

- `TypeTag` and `StructTag`: Represented in their canonical string format (such as  `0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI>`)

### Pagination

When using gRPC APIs that return lists of data like account balances, owned objects, and so on, you typically need to handle pagination. These APIs return results in chunks and include tokens to help you request the next batch.

In the request, provide a `page_size` to control how many items you want returned. If you leave this unset or set it to 0, the API uses a sensible default. You can also include a `page_token` in the request, which tells the server where to continue from. You get this token from the previous response.

The response includes a list of results and a `next_page_token` value, which you can pass into your next request to get the next page. When the server returns an empty `next_page_token`, you've reached the end of the list.

Make sure to keep all other parameters in your request the same between paginated calls. Otherwise, the server might reject the request with an `INVALID_ARGUMENT` error.

### Errors

The Sui gRPC services follow the [richer error model](https://grpc.io/docs/guides/error/#richer-error-model) defined in [AIP-193](https://google.aip.dev/193). When an RPC returns a non-OK status code, detailed error information is typically included in the `grpc-status-details-bin` header. This header contains a `google.rpc.Status` message encoded in Base64.

You can decode this message to access structured error details, which might include specific causes, context, or metadata. This makes it easier to understand and handle errors programmatically in your client applications.

### HTTP headers

In many gRPC responses, the Sui API includes additional metadata in the form of HTTP headers. These headers provide contextual information about the current network state and might be useful for debugging, telemetry, or understanding the data's freshness.

Here are the headers you might encounter:

- `x-sui-chain-id`: The chain ID of the current network.

- `x-sui-chain`: A human-readable name for the current network (`mainnet`, `testnet`, or `devnet`).

- `x-sui-checkpoint-height`: The height of the latest checkpoint at the time of the response.

- `x-sui-lowest-available-checkpoint`: The earliest checkpoint for which transaction and checkpoint data can still be queried.

- `x-sui-lowest-available-checkpoint-objects`: The earliest checkpoint from which object data (input and output) is available.

- `x-sui-epoch`: The current epoch of the network.

- `x-sui-timestamp-ms`: The network timestamp in milliseconds since the Unix epoch.

- `x-sui-timestamp`: The network timestamp in milliseconds since the Unix epoch in human-readable [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) format.

Not all headers are guaranteed to be present in every API response. They are only included when applicable to the given RPC.

## Subscriptions for streaming data

The `SubscriptionService` provides real-time streaming updates for on-chain activity through gRPC server-side streaming APIs. For example, the `SubscribeCheckpoint` RPC lets you subscribe to the global stream of executed checkpoints. When a subscription is initialized, the stream begins at the latest checkpoint known to the server. Checkpoints are guaranteed to arrive in order and without gaps. This allows clients to track exactly which checkpoint they last processed.

If the stream is interrupted due to client disconnect or network error, you can resume from the last known checkpoint using other APIs to backfill any missed data before resubscribing.

Streaming APIs are useful for building indexers, dashboards, or bots that need to react to real-time Sui activity with minimal latency.

## Handling pruned data

If a full node doesn't return a specific object, transaction, or event, it's likely that the data has been pruned based on the node's retention configuration. In that case, use a fallback mechanism in your application to query the same data from the [Archival Store and Service](/guides/developer/accessing-data/archival-store.mdx). The Archival Store retains historical data for the network.

You can reuse the same gRPC `LedgerService` methods for this lookup. Simply change the endpoint in your client from the full node's address to the archival service endpoint. This ensures that your application can access both recent and historical data reliably, regardless of a full node's pruning settings.

## Best practices

1. Always use [field masks](#field-masks) when applicable to reduce response size and latency, especially for large resources.

1. Use `TLS (port 443)` for production traffic to ensure encrypted transport and prevent downgrade attacks.

1. Use [streaming subscriptions](#subscriptions-for-streaming-data) for real-time use cases instead of polling repeatedly.

1. Generate client code from the official `.proto` definitions in [`sui-apis`](https://github.com/MystenLabs/sui-apis/tree/main/proto) to ensure compatibility and type safety.

1. [Paginate](#pagination) carefully. Always check `next_page_token` and do not assume all data is returned at once.

1. Retry transient failures with [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff), especially for streaming APIs or busy public nodes.

1. Validate all input data, including encodings and message formats, to prevent hard-to-debug API rejections.

## Frequently asked questions

#### Can I use field masks in batch requests?

Only the top-level `read_mask` field is respected in batch requests like `BatchGetObjects`. Any [field masks](#field-masks) within individual `GetObjectRequest` items are ignored.

#### Why does the API return fewer results than the requested `page_size`?

Even if you request a specific `page_size`, the server might return fewer items. This could be due to full node specific limits, filtered results, or reaching the end of available data.

#### Why do some fields say `optional` if they're required?

In `proto3`, marking a field as `optional` gives the API the ability to detect [field presence](#field-presence), that is, whether a field value is explicitly set or simply defaulted. This doesn't mean the field is optional in practice. You still need to follow the API contract to ensure the request is valid.

#### Are all services and related data guaranteed to be available on all full nodes?

Full nodes might vary in which services and retention they support. Some services might not be supported yet or some APIs might return `NOT_FOUND` depending on the node's configuration and data availability.

## Related links

- [Using gRPC](/guides/developer/accessing-data/grpc-overview.mdx): Instructions for using and building gRPC clients in TypeScript, Go, and Python.

- [Full Node Operator Configuration](/guides/operator/sui-full-node.mdx#considerations-to-enable-grpc): Configuration options for enabling gRPC on your full node.