---
title: Life of a Transaction
description: The life of a transaction on the Sui network has some differences compared to those from other blockchains. 
---

A transaction on the Sui network goes through several steps during its life cycle.

## Life cycle overview

At a high level, the following figure outlines the life cycle of a transaction on the Sui blockchain:

![Transaction life cycle](./images/txn-lifecycle.png)

The steps in the image align with the following description:  

1. A user with a private key creates and signs a transaction to mutate objects they own, or a mix of owned and [shared objects](../object-ownership/shared.mdx).  
2. The transaction is sent to each validator (often through a full node). Validators perform validity and safety checks, sign it, and return the signed transaction to the client.  
3. The client collects signatures from validators representing at least two-thirds of the stake (a supermajority) to form a transaction certificate. Unlike consensus-based blockchains, validators do not gossip signatures or aggregate certificates. The client or gateway performs this step.  
4. The client sends the transaction certificate back to all validators, who check its validity. If the transaction involves only owned objects, validators execute it immediately (**direct fast path**) without consensus. All certificates are also forwarded to Sui’s DAG-based consensus protocol.  
5. Consensus produces a total order of certificates. Validators then check and execute certificates that contain shared objects.  
6. Clients collect validator responses, assemble them into an effects certificate, and use it as proof of settlement.  
7. Sui forms checkpoints for every consensus commit, which also drive the reconfiguration protocol.  

For more technical detail, see the [Sui Lutris paper](https://docs.sui.io/paper/sui-lutris.pdf), which describes the safety and liveness protocols with security proofs in the standard distributed systems model.

## Submission

All transactions begin with submission to the network. For example, to transfer an NFT to a friend, you create a transaction in your wallet. The transaction includes your gas payment object and the transfer command. Before sending, your wallet signs it with your private key and submits it to a full node.

## Certification

Certification starts when a full node submits the transaction to validators. A validator checks validity and, if the checks pass, locks the owned input objects so they cannot be reused. This prevents double-spending.  

A transaction passes certification if:  

- It has a valid user signature
- The initiator owns the required input objects
- Any shared input objects exist
- The gas coin is a `Coin<SUI>` with at least the specified gas budget

If the transaction passes, the validator signs it with its BLS private key and returns the signature. The full node collects signatures from a supermajority of validators to form a **transaction certificate**.  

Because of quorum intersection, it is impossible to create 2 valid certificates for the same owned object version, even if some validators act dishonestly.

:::info
Full nodes collect validator signatures in parallel to minimize latency.  
:::

## Execution

Validators execute transactions after certification.  

- If the transaction does not use shared objects, validators execute it immediately.  
- If the transaction includes shared objects, validators submit it to consensus, which orders and then executes it.  

## Certified effects

After execution, validators sign the effects of the transaction and return them. Effects include:  

- Objects that were mutated, created, wrapped, unwrapped, or deleted
- Gas spent
- Execution status (success or error)

The full node collects signatures from a supermajority and forms an **effects certificate**.  

:::tip
An effects certificate guarantees finality.  
:::

You can present an effects certificate to another party (for example, proving you transferred an NFT) as irrefutable proof.

## Checkpoints

Checkpoints are the final stage. Validators group ordered transactions from consensus into checkpoints.  

- For transactions with shared objects, consensus comes first.  
- For transactions with only owned objects, execution comes first, then consensus.  

Checkpoints ensure causal completeness: dependencies appear before dependents. Each checkpoint contains transaction digests and effects digests. Formation usually takes a few seconds.  

Then the validator constructs a checkpoint, which (among other data) contains a list of transaction digests as well as the digests of the transaction effects of each transaction. Because checkpoints must be complete, the network sometimes has to wait for the availability of all transactions to form the checkpoints, which may take a couple of commits to process. This process typically completes in the order of a few seconds.

At this point, the transaction has reached the end of its life cycle and is included in the permanent record of transaction activity on the Sui network.

## Transaction finality

Finality means execution is irreversible.  

- Collecting validator signatures on a transaction takes <0.5 seconds.  
- At this point, the sender knows the transaction will be processed within the epoch.  
- Honest validators reject conflicting transactions using the same objects.  

## Settlement finality

Settlement finality occurs once a supermajority of validators execute the transaction and sign its effects:  

- For owned-only transactions, this happens in <0.5 seconds (direct path).  
- For shared-object transactions, this happens shortly after consensus (a few seconds).  

After this point, dependent transactions can safely execute.  

See [Object ownership](../../concepts/object-ownership.mdx) for more details.

## Example: paying for coffee

Imagine you pay 10 SUI to a coffee shop.  

1. **Transaction creation:** Your wallet constructs and signs a transfer of 10 SUI to the shop’s address.  
2. **Broadcast:** Your wallet submits the signed transaction to a full node, which broadcasts it to validators.  
3. **Certification:** Validators check validity, lock input objects, and sign the transaction. The full node collects signatures and forms a transaction certificate.  
4. **Finalization:** The certificate is sent to validators. They verify, execute, and return signed effects. The full node collects them into an effects certificate, which your wallet can show to the shop as proof of payment.  

### Checkpoint processing

The process in the previous section demonstrates a finalized transaction through an effects certificate. As the process shows, the full node plays the quorum driving role.

What if the full node goes offline before it collects a quorum of validator-signed effects? Your wallet app will probably retry the process with a different full node. Unfortunately, your phone runs out of battery before it sends the signed transaction to a new full node.

No worries. The coffee shop shortly notices your payment arrive in its terminal, connected to a different full node. This full node learns about your transaction through checkpoints.

As mentioned, a checkpoint contains a list of transactions. If a transaction appears in a certified checkpoint (a checkpoint that has been signed by a supermajority of validators), it is considered finalized.

The full node that the coffee shop's terminal connects to knows about your transaction through state sync. In this case, as long as one validator receives the transaction certificate from your original full node, the transaction will highly likely finalize even without an effects certificate. The coffee shop is assured of payment and can give you your coffee.```

### Local execution on full node

Before the full node sends back an effects certificate to your wallet app, it may try to execute the transaction locally, if the request asks it to.

The purpose of this extra step is to keep the full node up to date as much as possible, especially when the wallet app frequently hits the same full node. In this coffee shop example, this might be trivial, but for a high frequency application, such as gaming, it could be important.

When an app constructs a transaction, it typically requests that the full node choose a gas object for it. Gas objects are owned objects, meaning that if the full node is stale and not aware of the right version of the object, it could lead to invalid transactions, or worse, client equivocation if the client software does not handle it properly. Executing on full node before returning `EffectsCertificate` is one way to avoid this situation. A request can ask for such behavior by using the `WaitForLocalExecution` parameter. See [Sponsored Transactions](../transactions/sponsored-transactions.mdx) for more on client equivocation.

Using `WaitForLocalExecution` is not always the best choice, however. For example, with this coffee payment it adds a layer of end-to-end latency without significant benefits. In this case, using the `WaitForEffects` parameter instead to have a slightly shorter user-perceived latency.```

### Epoch change

Every ~24 hours, the network reconfigures during an epoch change. Rewards are distributed, validator metadata updates, and protocol upgrades may occur.  All user transactions are delayed until the new epoch begins.

If a transaction is caught at the epoch boundary, its certificate might become void (since signatures include the epoch ID). In this case, the wallet resubmits the transaction in the new epoch. Full nodes handle this automatically.

### Verifying finality

If your wallet crashes, it can query the full node with `getTransactionBlock` after restarting:  

- If transaction details are returned, it is finalized.  
- If `None`, the transaction may be dropped or not yet checkpointed. The safe option is to resubmit.  

Before a transaction is locally executed, its effects are not reflected on the full node. The same idea applies to the coffee shop's full node. Your transaction was not submitted through this full node, hence it does not have a chance to locally execute it before it's included in a checkpoint. This full node must wait for the transaction to be checkpointed and state synced, which normally takes a few seconds. After the full node receives this transaction in a checkpoint, it is executed and has effects updated locally, for example the coffee shop's balance increases.

## Summary

Hopefully, you now have a better understanding of how a transaction gets certified and finalized.

1. A transaction certificate does not always guaranteed finality, even though it's highly likely. Specifically, a transaction certificate might become void after an epoch change.

2. An effects certificate guarantees finality - it takes a supermajority of validators to execute the transaction and commit to the effects.

3. An inclusion in a certified checkpoint guarantees finality - it takes a supermajority of validators to certify the checkpoint, in which every transaction is executed and effects-committed.
