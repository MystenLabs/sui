---
title: Life of a Transaction
description: The life of a transaction on the Sui network has some differences compared to those from other blockchains. 
---

A transaction on the Sui network goes through several steps during its life cycle.

## Life cycle overview

At a high level, the following figure outlines the life cycle of a transaction on the Sui blockchain:

![Transaction life cycle](./images/txn-lifecycle.png)

The steps in the image align with the following description:  

1. A user with a private key creates and signs a transaction to mutate objects they own, or a mix of owned and [shared objects](../object-ownership/shared.mdx).  
2. The transaction is sent to each validator (often through a full node). Validators perform validity and safety checks, sign it, and return the signed transaction to the client.  
3. The client collects signatures from validators representing at least two-thirds of the stake (a supermajority) to form a transaction certificate. Unlike consensus-based blockchains, validators do not gossip signatures or aggregate certificates. The client or gateway performs this step.  
4. The client sends the transaction certificate back to all validators, who check its validity. If the transaction involves only owned objects, validators execute it immediately (**direct fast path**) without consensus. All certificates are also forwarded to Sui’s DAG-based consensus protocol.  
5. Consensus produces a total order of certificates. Validators then check and execute certificates that contain shared objects.  
6. Clients collect validator responses, assemble them into an effects certificate, and use it as proof of settlement.  
7. Sui forms checkpoints for every consensus commit, which also drive the reconfiguration protocol.  

For more technical detail, see the [Sui Lutris paper](https://docs.sui.io/paper/sui-lutris.pdf), which describes the safety and liveness protocols with security proofs in the standard distributed systems model.

## Submission

All transactions begin with submission to the network. For example, to transfer an NFT to a friend, you create a transaction in your wallet. The transaction includes your gas payment object and the transfer command. Before sending, your wallet signs it with your private key and submits it to a full node.

## Certification

Certification starts when a full node submits the transaction to validators. A validator checks validity and, if the checks pass, locks the owned input objects so they cannot be reused. This prevents double-spending.  

A transaction passes certification if:  

- It has a valid user signature.  
- The initiator owns the required input objects.  
- Any shared input objects exist.  
- The gas coin is a `Coin<SUI>` with at least the specified gas budget.  

If the transaction passes, the validator signs it with its BLS private key and returns the signature. The full node collects signatures from a supermajority of validators to form a **transaction certificate**.  

Because of quorum intersection, it is impossible to create two valid certificates for the same owned object version, even if some validators act dishonestly.

:::info
Full nodes collect validator signatures in parallel to minimize latency.  
:::

## Execution

Validators execute transactions after certification.  

- If the transaction does not use shared objects, validators execute it immediately.  
- If the transaction includes shared objects, validators submit it to consensus, which orders and then executes it.  

## Certified effects

After execution, validators sign the effects of the transaction and return them. Effects include:  

- Objects that were mutated, created, wrapped, unwrapped, or deleted.  
- Gas spent.  
- Execution status (success or error).  

The full node collects signatures from a supermajority and forms an **effects certificate**.  

:::tip
An effects certificate guarantees finality.  
:::

You can present an effects certificate to another party (for example, proving you transferred an NFT) as irrefutable proof.

## Checkpoints

Checkpoints are the final stage. Validators group ordered transactions from consensus into checkpoints.  

- For transactions with shared objects, consensus comes first.  
- For transactions with only owned objects, execution comes first, then consensus.  

Checkpoints ensure causal completeness: dependencies appear before dependents. Each checkpoint contains transaction digests and effects digests. Formation usually takes a few seconds.  

At this stage, the transaction is part of the permanent history of the Sui network.

## Transaction finality

Finality means execution is irreversible.  

- Collecting validator signatures on a transaction takes <0.5 seconds.  
- At this point, the sender knows the transaction will be processed within the epoch.  
- Honest validators reject conflicting transactions using the same objects.  

## Settlement finality

Settlement finality occurs once a supermajority of validators execute the transaction and sign its effects:  

- For owned-only transactions, this happens in <0.5 seconds (direct path).  
- For shared-object transactions, this happens shortly after consensus (a few seconds).  

After this point, dependent transactions can safely execute.  

See [Object ownership](../../concepts/object-ownership.mdx) for more details.

## Example: paying for coffee

Imagine you pay 10 SUI to a coffee shop.  

1. **Transaction creation:** Your wallet constructs and signs a transfer of 10 SUI to the shop’s address.  
2. **Broadcast:** Your wallet submits the signed transaction to a full node, which broadcasts it to validators.  
3. **Certification:** Validators check validity, lock input objects, and sign the transaction. The full node collects signatures and forms a transaction certificate.  
4. **Finalization:** The certificate is sent to validators. They verify, execute, and return signed effects. The full node collects them into an effects certificate, which your wallet can show to the shop as proof of payment.  

### Checkpoint processing

If the wallet or full node fails before collecting enough signatures, the transaction can still finalize once included in a checkpoint. As long as one validator receives the certificate, checkpoints ensure finality.

### Local execution on full node

Full nodes may execute transactions locally before returning effects to keep state fresh, especially for high-frequency use cases. This behavior depends on the `WaitForLocalExecution` parameter.  

For simple payments, `WaitForEffects` is usually preferred because it reduces latency.

### Epoch change

Every ~24 hours, the network reconfigures during an epoch change. Rewards are distributed, validator metadata updates, and protocol upgrades may occur.  

If a transaction is caught at the epoch boundary, its certificate might become void (since signatures include the epoch ID). In this case, the wallet resubmits the transaction in the new epoch. Full nodes handle this automatically.

### Verifying finality

If your wallet crashes, it can query the full node with `getTransactionBlock` after restarting:  

- If transaction details are returned, it is finalized.  
- If `None`, the transaction may be dropped or not yet checkpointed. The safe option is to resubmit.  

Once included in a checkpoint, the effects appear locally on all full nodes.

## Summary

- A **transaction certificate** suggests finality but may become void after an epoch change.  
- An **effects certificate** guarantees finality, backed by a supermajority of validators.  
- Inclusion in a **certified checkpoint** also guarantees finality, as it represents validator consensus on executed transactions.  
