---
title: Move Conventions
description: Recommended Move 2024 best practices for Sui development.
---

This guide outlines recommended conventions and best practices for writing Move smart contracts on Sui. Following these guidelines helps create maintainable, secure, and composable code that aligns with ecosystem standards.

These conventions are recommendations, not strict rules. They represent patterns that have proven effective across many Sui projects and help ensure consistency across the ecosystem.

## Organization principles


A Sui package consists of:

- A `sources` directory containing the Move code uploaded on-chain.
- A `Move.toml` manifest file that declares dependencies and package metadata.
- A `Move.lock` file that the toolchain generates to lock dependency versions and track published and upgraded package addresses across networks.

Always commit the `Move.lock` file (do not add it to `.gitignore`). Use [automated address management](https://docs.sui.io/concepts/sui-move-concepts/packages/automated-address-management) instead of the old `published-at` field in the manifest.

Optionally, you can add a `tests` directory to contain the tests for the package and an `examples` directory to provide use cases for the package. Neither directory is uploaded on chain when you publish the package.

```
sources/
    my_module.move
    another_module.move
    ...
tests/
    my_module_tests.move
    ...
examples/
    using_my_module.move
Move.lock
Move.toml
```

In `Move.toml`:  

- Use PascalCase for package names (`name = "MyPackage"`).  
- Use snake_case for the named address representing the package (`my_package = 0x0`).  

### Modules

Modules are the main building blocks of Move code. Design modules around a single object or data structure. Variant structures should have their own module to reduce complexity.

You no longer need brackets for module declarations. The compiler includes default `use` statements for common modules.

```move
module conventions::wallet;

public struct Wallet has key, store {
    id: UID,
    amount: u64
}
```

### Body

Use comments to divide your module into sections. Use `===` to mark section titles.

```move
module conventions::comments;

// === Imports ===
// === Errors ===
// === Constants ===
// === Structs ===
// === Events ===
// === Method Aliases ===
// === Public functions ===
// === View functions ===
// === Admin functions ===
// === Package functions ===
// === Private functions ===
// === Test functions ===
```

Here, "public functions" are the functions modifying state, "view functions" are often on-chain getters or off-chain helpers. The latter are not necessary because you can query objects to read their data. 

Other general guidelines include:

- Place the `init` function first if it exists.  
- Group functions by purpose and in user-flow order.  
- Use descriptive names like `admin_set_fees`.  
- Keep test-only helpers inside the module; write actual tests in the `tests` directory.  
- Group imports by dependency:  

```move
use std::string::String;
use sui::{
    coin::Coin,
    balance,
    table::Table
};
use my_dep::battle::{Battle, Score};
```

## Naming conventions

Adhering to naming conventions in your code helps readability and ultimately makes your codebase easier to maintain. The following sections outline the key naming conventions to follow when writing Move code.

### Constants

Constants should be uppercase and formatted as snake case. Errors are specific constants that use PascalCase and start with an E. Make them descriptive.

```move
module conventions::constants;

const MAX_NAME_LENGTH: u64 = 64;
const EInvalidName: u64 = 0; // correct
const E_INVALID_NAME: u64 = 0; // wrong
```

### Structs

- Declare abilities in this order: `key`, `copy`, `drop`, `store`.  
- Avoid using `Potato` as a suffix (this signals missing abilities).  
- Use positional fields for simple wrappers, dynamic field keys, or tuples.  
- Use the `Event` suffix for event structs.  

```move
module conventions::request;

// dynamic field keys
public struct ReceiptKey(ID) has copy, drop, store;

// dynamic field
public struct Receipt<Data> has key, store {
    id: UID,
    data: Data
}

public struct Request(); // correct
public struct RequestPotato {} // wrong
```

### CRUD function names

Standard names:

- `new` → Create an empty object  
- `empty` → Create an empty struct  
- `create` → Create an initialized object  
- `add` / `remove` → Add or remove a value  
- `exists` / `contains` → Check existence  
- `borrow` / `borrow_mut` → Return a reference  
- `property_name` / `property_name_mut` → Return a field  
- `drop` → Drop a struct  
- `destroy` / `destroy_empty` → Destroy an object  
- `to_name` / `from_name` → Type transformations  

### Generics

Use either single letters (`T`, `U`) or descriptive names. Prioritize readability.

```move
public struct Receipt<T> has store { ... }
// full name
public struct Receipt<Data> has store { ... }
```

## Code structure

### Shared objects

Library modules that share objects should provide two functions: one to instantiate and return the object, and another one to share it. It allows the caller to pass it to other functions and run custom functionality before sharing it.

```move
module conventions::shop;
public struct Shop has key {
    id: UID
}
public fun new(ctx: &mut TxContext): Shop {
    Shop {
        id: object::new(ctx)
    }
}
public fun share(shop: Shop) {
    transfer::share_object(shop);
}
```

### Pure functions

Keep core functions pure. Avoid `transfer::transfer` inside them, except for non-transferable objects.

```move
module conventions::amm;
use sui::coin::Coin;
public struct Pool has key {
    id: UID
}

// right -> returns the excess coins even if they have zero value.
public fun add_liquidity<CoinX, CoinY, LpCoin>(pool: &mut Pool, coin_x: Coin<CoinX>, coin_y: Coin<CoinY>): (Coin<LpCoin>, Coin<CoinX>, Coin<CoinY>) {
    // Implementation omitted.
    abort(0)
}

// right but not recommended
public fun add_liquidity_and_transfer<CoinX, CoinY, LpCoin>(pool: &mut Pool, coin_x: Coin<CoinX>, coin_y: Coin<CoinY>, recipient: address) {
    let (lp_coin, coin_x, coin_y) = add_liquidity<CoinX, CoinY, LpCoin>(pool, coin_x, coin_y);
    transfer::public_transfer(lp_coin, recipient);
    transfer::public_transfer(coin_x, recipient);
    transfer::public_transfer(coin_y, recipient);
}

// wrong
public fun impure_add_liquidity<CoinX, CoinY, LpCoin>(pool: &mut Pool, coin_x: Coin<CoinX>, coin_y: Coin<CoinY>, ctx: &mut TxContext): Coin<LpCoin> {
    let (lp_coin, coin_x, coin_y) = add_liquidity<CoinX, CoinY, LpCoin>(pool, coin_x, coin_y);
    transfer::public_transfer(coin_x, tx_context::sender(ctx));
    transfer::public_transfer(coin_y, tx_context::sender(ctx));
    lp_coin
}
```

### Coin argument

Pass coins by value with the exact amount needed. This improves readability for frontends.

```move
module conventions::amm;
use sui::coin::Coin;
public struct Pool has key {
    id: UID
}

// right
public fun swap<CoinX, CoinY>(coin_in: Coin<CoinX>): Coin<CoinY> {
    // Implementation omitted.
    abort(0)
}

// wrong
public fun exchange<CoinX, CoinY>(coin_in: &mut Coin<CoinX>, value: u64): Coin<CoinY> {
    // Implementation omitted.
    abort(0)
}
```

### Access control

Use capability objects instead of arrays of addresses. This makes code more composable.

```move
module conventions::access_control;
use sui::sui::SUI;
use sui::balance::Balance;
use sui::coin::{Self, Coin};
use sui::table::{Self, Table};
public struct Account has key, store {
    id: UID,
    balance: u64
}
public struct State has key {
    id: UID,
    // field not necessary as the state lives in the Account objects
    accounts: Table<address, u64>,
    balance: Balance<SUI>
}
// right -> with this function, another protocol can hold the `Account` on behalf of a user.
public fun withdraw(state: &mut State, account: &mut Account, ctx: &mut TxContext): Coin<SUI> {
    let authorized_balance = account.balance;
    account.balance = 0;
    coin::take(&mut state.balance, authorized_balance, ctx)
}

// wrong -> this is less composable.
public fun wrong_withdraw(state: &mut State, ctx: &mut TxContext): Coin<SUI> {
    let sender = tx_context::sender(ctx);
    let authorized_balance = table::borrow_mut(&mut state.accounts, sender);
    let value = *authorized_balance;
    *authorized_balance = 0;
    coin::take(&mut state.balance, value, ctx)
}
```

### Owned vs shared objects

Use owned objects for one-to-one relationships. Use shared objects when multiple actors interact with the same state.

```move
module conventions::vesting_wallet;
use sui::sui::SUI;
use sui::coin::Coin;
use sui::table::Table;
use sui::balance::Balance;
public struct OwnedWallet has key {
    id: UID,
    balance: Balance<SUI>
}
public struct SharedWallet has key {
    id: UID,
    balance: Balance<SUI>,
    accounts: Table<address, u64>
}
// A vesting wallet releases a certain amount of coin over a period of time.
// If the entire balance belongs to one user and the wallet has no additional functionalities, it is best to store it in an owned object.
public fun new(deposit: Coin<SUI>, ctx: &mut TxContext): OwnedWallet {
    // Implementation omitted.
    abort(0)
}
// If you wish to add extra functionality to a vesting wallet, it is best to share the object.
// For example, if you wish the issuer of the wallet to be able to cancel the contract in the future.
public fun new_shared(deposit: Coin<SUI>, ctx: &mut TxContext) {
    // Implementation omitted.
    // shares the `SharedWallet`.
    abort(0)
}
```

### Admin capability

In admin-gated functions, place the capability as the first parameter. This improves autocomplete.

```move
module conventions::social_network;
use std::string::String;
public struct Account has key {
    id: UID,
    name: String
}
public struct Admin has key {
    id: UID,
}
// right -> cap.update(&mut account, b"jose".to_string());
public fun update(_: &Admin, account: &mut Account, new_name: String) {
    // Implementation omitted.
    abort(0)
}

// wrong -> account.update(&cap, b"jose".to_string());
public fun set(account: &mut Account, _: &Admin, new_name: String) {
    // Implementation omitted.
    abort(0)
}
```

## Documentation

### Comments

- Use `///` for user-facing documentation.  
- Use `//` for developer-only insights.  
- Document struct fields and complex function params/returns.  

```move
module conventions::hero;

use std::string::String;
use sui::kiosk::{Kiosk, KioskOwnerCap};

public struct Hero has key, store {
    id: UID,
    // power of the nft
    power: u64
}

/// Creates and returns a new Hero object
public fun new(ctx: &mut TxContext): Hero {
    Hero {
        id: object::new(ctx),
        power: 0
    }
}

// should be initialized before being shared
public fun initialize_hero(hero: &mut Hero) {
    hero.power = 100;
}

public fun start_battle(
    self: &mut Kiosk, // user kiosk
    cap: &KioskOwnerCap, // user kiosk owner cap
    _policy: &TransferPolicy<Hero>, // transfer policy for the game
    hero_id: ID, // hero to use
    battle_id: String // id of the battle to start
) {
    // Implementation omitted.
    abort(0)
}
```


### README

Add a `README.md` to the package root. Include:  

- Description of the package  
- Purpose of the package  
- Usage instructions  
