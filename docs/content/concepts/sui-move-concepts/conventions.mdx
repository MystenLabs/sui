---
title: Move Conventions
description: Recommended Move 2024 best practices for Sui development.
---

This guide outlines recommended conventions and best practices for writing Move smart contracts on Sui. Following these guidelines helps create maintainable, secure, and composable code that aligns with ecosystem standards.

These conventions are recommendations, not strict rules. They represent patterns that have proven effective across many Sui projects and help ensure consistency across the ecosystem.

## Organization principles

### Package

A Sui package consists of:

- a `sources` directory containing the Move code uploaded on-chain  
- a `Move.toml` manifest file that declares dependencies and package metadata  
- a `Move.lock` file that the toolchain generates to lock dependency versions and track published and upgraded package addresses across networks  

Always commit the `Move.lock` file (do not add it to `.gitignore`). Use [automated address management](https://docs.sui.io/concepts/sui-move-concepts/packages/automated-address-management) instead of the old `published-at` field in the manifest.

Optional directories:

- `tests` for package tests  
- `examples` for usage examples  

These are not uploaded when you publish.

```
sources/
    my_module.move
    another_module.move
tests/
    my_module_tests.move
examples/
    using_my_module.move
Move.lock
Move.toml
```

In `Move.toml`:  

- Use PascalCase for package names (`name = "MyPackage"`).  
- Use snake_case for the named address representing the package (`my_package = 0x0`).  

### Modules

Modules are the main building blocks of Move code. Design modules around a single object or data structure. Variant structures should have their own module to reduce complexity.

You no longer need brackets for module declarations. The compiler includes default `use` statements for common modules.

```move
module conventions::wallet;

public struct Wallet has key, store {
    id: UID,
    amount: u64
}
```

### Body

Use comments to divide your module into sections. Use `===` to mark section titles.

```move
module conventions::comments;

// === Imports ===
// === Errors ===
// === Constants ===
// === Structs ===
// === Events ===
// === Method Aliases ===
// === Public functions ===
// === View functions ===
// === Admin functions ===
// === Package functions ===
// === Private functions ===
// === Test functions ===
```

Guidelines:

- Place the `init` function first if it exists.  
- Group functions by purpose and in user-flow order.  
- Use descriptive names like `admin_set_fees`.  
- Keep test-only helpers inside the module; write actual tests in the `tests` directory.  
- Group imports by dependency:  

```move
use std::string::String;
use sui::{
    coin::Coin,
    balance,
    table::Table
};
use my_dep::battle::{Battle, Score};
```

## Naming conventions

### Constants

- Constants: uppercase snake case.  
- Errors: PascalCase starting with `E`.  

```move
module conventions::constants;

const MAX_NAME_LENGTH: u64 = 64;
const EInvalidName: u64 = 0; // correct
const E_INVALID_NAME: u64 = 0; // wrong
```

### Structs

- Declare abilities in this order: `key`, `copy`, `drop`, `store`.  
- Avoid using `Potato` as a suffix (this signals missing abilities).  
- Use positional fields for simple wrappers, dynamic field keys, or tuples.  
- Use the `Event` suffix for event structs.  

```move
module conventions::request;

public struct ReceiptKey(ID) has copy, drop, store;

public struct Receipt<Data> has key, store {
    id: UID,
    data: Data
}

public struct Request(); // correct
public struct RequestPotato {} // wrong
```

### CRUD function names

Standard names:

- `new` → create an empty object  
- `empty` → create an empty struct  
- `create` → create an initialized object  
- `add` / `remove` → add or remove a value  
- `exists` / `contains` → check existence  
- `borrow` / `borrow_mut` → return a reference  
- `property_name` / `property_name_mut` → return a field  
- `drop` → drop a struct  
- `destroy` / `destroy_empty` → destroy an object  
- `to_name` / `from_name` → type transformations  

### Generics

Use either single letters (`T`, `U`) or descriptive names. Prioritize readability.

```move
public struct Receipt<T> has store { ... }
public struct Receipt<Data> has store { ... }
```

## Code structure

### Shared objects

Provide one function to instantiate an object and another to share it. This lets callers compose logic before sharing.

```move
public fun new(ctx: &mut TxContext): Shop {
    Shop { id: object::new(ctx) }
}

public fun share(shop: Shop) {
    transfer::share_object(shop);
}
```

### Pure functions

Keep core functions pure. Avoid `transfer::transfer` inside them, except for non-transferable objects.

```move
// right → returns leftover coins
public fun add_liquidity<CoinX, CoinY, LpCoin>(...): (Coin<LpCoin>, Coin<CoinX>, Coin<CoinY>) { ... }

// right but less composable
public fun add_liquidity_and_transfer(...) { ... }

// wrong → impure
public fun impure_add_liquidity(...) { ... }
```

### Coin argument

Pass coins by value with the exact amount needed. This improves readability for frontends.

```move
// right
public fun swap<CoinX, CoinY>(coin_in: Coin<CoinX>): Coin<CoinY> { ... }

// wrong
public fun exchange<CoinX, CoinY>(coin_in: &mut Coin<CoinX>, value: u64): Coin<CoinY> { ... }
```

### Access control

Use capability objects instead of arrays of addresses. This makes code more composable.

```move
// right
public fun withdraw(state: &mut State, account: &mut Account, ctx: &mut TxContext): Coin<SUI> { ... }

// wrong
public fun wrong_withdraw(state: &mut State, ctx: &mut TxContext): Coin<SUI> { ... }
```

### Owned vs shared objects

Use owned objects for one-to-one relationships. Use shared objects when multiple actors interact with the same state.

```move
public fun new(deposit: Coin<SUI>, ctx: &mut TxContext): OwnedWallet { ... }
public fun new_shared(deposit: Coin<SUI>, ctx: &mut TxContext) { ... }
```

### Admin capability

In admin-gated functions, place the capability as the first parameter. This improves autocomplete.

```move
// right
public fun update(_: &Admin, account: &mut Account, new_name: String) { ... }

// wrong
public fun set(account: &mut Account, _: &Admin, new_name: String) { ... }
```

## Documentation

### Comments

- Use `///` for user-facing documentation.  
- Use `//` for developer-only insights.  
- Document struct fields and complex function params/returns.  

```move
/// Creates and returns a new Hero object
public fun new(ctx: &mut TxContext): Hero { ... }

// must be initialized before sharing
public fun initialize_hero(hero: &mut Hero) { ... }
```

### README

Add a `README.md` to the package root. Include:  

- description of the package  
- purpose of the package  
- usage instructions  
