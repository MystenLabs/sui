---
title: Derived Objects
description: Derived objects enable deterministic object addressing, Transfer-to-Object capabilities, guaranteed uniqueness, and native parallelization for building scalable composable systems on Sui.
keywords: [ Derived objects, deterministic addressing, Transfer-to-Object, TTO, parallelization, object composition, scalability ]
---

Derived objects enable you to deterministically compute object IDs from a parent object ID and a key, both on- and off-chain. Put another way, the derived object logic means you can can compute the ID of an object before it's even created on the network. 



<details>
<summary>
`derived_object` package source
</summary>
<ImportContent source="crates/sui-framework/packages/sui-framework/sources/derived_object.move" mode="code" />
</details>

## Core capabilities

Derived objects provide four fundamental capabilities:

### Deterministic addressing

Object IDs can be computed ahead of time using `derived_object::derive_address(parent_id, key)`. This means applications can predict where objects will live before they exist, enabling sophisticated coordination patterns and reducing the need for on-chain lookups.

### Transfer-to-Object (TTO) compatibility

Because addresses are computable, objects can receive transfers even before they exist. Send assets to a derived address, then create the object later to claim them. This enables patterns like:

- Pre-funding accounts before user onboarding.
- Conditional object creation based on received assets.
- Cross-chain bridging to deterministic destinations.

### One-per-key uniqueness

Each `(parent, key)` pair maps to exactly one object address. This gives you registry-like uniqueness guarantees without the registry bottleneck. Perfect for soulbound tokens, per-user configurations, or any scenario requiring unique slots.

### Native parallelization

Unlike dynamic fields that funnel operations through a parent object, derived objects operate independently after creation. Unrelated keys can be modified in parallel, eliminating consensus hotspots while maintaining namespace guarantees.

These capabilities combine to enable entirely new design patterns that were previously impossible or inefficient on other blockchains.

**On-chain benefits**

-	Less contention and better parallelism: No parent bottleneck for unrelated keys.
-	Deterministic uniqueness: One object per (parent, key) without manual bookkeeping.
-	Top-level object ergonomics: Clean capability patterns, Object Display, and simpler permissioning.

**Off-chain benefits**

-	Fewer hops: Clients can compute or look up the derived ID directly instead of going through the parent.
-	Better discoverability/indexing: Explorers/SDKs can infer or cache the parent-key namespace with fewer sequential queries.
-	Lean SDK calls: Less querying needed, minimizing the SDK codebase and requiring less network traffic.

## Derived objects and dynamic fields matrix

The following matrix highlights some of the differences between using dynamic fields versus derived objects. Considering the tradeoffs helps you select the optimum approach for your project.

| Aspect | Derived objects | Dynamic fields |
| --- | --- | --- |
| Address predictability | ✅ Yes | ✅ Yes |
| Parent required? | Only to create | ✅ Yes |
| Ownership type | Any. Can be wrapped or shared, owned, party, or frozen. | Cannot be independently owned. Owner is always the parent. |
| Supports receiving objects? | ✅ Yes | ❌ No |
| Object parallelism | ✅ Yes | Limited. All writes sequenced through parent. |
| Loading type | Static. Direct access after creation. | Dynamic. They are loaded through the parent. |
| Supports deletion? | ✅ Yes | ✅ Yes |
| Supports reclaiming? | ❌ Currently no | ✅ Yes |

## Use cases

Derived objects enable many useful patterns:

### Gaming: Deterministic loot boxes

Players can compute loot box addresses before opening. This allows for pre-funding, conditional reveals, and parallel processing.

```move
public fun derive_loot_box_address(game_id: ID, player: address, box_type: u8): address {
    let key = bcs::to_bytes(&player);
    vector::append(&mut key, bcs::to_bytes(&box_type));
    derived_object::derive_address(game_id, key)
}
```

### DeFi: Per-user trading accounts

Each user gets a unique trading account that can receive assets before the user even creates it, enabling seamless onboarding.

```move
public fun create_trading_account(exchange_id: &mut UID, ctx: &mut TxContext): TradingAccount {
    let account = TradingAccount {
        id: derived_object::claim(exchange_id, ctx.sender()),
        balance: 0,
        positions: vector::empty(),
    };
    account
}
```

### Social: Content addressing

Social media posts, NFT collections, or any content can have deterministic addresses based on creator and content hash.

```move
public fun derive_post_address(platform_id: ID, creator: address, content_hash: vector<u8>): address {
    let key = bcs::to_bytes(&creator);
    vector::append(&mut key, content_hash);
    derived_object::derive_address(platform_id, key)
}
```

### Cross-chain: Bridged asset destinations

Bridge contracts can compute destination addresses on Sui before assets arrive, enabling atomic cross-chain swaps.

```move

public fun derive_bridge_vault(bridge_id: ID, source_chain: u8, source_tx: vector<u8>): address {
    let key = bcs::to_bytes(&source_chain);
    vector::append(&mut key, source_tx);
    derived_object::derive_address(bridge_id, key)
}
```

### Registries: Comparison between traditional and derived object patterns {#registries}

The following code examples demonstrate the registry use case, comparing dynamic field tables, pointer-based registries, and derived objects. While registries are just one application of derived objects, the following patterns illustrate the core tradeoffs.

#### Classic registry

Perhaps the biggest advantage for classic registries are the straightforward queries. This increased discoverability comes at the cost of parallelization, however, as all operations must go through the parent object.

```move
const EVaultAlreadyExists: u64 = 0;

public struct VaultRegistry has key {
  id: UID,
  vaults: Table<address, Vault>,
}

public struct Vault has key, store {
  id: UID,
}

// Creating a vault goes through the registry and is stored there.
public fun new(registry: &mut VaultRegistry, ctx: &mut TxContext) {
  assert!(!registry.vaults.contains(ctx.sender()), EVaultAlreadyExists);

  let vault = Vault {
    id: object::new(ctx),
  };

  registry.vaults.add(ctx.sender(), vault);
}

// Access vault through parent
public fun receive_from_vault<T key + store>(
  registry: &mut VaultRegistry,
  receiving: Receiving<T>,
  ctx: &mut TxContext,
): T {
  let vault = registry.vaults.borrow_mut(ctx.sender());

  let obj = transfer::public_receive(&mut vault.id, receiving);

  obj
}
```

#### Registry with pointer

If parallelization is an important aspect for your project needs, you could create a registry that uses a pointer. This approach provides good parallelization, but makes discoverability a 2-sequential-network-hop operation. To find a vault, you first have to find its pointer.

```move
const EVaultAlreadyExists: u64 = 0;

public struct VaultRegistry has key {
  id: UID,
  vaults: Table<address, Vault>,
}

public struct Vault has key, store {
  id: UID,
}

// Creating a vault goes through the registry but only a pointer to the vault is stored there.
public fun new(registry: &mut VaultRegistry, ctx: &mut TxContext) {
  assert!(!registry.vaults.contains(ctx.sender()), EVaultAlreadyExists);

  let vault = Vault {
    id: object::new(ctx),
  };

  registry.vaults.add(ctx.sender(), vault.id.to_inner());

  transfer::transfer(vault, ctx.sender());
}

// Access vault without relying on parent
public fun receive_from_vault<T key + store>(
  vault: &mut Vault,
  receiving: Receiving<T>,
  ctx: &mut TxContext,
): T {

  let obj = transfer::public_receive(&mut vault.id, receiving);

  obj
}
```

#### Derived objects

Using derived objects doesn't require a tradeoff between discoverability and parallelization.  

```move
const EVaultAlreadyExists: u64 = 0;

public struct VaultRegistry has key {
  id: UID,
  vaults: Table<address, Vault>,
}

public struct Vault has key, store {
  id: UID,
}

// Creating a unique soulbound vault from address.
public fun new(registry: &mut VaultRegistry, ctx: &mut TxContext) {
  assert!(!derived_objects::exists(&registry.id, ctx.sender()), EVaultAlreadyExists);

  let vault = Vault {
    id: derived_object::claim(&mut registry.id, ctx.sender()),
  };

  transfer::transfer(vault, ctx.sender());
}

// Access vault without relying on parent
public fun receive_from_vault<T key + store>(
  vault: &mut Vault,
  receiving: Receiving<T>,
): T {

  let obj = transfer::public_receive(&mut vault.id, receiving);

  obj
}

```

## Related links

<RelatedLink to="/concepts/dynamic-fields" />
<RelatedLink to="/concepts/object-ownership" />
<RelatedLink to="/concepts/transfers/transfer-to-object" />
<RelatedLink href="https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/derived_object.move" label="`derived_object` module" desc="The code that defines derived objects on Sui." />