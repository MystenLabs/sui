---
title: Derived Objects
description: Derived objects enable deterministic object addressing, Transfer-to-Object capabilities, guaranteed uniqueness, and native parallelization for building scalable composable systems on Sui.
keywords: [ Derived objects, deterministic addressing, Transfer-to-Object, TTO, parallelization, object composition, scalability ]
---

Derived objects enable you to deterministically compute object IDs from a parent object ID and a key, both on- and off-chain. This means you can compute the ID of a derived object before you ever create it on the blockchain. 

Most objects on Sui get an ID assigned to them upon object creation that is guarnateed to be unique to every other object on the network. Derived objects, on the other hand, have an ID that is claimed from the mapping of a parent object and a key. This `parent-key` mapping ensures that the claimed ID is a singular namespace because the objects derived from the parent object (unique ID that exists on-chain) are paired with individual keys. It's this mapping that makes the resulting ID of derived objects deterministic.

When you claim an ID from the `derived_object` module, you pass the parent object and key. The parent object already exists on-chain, either at package publish time or through a transaction with the smart contract. The parent object is [shared](/concepts/object-ownership/shared.mdx) so that any user can create a derived object using the same parent. 

The key is typically an address or other object ID, which are themselves unique. This is not a requirement, though, as the `derived_object` module uses a `ClaimedStatus` enum to mark already claimed IDs as `Reserved`. Trying to claim an ID with a `Reserved` enum value results in transaction failure. So, you could use something like the US lowercase alphabet as your key, but would then be limited to 24 derived objects from one parent.

Although claiming the ID of the derived object requires a parent object, the derived object is not a child of the parent. This is an important distinction as the the lack of a hierarchal relationship means that using the derived object as inputs to your transactions does not require sequential processing through the parent. The derived object is its own entity; the parent only exists to ensure its uniqueness. This relationship provides parallelization that is not possible with parent-child relationships.

Because you can compute the ID of a derived object off-chain, your client logic is able to treat as-yet unclaimed IDs as if they already exist. If your key is a limited one, such as the US alphabet, and two clients tried to claim the ID from the same parent using the `r` key, then the first one to submit the transaction claims the ID and the subsequent client transaction fails.

<details>
<summary>
`derived_object` package source
</summary>
<ImportContent source="crates/sui-framework/packages/sui-framework/sources/derived_object.move" mode="code" />
</details>

## Core capabilities

Derived objects provide four fundamental capabilities:

### Deterministic addressing

Object IDs can be computed ahead of time using `derived_object::derive_address(parent_id, key)`. This means applications can predict where objects will live before they exist, enabling sophisticated coordination patterns and reducing the need for on-chain lookups.

### Transfer-to-Object (TTO) compatibility

Because addresses are computable, objects can receive transfers even before they exist. Send assets to a derived address, then create the object later to claim them. This enables patterns like:

- Pre-funding accounts before user onboarding.
- Conditional object creation based on received assets.
- Cross-chain bridging to deterministic destinations.

### One-per-key uniqueness

Each `(parent, key)` pair maps to exactly one object address. This gives you registry-like uniqueness guarantees without the registry bottleneck. Perfect for soulbound tokens, per-user configurations, or any scenario requiring unique slots.

### Native parallelization

Unlike dynamic fields that funnel operations through a parent object, derived objects operate independently after creation. Unrelated keys can be modified in parallel, eliminating consensus hotspots while maintaining namespace guarantees.

These capabilities combine to enable entirely new design patterns that were previously impossible or inefficient on other blockchains.

**On-chain benefits**

-	Less contention and better parallelism: No parent bottleneck for unrelated keys.
-	Deterministic uniqueness: One object per (parent, key) without manual bookkeeping.
-	Top-level object ergonomics: Clean capability patterns, Object Display, and simpler permissioning.

**Off-chain benefits**

-	Fewer hops: Clients can compute or look up the derived ID directly instead of going through the parent.
-	Better discoverability/indexing: Explorers/SDKs can infer or cache the parent-key namespace with fewer sequential queries.
-	Lean SDK calls: Less querying needed, minimizing the SDK codebase and requiring less network traffic.

## Derived objects and dynamic fields matrix

The following matrix highlights some of the differences between using dynamic fields versus derived objects. Considering the tradeoffs helps you select the optimum approach for your project.

| Aspect | Derived objects | Dynamic fields |
| --- | --- | --- |
| Address predictability | ✅ Yes | ✅ Yes |
| Parent required? | Only to create | ✅ Yes |
| Ownership type | Any. Can be wrapped or shared, owned, party, or frozen. | Cannot be independently owned. Owner is always the parent. |
| Supports receiving objects? | ✅ Yes | ❌ No |
| Object parallelism | ✅ Yes | Limited. All writes sequenced through parent. |
| Loading type | Static. Direct access after creation. | Dynamic. They are loaded through the parent. |
| Supports deletion? | ✅ Yes | ✅ Yes |
| Supports reclaiming? | ❌ Currently no | ✅ Yes |

## Registries {#registries}

The possibilities and uses for derived objects are only limited by your imagination (or AI prompt quotas). One of the more obvious implementations is their application in registries. The following examples compare dynamic field tables, pointer-based, and derived objects registries to illustrate the core tradeoffs between the different patterns.

### Classic registry

Perhaps the biggest advantage for classic registries are the straightforward queries. This increased discoverability comes at the cost of parallelization, however, as all operations must go through the parent object.

```move
const EVaultAlreadyExists: u64 = 0;

public struct VaultRegistry has key {
  id: UID,
  vaults: Table<address, Vault>,
}

public struct Vault has key, store {
  id: UID,
}

// Creating a vault goes through the registry and is stored there.
public fun new(registry: &mut VaultRegistry, ctx: &mut TxContext) {
  assert!(!registry.vaults.contains(ctx.sender()), EVaultAlreadyExists);

  let vault = Vault {
    id: object::new(ctx),
  };

  registry.vaults.add(ctx.sender(), vault);
}

// Access vault through parent
public fun receive_from_vault<T key + store>(
  registry: &mut VaultRegistry,
  receiving: Receiving<T>,
  ctx: &mut TxContext,
): T {
  let vault = registry.vaults.borrow_mut(ctx.sender());

  let obj = transfer::public_receive(&mut vault.id, receiving);

  obj
}
```

### Registry with pointer

If parallelization is an important aspect for your project needs, you could create a registry that uses a pointer. This approach provides good parallelization, but requires 2 sequential network hops to discover. To find a vault, you first have to find its pointer.

```move
const EVaultAlreadyExists: u64 = 0;

public struct VaultRegistry has key {
  id: UID,
  vaults: Table<address, Vault>,
}

public struct Vault has key, store {
  id: UID,
}

// Creating a vault goes through the registry but only a pointer to the vault is stored there.
public fun new(registry: &mut VaultRegistry, ctx: &mut TxContext) {
  assert!(!registry.vaults.contains(ctx.sender()), EVaultAlreadyExists);

  let vault = Vault {
    id: object::new(ctx),
  };

  registry.vaults.add(ctx.sender(), vault.id.to_inner());

  transfer::transfer(vault, ctx.sender());
}

// Access vault without relying on parent
public fun receive_from_vault<T key + store>(
  vault: &mut Vault,
  receiving: Receiving<T>,
  ctx: &mut TxContext,
): T {

  let obj = transfer::public_receive(&mut vault.id, receiving);

  obj
}
```

### Derived objects

Using derived objects doesn't require a tradeoff between discoverability and parallelization.  

```move
const EVaultAlreadyExists: u64 = 0;

public struct VaultRegistry has key {
  id: UID,
  vaults: Table<address, Vault>,
}

public struct Vault has key, store {
  id: UID,
}

// Creating a unique soulbound vault from address.
public fun new(registry: &mut VaultRegistry, ctx: &mut TxContext) {
  assert!(!derived_objects::exists(&registry.id, ctx.sender()), EVaultAlreadyExists);

  let vault = Vault {
    id: derived_object::claim(&mut registry.id, ctx.sender()),
  };

  transfer::transfer(vault, ctx.sender());
}

// Access vault without relying on parent
public fun receive_from_vault<T key + store>(
  vault: &mut Vault,
  receiving: Receiving<T>,
): T {

  let obj = transfer::public_receive(&mut vault.id, receiving);

  obj
}

```

## Related links

<RelatedLink to="/concepts/dynamic-fields" />
<RelatedLink to="/concepts/object-ownership" />
<RelatedLink to="/concepts/transfers/transfer-to-object" />
<RelatedLink href="https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/derived_object.move" label="`derived_object` module" desc="The code that defines derived objects on Sui." />