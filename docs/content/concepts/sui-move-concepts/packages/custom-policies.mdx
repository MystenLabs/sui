---
title: Custom Upgrade Policies
description: Custom upgrade policies let you upgrade live packages while addressing the security risks of single-key ownership upgrades.
keywords: [ upgrade policies, custom upgrade policies, immutable policy, dependency policy, additive policy, compatible policy, create an upgrade policy, isolate a policy ] 
mdx:
  format: md
---

Upgrading a package on-chain with a single key poses security risks:

{@include: ../../../snippets/upgrade-single-key-risk.mdx}

To reduce these risks while still allowing [package upgrades](./upgrade.mdx), Sui supports **custom upgrade policies**. These policies protect `UpgradeCap` access and issue `UpgradeTicket` objects that authorize upgrades on a case-by-case basis.

## Compatibility {#compatibility}

Sui provides built-in package compatibility policies, listed from most to least strict:

| Policy          | Description                                                                                                                                                                                                                       |
| --------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Immutable       | No one can upgrade the package.                                                                                                                                                                                                  |
| Dependency-only | You can modify only the dependencies of the package.                                                                                                                                                                             |
| Additive        | You can add new functionality (for example, new public functions or structs), but you cannot change existing functionality (for example, you cannot modify code inside existing public functions).                               |
| Compatible      | The most relaxed policy. In addition to the above, you can change all function implementations, relax ability constraints on generics, and change or remove private and friend functions. You cannot change public function signatures or existing types. |

Each policy is a superset of the one above it.  

By default, a published package uses the most relaxed, **compatible** policy. You can publish a package inside a transaction that sets a stricter policy before completion.  

You can also restrict an existing package’s policy using functions in `sui::package` (`only_additive_upgrades`, `only_dep_upgrades`, `make_immutable`). Policies can only become more restrictive over time. For example, after you call `only_dep_upgrades`, a call to `only_additive_upgrades` on the same package fails.

## Upgrade overview {#upgrade-overview}

A package upgrade must occur end-to-end in a single transaction. It has three steps:

1. **Authorization:** Get permission from the `UpgradeCap`, creating an `UpgradeTicket`.  
2. **Execution:** Use the `UpgradeTicket` to verify bytecode and compatibility, then create the new package. On success, return an `UpgradeReceipt`.  
3. **Commit:** Update the `UpgradeCap` with the new package details.  

Step 2 is built in, while steps 1 and 3 are Move functions provided by the Sui framework:

{@inject:  ../../../../../crates/sui-framework/packages/sui-framework/sources/package.move#fun=authorize_upgrade,commit_upgrade noComments}

The Sui client CLI (`sui client upgrade`) uses these functions. Custom upgrade policies add extra conditions (such as voting, governance, allowlists, or timelocks) before an `UpgradeCap` can authorize or commit.  

Any pair of functions that creates an `UpgradeTicket` and consumes an `UpgradeReceipt` to update an `UpgradeCap` is a valid custom upgrade policy.

## UpgradeCap {#upgradecap}

The `UpgradeCap` coordinates package upgrades:

{@inject:  ../../../../../crates/sui-framework/packages/sui-framework/sources/package.move#struct=UpgradeCap noComments}

Publishing a package creates its `UpgradeCap`. Upgrading the package updates it. The `UpgradeCap` owner can:

- Change compatibility requirements for future upgrades.  
- Authorize upgrades.  
- Make the package immutable.  

API guarantees include:

- Only the latest package version can be upgraded (linear history).  
- Only one upgrade can be in progress at a time.  
- An upgrade can only be authorized for one transaction (no storing tickets).  
- Policies can only become stricter.  

## UpgradeTicket {#upgradeticket}

{@inject:  ../../../../../crates/sui-framework/packages/sui-framework/sources/package.move#struct=UpgradeTicket noComments}

An `UpgradeTicket` proves that an upgrade was authorized. It ties authorization to:

- A specific package ID (must be the latest version for that `UpgradeCap`).  
- A specific compatibility policy.  
- A specific digest of the new package contents.  

You must use an `UpgradeTicket` in the same transaction where it was created, or the transaction fails.

### Package digest {#package-digest}

The `digest` field comes from the `authorize_upgrade` call. Custom policies can check this digest against known code.  

Digest calculation:

1. Collect bytecode for all modules.  
2. Append transitive dependencies.  
3. Sort the list lexicographically.  
4. Hash each entry with `Blake2B`.  

Use the Move toolchain to output the digest with `--dump-bytecode-as-base64`:

```sh
$ sui move build --dump-bytecode-as-base64
```

## UpgradeReceipt {#upgradereceipt}

{@inject:  ../../../../../crates/sui-framework/packages/sui-framework/sources/package.move#struct=UpgradeReceipt noComments}

An `UpgradeReceipt` proves that an upgrade succeeded and created a new package. It updates the `UpgradeCap` with the new package ID.  

Like `UpgradeTicket`, you must use an `UpgradeReceipt` in the same transaction.

## Isolating policies {#isolating-policies}

When writing custom upgrade policies:

- Place the policy in a separate package.  
- Make the policy package immutable.  
- Lock the `UpgradeCap` policy to prevent making it less restrictive later.  

These practices ensure **informed user consent** and **bounded risk**: users know the upgrade rules before locking value into a package, and the rules cannot quietly become more permissive.

## Example: day-of-week policy {#example-upgrade}

This example shows how to create a policy that allows upgrades only on a chosen day of the week.

### Create the policy {#creating-upgrade-policy}

Start a new package:

```sh
$ sui move new policy
```

Add `day_of_week.move` under `sources/`:

```move
module policy::day_of_week;

use sui::package;

const ENotWeekDay: u64 = 1;

public struct UpgradeCap has key, store {
    id: UID,
    cap: package::UpgradeCap,
    day: u8,
}

public fun new_policy(
    cap: package::UpgradeCap,
    day: u8,
    ctx: &mut TxContext,
): UpgradeCap {
    assert!(day < 7, ENotWeekDay);
    UpgradeCap { id: object::new(ctx), cap, day }
}
```

Continue extending the module with weekday checks, `authorize_upgrade`, `commit_upgrade`, and `make_immutable`. (See full example in the original doc.)

### Publish the policy {#publishing-an-upgrade-policy}

Publish with the CLI:

```sh
$ sui client publish
```

After publishing, make the policy immutable:

```sh
$ sui client call \
    --package 0x2 \
    --module 'package' \
    --function 'make_immutable' \
    --args <UPGRADECAP-ID>
```

### Create and test a package {#creating-testing-package}

Create a simple package to upgrade:

```sh
$ sui move new example
```

Add `example.move`:

```move
module example::example {
    struct Event has copy, drop { x: u64 }
    entry fun nudge() {
        sui::event::emit(Event { x: 41 })
    }
}
```

### Use the TypeScript SDK {#using-typescript-sdk}

Install the SDK:

```sh
$ npm install @mysten/sui
```

Create scripts (`publish.js`, `upgrade.js`) to publish and upgrade the example package using your policy. (See full code samples in the original doc.)  

Run the scripts with Node.js:

```sh
$ node publish.js
$ node upgrade.js
```

If today matches your policy’s day (for example, Tuesday), the upgrade succeeds. Otherwise, it fails with error code `ENotAllowedDay`.

## Summary

- Custom policies extend built-in upgrade rules with governance logic.  
- Policies work by wrapping `UpgradeCap` access.  
- Use `UpgradeTicket` and `UpgradeReceipt` within one transaction.  
- Isolate and lock down policy packages to ensure predictable upgrade rules.  
