---
title: Upgrading Packages
description: Sui provides a method of upgrading your packages while still retaining their immutable properties.
keywords: [ upgrading packages, upgrade considerations, how to upgrade a package, how to upgrade, update package, update, how to update ]
mdx:
  format: md
---

Sui smart contracts are immutable package objects consisting of Move modules. Because packages are immutable, transactions can safely access them without requiring full consensus (fastpath transactions). If packages could change, they would become [shared objects](/concepts/object-ownership/shared.mdx#shared), requiring full consensus before completing a transaction.

Immutability creates challenges for iterative development. Developers need to update code and pull changes from others while keeping the benefits of fastpath transactions. To solve this, Sui provides a method to **upgrade packages** while retaining their immutable properties.

## Upgrade considerations

Keep these details in mind before upgrading:

- **Module initializers don’t re-run.** When you publish a package, the `init` function runs once at publish time. Any `init` functions in later versions are ignored. See [Module Initializer](https://move-book.com/programmability/module-initializer.html) in *The Move Book*.  
- **Old packages remain on-chain.** You cannot delete old versions, and nothing prevents other packages from using their methods and types. Users may also continue to rely on them.

### Example: changing a function

Original package:

```move
public fun increment(c: &mut Counter) {
    c.value = c.value + 1;
}
```

Upgraded package:

```move
public struct Progress has copy, drop {
    reached: u64
}

public fun increment(c: &mut Counter) {
    c.value = c.value + 1;
    if (c.value % 100 == 0) {
        event::emit(Progress { reached: c.value });
    }
}
```

Mixing callers from both versions fails because the old function is unaware of the new `Progress` event.  

### Example: introducing new types

If an object type’s logic changes, introduce a new type in the upgraded package and provide a migration function. For example:  

- To replace a flawed shared object, add a new type and setup function in the upgraded package.  
- Protect migration with an `AdminCap` so only the package owner can initiate it.  
- Optionally add a flag to temporarily disable the old shared object during migration.  

## Versioned shared objects

When your package involves shared objects, design for upgrades from the start. A good pattern is to version your shared object and check versions at runtime.  

Original `counter` module:

```move
module example::counter;

public struct Counter has key {
    id: UID,
    value: u64,
}

fun init(ctx: &mut TxContext) {
    transfer::share_object(Counter { id: object::new(ctx), value: 0 })
}

public fun increment(c: &mut Counter) {
    c.value = c.value + 1;
}
```

Upgrade-aware version:

```move
module example::counter;

const ENotAdmin: u64 = 0;
const EWrongVersion: u64 = 1;

const VERSION: u64 = 1;

public struct Counter has key {
    id: UID,
    version: u64,
    admin: ID,
    value: u64,
}

public struct AdminCap has key { id: UID }

fun init(ctx: &mut TxContext) {
    let admin = AdminCap { id: object::new(ctx) };
    transfer::share_object(Counter {
        id: object::new(ctx),
        version: VERSION,
        admin: object::id(&admin),
        value: 0,
    });
    transfer::transfer(admin, ctx.sender());
}

public fun increment(c: &mut Counter) {
    assert!(c.version == VERSION, EWrongVersion);
    c.value = c.value + 1;
}
```

### Upgraded module with migration

```move
module example::counter;

use sui::event;

const ENotAdmin: u64 = 0;
const ENotUpgrade: u64 = 1;
const EWrongVersion: u64 = 2;

const VERSION: u64 = 2;

public struct Counter has key {
    id: UID,
    version: u64,
    admin: ID,
    value: u64,
}

public struct AdminCap has key { id: UID }

public struct Progress has copy, drop { reached: u64 }

fun init(ctx: &mut TxContext) {
    let admin = AdminCap { id: object::new(ctx) };
    transfer::share_object(Counter {
        id: object::new(ctx),
        version: VERSION,
        admin: object::id(&admin),
        value: 0,
    });
    transfer::transfer(admin, ctx.sender());
}

public fun increment(c: &mut Counter) {
    assert!(c.version == VERSION, EWrongVersion);
    c.value = c.value + 1;
    if (c.value % 100 == 0) {
        event::emit(Progress { reached: c.value })
    }
}

entry fun migrate(c: &mut Counter, a: &AdminCap) {
    assert!(c.admin == object::id(a), ENotAdmin);
    assert!(c.version < VERSION, ENotUpgrade);
    c.version = VERSION;
}
```

After upgrading, call `migrate` in a follow-up transaction to update the shared object.  

## Upgrade requirements

Your package must meet these requirements:

- You must have an `UpgradeTicket` for the package. Publishing a package creates an `UpgradeCap`, which can issue `UpgradeTickets`. The Sui client CLI manages this automatically.  
- Changes must be layout-compatible with the previous version:  
  - Public function signatures must remain the same.  
  - Struct layouts (including abilities) must remain the same.  
  - You can add new structs and functions.  
  - You can remove generic type constraints.  
  - You can change function implementations.  
  - You can change non-public signatures (`friend`, `entry`).  

:::info
If a dependency upgrades, your package does not automatically update. You must explicitly upgrade it to point to the new version.
:::

## Upgrading

Use the `sui client upgrade` command.  

{@include: ../../../snippets/info-gas-budget.mdx}

- `--gas-budget`: Maximum gas units before the network cancels the transaction.  
- `--cap`: The ID of the `UpgradeCap` (returned from the publish command).  

The CLI:  

- Generates the upgrade digest.  
- Authorizes the upgrade with the `UpgradeCap` to create an `UpgradeTicket`.  
- Updates the `UpgradeCap` with the `UpgradeReceipt`.  

See the Move docs for the [package module](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/docs/sui/package.md) for details.  

## Example

Package manifest:

```toml
[package]
name = "sui_package"
version = "0.0.0"

[addresses]
sui_package = "0x0"
```

Publish:

```sh
$ sui client publish
```

The result includes an **Object changes** section with your package ID and `UpgradeCap` ID.

<Tabs>

<TabItem value="automated-address-management" label="Automated addresses">

:::info
As of Sui `v1.29.0`, addresses are automatically managed in the `Move.lock` file. No further action is needed.  

If you published with an earlier version, see [adopting automated address management](automated-address-management#adopting-automated-address-management-for-published-packages).
:::

</TabItem>

<TabItem value="manual-address-management" label="Manual addresses">

If your package has not adopted automated address management, edit your `Move.toml`:  

```toml
[package]
name = "sui_package"
version = "0.0.0"
published-at = "<ORIGINAL-PACKAGE-ID>"

[addresses]
sui_package = "<ORIGINAL-PACKAGE-ID>"
```

Before upgrading, set `sui_package = "0x0"` again:

```toml
[package]
name = "sui_package"
version = "0.0.1"
published-at = "<ORIGINAL-PACKAGE-ID>"

[addresses]
sui_package = "0x0"
```

</TabItem>

</Tabs>

Run upgrade:

```sh
$ sui client upgrade --upgrade-capability <UPGRADE-CAP-ID>
```

The result provides a new package ID.

<Tabs>

<TabItem value="automated-address-management" label="Automated addresses">

:::info
As of Sui `v1.29.0`, upgraded addresses are automatically managed in the `Move.lock` file. No further action is needed.  
:::

</TabItem>

<TabItem value="manual-address-management" label="Manual addresses">

Edit your `Move.toml` again so dependents know where to find the new package:

```toml
[package]
name = "sui_package"
version = "0.0.1"
published-at = "<UPGRADED-PACKAGE-ID>"

[addresses]
sui_package = "<ORIGINAL-PACKAGE-ID>"
```

Update `published-at` after each upgrade. The `[addresses]` entry always points to the original ID, but must be set to `0x0` before the next upgrade.  

</TabItem>

</Tabs>
