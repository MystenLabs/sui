---
title: Transfer to Object
description: On Sui, you can transfer objects to objects in the same way you transfer objects to addresses.
---

You can transfer objects to an object ID in the same way you transfer them to an address, using the same functions. This works because Sui does not distinguish between the 32-byte ID of an address and the 32-byte ID of an object (which never overlap). The transfer-to-object operation uses this feature by letting you provide an object ID as the address input of a transfer.

:::note
The transfer-to-object mechanism is not supported for [Party Objects](../object-ownership/party.mdx) whose owning address corresponds to an object ID.
:::

Because IDs share the same structure, you can use an object ID wherever an address is expected. All functionality for address-owned objects applies to objects owned by other objects—you simply replace the address with the object ID.

When you transfer an object to another object, you establish a parent–child relationship. Objects transferred to a parent can be received by the owner of the parent (directly or transitively). The module that defines the parent object type also defines access control for receiving child objects.

These restrictions are enforced dynamically through mutable access to the parent object’s `UID` during transaction execution. As a result, you can transfer objects to, and receive them from, owned objects, dynamic field objects, wrapped objects, and shared objects.

One benefit of transfer-to-object is the ability to have a stable ID for an on-chain wallet or account. The transfer does not affect the object’s ID, regardless of where it is held. When you transfer an object, all of its child objects move with it, and the object’s ID remains the same whether it is transferred, wrapped, or used as a dynamic field.

## Transferring to an object

As with normal transfers, the target object ID must exist. The target object must not be immutable, since you cannot access an object transferred to an immutable object.

Be aware of both the type of the receiving object and the type of the transferred object. The receiving (parent) object can:

- Define predicates that are checked dynamically when accessing the transferred object.
- Omit support for accessing transferred objects. Future versions of its defining module might add this functionality, but it is optional.

If the transferred object has only the `key` ability:

- Its defining module must implement a custom receive function. This function may enforce arbitrary restrictions, or may not exist at all.
- After sending, you cannot access the object unless:
  - The parent object’s module defines a function to receive objects, and
  - The child object’s module defines a function to receive it, and
  - All restrictions from both functions are satisfied.

```move
// 0xADD is an address
// 0x0B is an object ID
// b and c are objects

// Transfers the object `b` to the address 0xADD
transfer::public_transfer(b, @0xADD);

// Transfers the object `c` to the object with ID 0x0B
transfer::public_transfer(c, @0x0B);
```

Transferring to an object ID produces the same effect as transferring to an address: the object’s owner becomes the provided ID. Because the result is identical, you can use existing RPC methods such as `getOwnedObjects` on the ID. If the ID is an address, the method returns the objects owned by that address. If it is an object ID, it returns the objects that the object ID owns.

```json
// Get the objects owned by the address 0xADD. Returns `b`.
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "suix_getOwnedObjects",
  "params": [
    "0xADD"
  ]
}

// Get the objects owned by the object with ID 0x0B. Returns `c`.
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "suix_getOwnedObjects",
  "params": [
    "0x0B"
  ]
}
```

## Receiving objects

After an object `c` is sent to an object `p`, `p` must receive it before use. To receive `c`, a programmable transaction block (PTB) uses the `Receiving(o: ObjectRef)` argument type. This takes the sent object’s `ObjectID`, `Version`, and `Digest`, similar to owned object arguments in PTBs. However, `Receiving` arguments are not passed as owned values or mutable references.

The receiving interface is defined in the `transfer` module of the Sui framework:

```move
module sui::transfer;

/// Represents the ability to receive an object of type `T`. Cannot be stored.
public struct Receiving<phantom T: key> has drop { ... }

/// Given mutable (i.e., locked) access to the `parent` and a `Receiving`
/// object referencing an object owned by `parent` use the `Receiving` ticket
/// and return the corresponding object.
///
/// This function has custom rules that the Sui Move bytecode verifier enforces to ensure
/// that `T` is an object defined in the module where `receive` is invoked. Use
/// `public_receive` to receive an object with `store` outside of its defining module.
///
/// NB: &mut UID here allows the defining module of the parent type to
/// define custom access/permission policies around receiving objects sent
/// to objects of a type that it defines. You can see this more in the examples.
public native fun receive<T: key>(parent: &mut UID, object: Receiving<T>): T;

/// Given mutable (locked) access to the `parent` and a `Receiving` argument
/// referencing an object of type `T` owned by `parent` use the `object`
/// argument to receive and return the referenced owned object of type `T`.
/// The object `T` must have `store` to be received by this function, and
/// this can be called outside of the module that defines `T`.
public native fun public_receive<T: key + store>(parent: &mut UID, object: Receiving<T>): T;

...
```

Each `Receiving<T>` argument in a PTB corresponds to one sent object of type `T`. You use it with `transfer::receive` to access the object.

When you call the `transfer::receive` function, you must pass a mutable reference to the parent object's `UID`. You can't get a mutable reference to the `UID` of an object, though, unless the defining module of the object exposes it. Consequently, the module that defines the type of the parent object that is receiving the child object defines access control policies and other restrictions on receiving objects that are sent to it. See the [authorization example](#receive-shared-example) for a demonstration of this pattern. The fact that the passed-in `UID` actually owns the object referenced by the `Receiving` parameter is dynamically checked and enforced. This allows access to objects that have been sent to, for example, dynamic fields where the ownership chain can only be established dynamically.

Because `sui::transfer::Receiving` has only the `drop` ability, the existence of a `Receiving<T>` argument represents the ability, but not the obligation to receive the object of type `T` specified by the object reference in the PTB `Receiving` argument during that transaction. You can use some, none, or all `Receiving` arguments in a PTB without issue. Any object that corresponds to a `Receiving` argument remains untouched (in particular, its object reference remain the same) unless it is received.

## Custom receiving rules

Just like [custom transfer rules](./custom-rules.mdx), Sui lets you define custom receiving rules for `key`-only objects. You can call `transfer::receive` only on objects defined in the same module. By contrast, anyone can call `transfer::public_receive` on objects with the `store` ability.

Since both the parent and child can enforce rules, consider the following permissions:

| Child abilities | Parent can restrict | Child can restrict |
| --------------- | ------------------- | ------------------ |
| `key`           | Yes                 | Yes                |
| `key` + `store` | Yes                 | No                 |

You can combine these rules to build advanced patterns, such as [soulbound objects](#soul-bound-example).

## Using SDKs

In SDKs, `Receiving` arguments behave like other object arguments. For example, in the [Simple Account](#simple-account) example, you can receive a coin object with ID `0xc0ffee` sent to your account at `0xcafe`:

<Tabs groupId="code-language">

<TabItem label="TypeScript" value="typescript">

```ts
... // Setup TypeScript SDK as normal.
const tx = new Transaction();
tx.moveCall({
  target: `${examplePackageId}::account::accept_payment`,
  arguments: [tx.object("0xcafe"), tx.object("0xc0ffee")]
});
const result = await client.signAndExecuteTransaction({
      transaction: tx,
  });
...
```

</TabItem>

<TabItem label="Rust" value="rust">

```rust
... // Setup Rust SDK client as normal.
client
  .transaction_builder()
  .move_call(
     sending_account,
     example_package_id,
     "account",
     "accept_payment",
     vec!["0x2::sui::SUI"],
     vec![
       SuiJsonValue::from_object_id("0xcafe"),
       SuiJsonValue::from_object_id("0xc0ffee") // 0xcoffee is turned into the `Receiving<...>` argument of `accept_payment` by the SDK
     ])
  ...
```

</TabItem>

</Tabs>

Like `ObjectRef`, there is also a `ReceivingRef` constructor where you can specify object ID, version, and digest.

## Examples

The following examples demonstrate receiving previously sent objects.

### Receiving objects from shared objects {#receive-shared-example}

Generally, if you want to allow receiving sent objects from shared objects that are defined in the module, add dynamic authorization checks; otherwise, anyone could receive sent objects. In this example, a shared object (`SharedObject`) holds a counter that anyone can increment, but only the address `0xB0B` can receive objects from the shared object.

Because the `receive_object` function is generic over the object being received, it can only receive objects that are both `key` and `store`. `receive_object` must also use the `transfer::public_receive` function to receive the object and not `transfer::receive` because you can only use `receive` on objects defined in the current module.

```move
module examples::shared_object_auth;

use transfer::Receiving;

const EAccessDenied: u64 = 0;
const AuthorizedReceiverAddr: address = @0xB0B;

public struct SharedObject has key {
    id: UID,
    counter: u64,
}

public fun create(ctx: &mut TxContext) {
    let s = SharedObject {
        id: object::new(ctx),
        counter: 0,
    };
    transfer::share_object(s);
}

/// Anyone can increment the counter in the shared object.
public fun increment(obj: &mut SharedObject) {
    obj.counter = obj.counter + 1;
}

/// Objects can only be received from the `SharedObject` by the
/// `AuthorizedReceiverAddr` otherwise the transaction aborts.
public fun receive_object<T: key + store>(
    obj: &mut SharedObject,
    sent: Receiving<T>,
    ctx: &TxContext
): T {
    assert!(ctx.sender() == AuthorizedReceiverAddr, EAccessDenied);
    transfer::public_receive(&mut obj.id, sent)
}
```

### Receiving objects and adding them as dynamic fields {#simple-account}

This example defines an `Account` object that stores coin balances in dynamic fields. The account keeps the same ID regardless of ownership changes.
```move
module examples::account;

use sui::dynamic_field as df;
use sui::coin::{Self, Coin};
use transfer::Receiving;

const EBalanceDONE: u64 = 1;

/// Account object that `Coin`s can be sent to. Balances of different types
/// are held as dynamic fields indexed by the `Coin` type's `type_name`.
public struct Account has key {
    id: UID,
}

/// Dynamic field key representing a balance of a particular coin type.
public struct AccountBalance<phantom T> has copy, drop, store { }

/// This function will receive a coin sent to the `Account` object and then
/// join it to the balance for each coin type.
/// Dynamic fields are used to index the balances by their coin type.
public fun accept_payment<T>(account: &mut Account, sent: Receiving<Coin<T>>) {
    // Receive the coin that was sent to the `account` object
    // Since `Coin` is not defined in this module, and since it has the `store`
    // ability we receive the coin object using the `transfer::public_receive` function.
    let coin = transfer::public_receive(&mut account.id, sent);
    let account_balance_type = AccountBalance<T>{};
    let account_uid = &mut account.id;

    // Check if a balance of that coin type already exists.
    // If it does then merge the coin we just received into it,
    // otherwise create new balance.
    if (df::exists_(account_uid, account_balance_type)) {
        let balance: &mut Coin<T> = df::borrow_mut(account_uid, account_balance_type);
        balance.join(coin);
    } else {
        df::add(account_uid, account_balance_type, coin);
    }
}

/// Withdraw `amount` of coins of type `T` from `account`.
public fun withdraw<T>(account: &mut Account, amount: u64, ctx: &mut TxContext): Coin<T> {
    let account_balance_type = AccountBalance<T>{};
    let account_uid = &mut account.id;
    // Make sure what we are withdrawing exists
    assert!(df::exists_(account_uid, account_balance_type), EBalanceDONE);
    let balance: &mut Coin<T> = df::borrow_mut(account_uid, account_balance_type);
    balance.split(amount, ctx)
}

/// Can transfer this account to a different address
/// (e.g., to an object or address).
public fun transfer_account(account: Account, to: address, _ctx: &mut TxContext) {
    // Perform some authorization checks here and if they pass then transfer the account
    // ...
    transfer::transfer(account, to);
}
```

### Soul-bound objects {#soul-bound-example}

Soulbound objects must always be returned to their original owner. In this example, receiving a `SoulBound` object produces a `ReturnReceipt` that must be destroyed by transferring the object back in the same transaction.

```move
module examples::soul_bound;

use transfer::{Self, Receiving};

/// Tried to return the wrong object.
const EWrongObject: u64 = 0;

/// This object has `key` only  -- if this had `store` we would not be
/// able to ensure it is bound to whatever address we sent it to
public struct SoulBound has key {
    id: UID,
}

/// A non-store, non-drop, non-copy struct. When you receive a `SoulBound`
/// object, we'll also give you one of these. In order to successfully
/// execute the transaction you need to destroy this `ReturnReceipt` and
/// the only way to do that is to transfer it back to the same object you
/// received it from in the transaction using the `return_object` function.
public struct ReturnReceipt {
    /// The object ID of the object that needs to be returned.
    /// This field is required to prevent swapping of soul bound objects if
    /// multiple are present in the same transaction.
    object_id: ID,
    /// The address (object ID) it needs to be returned to.
    return_to: address,
}

/// Takes the object UID that owns the `SoulBound` object and a `SoulBound`
/// receiving ticket. It then receives the `SoulBound` object and returns a
/// `ReturnReceipt` that must be destroyed in the transaction by calling `return_object`.
public fun get_object(parent: &mut UID, soul_bound_ticket: Receiving<SoulBound>): (SoulBound, ReturnReceipt) {
    let soul_bound = transfer::receive(parent, soul_bound_ticket);
    let return_receipt = ReturnReceipt {
        return_to: parent.to_address(),
        object_id: object::id(&soul_bound),
    };
    (soul_bound, return_receipt)
}

/// Given a `SoulBound` object and a return receipt returns it to the
/// object it was received from. Verifies that the `receipt`
/// is for the given `soul_bound` object before returning it.
public fun return_object(soul_bound: SoulBound, receipt: ReturnReceipt) {
    let ReturnReceipt { return_to, object_id }  = receipt;
    assert!(object::id(&soul_bound) == object_id, EWrongObject);
    transfer::transfer(soul_bound, return_to);
}
```
