---
<<<<<<< HEAD
title: GraphQL for Sui RPC (Beta)
beta: devnet, testnet, mainnet
description: Use GraphQL to make Sui RPC calls. This feature is currently in Beta. 
keywords: [ graphql, graphql headers, x-sui-rpc-version, x-sui-rpc-show-usage, variables, fragments, pagination, graphql limits, make rpc call, sui rpc calls ]
---

Important concepts when working with GraphQL include altering behavior using HTTP headers, re-using query snippets with variables and fragments, consuming paginated queries, and understanding and working within the limits enforced by the service.

For more details on GraphQL fundamentals, see the introductory documentation from [GraphQL](https://graphql.org/learn/) and [GitHub](https://docs.github.com/en/graphql/guides/introduction-to-graphql).

<ImportContent source="data-serving-msg.mdx" mode="snippet" />

:::caution

Switch any apps that still use the GraphQL Alpha endpoints (`https://sui-mainnet.mystenlabs.com/graphql`, `https://sui-testnet.mystenlabs.com/graphql`, and `https://sui-devnet.mystenlabs.com/graphql`) to the GraphQL Beta endpoints as soon as possible to avoid disruption of service.

- GraphQL Beta Mainnet: `https://graphql.mainnet.sui.io/graphql`

- GraphQL Beta Testnet: `https://graphql.testnet.sui.io/graphql`

- GraphQL Beta Devnet: `https://graphql.devnet.sui.io/graphql`

:::

## Headers

The service accepts the following optional HTTP request headers:

- `x-sui-rpc-version`: Specifies which RPC version to use. Currently only one version is supported.

- `x-sui-rpc-show-usage`: Returns the response with extra query complexity information.

By default, each response contains the following HTTP response headers:

- `x-sui-rpc-request-id`: A unique identifier for the request. This appears in application logs for debugging.

- `x-sui-rpc-version`: The version of the service that handled the request.

```sh
$ curl -i -X POST https://graphql.testnet.sui.io/graphql\
     --header 'x-sui-rpc-show-usage: true'                 \
     --header 'Content-Type: application/json'             \
     --data '{
          "query": "query { epoch { referenceGasPrice } }"
     }'
```

<details>
<summary>Output</summary>

```sh
HTTP/2 200 
content-type: application/json
content-length: 179
x-sui-rpc-request-id: f5442058-47ab-4360-8295-61c009f38516
x-sui-rpc-version: 1.56.1-
vary: origin, access-control-request-method, access-control-request-headers
access-control-allow-origin: *
date: Tue, 09 Sep 2025 23:34:04 GMT
via: 1.1 google
alt-svc: h3=":443"; ma=2592000,h3-29=":443"; ma=2592000

{
  "data": { 
    "epoch": { 
      "referenceGasPrice": "1000" 
    } 
  },
  "extensions": {
    "usage": {
      "input": { 
        "nodes": 2, 
        "depth": 2 
      },
      "payload": { 
        "query_payload_size": 67, 
        "tx_payload_size": 0 
      },
      "output": { 
        "nodes": 2 
=======
title: Querying Sui RPC with GraphQL
description: Introductory guide to making queries of the Sui RPC using the GraphQL service.
keywords: [ rpc, sui rpc, graphql, how to use graphql, schema, graphql schema, query transactions, query blocks, query block info, query dynamic field, execute transaction ]
---

:::info

<ImportContent source="data-serving-msg.mdx" mode="snippet" />

:::

The quickest way to access the GraphQL service for Sui RPC is through the online IDE that provides a complete toolbox for fetching data and executing transactions on the network. The online IDE provides features such as auto-completion (use <kbd>Ctrl</kbd>+<kbd>Space</kbd> or just start typing), built-in documentation (Book icon, top-left), multi-tabs, and more.

The online IDE is available for Mainnet, Testnet, and Devnet. You can try the various queries on this page directly in the IDE.

:::info

Both Mainnet and Testnet services are rate-limited to keep network throughput optimized.

:::

- Mainnet: https://graphql.mainnet.sui.io/graphql
- Testnet: https://graphql.testnet.sui.io/graphql
- Devnet: https://graphql.devnet.sui.io/graphql

:::caution

Switch any apps that still use the GraphQL Alpha endpoints (`https://sui-mainnet.mystenlabs.com/graphql`, `https://sui-testnet.mystenlabs.com/graphql`, and `https://sui-devnet.mystenlabs.com/graphql`) as soon as possible. Migrate your apps to the GraphQL Beta endpoints to avoid disruption of service.

:::

For more details about some concepts used in the following examples, see the [GraphQL concepts](/concepts/data-access/graphql-rpc.mdx) page. Consult the [GraphQL reference](../../../references/sui-graphql.mdx) for full documentation on the supported schema.

## Discovering the schema

GraphQL introspection exposes the schema supported by the RPC service. The IDE's **Docs** pane (Book icon, top-left) and **Search** dialog (<kbd>Cmd</kbd> + <kbd>K</kbd> on macOS or <kbd>Ctrl</kbd> + <kbd>K</kbd> on Windows and Linux) offer a way to browse introspection output interactively.

The [official GraphQL introspection documentation](https://graphql.org/learn/introspection/) provides an overview on introspection and how to interact with it programmatically.

## Beta schema changes

Some of the schema updates for the beta version include:

### Renames and deprecations

- `TransactionBlock` is being replaced with `Transaction`
- `Owner` has been merged with `Address`
- `dryRunTransactionBlock` is being replaced with `simulateTransaction`
- `bcs` fields are qualified with the type of BCS data they hold to avoid confusion.
- `changedObject` and `inputObject` filters in `transactions` query are being replaced with `affectedObject`.
- `address.coins` and `address.stakedSuis` are being deprecated in favor of `address.objects` with the corresponding `type` filter.
- `MoveValue.data` has been deprecated because it does not add value over `MoveValue.json`, which provides a more clear representation of the data.

### Consistency

GraphQL Beta offers the ability to run a query at a fixed checkpoint (retention permitting). This allows clients to query the chain state at a particular snapshot in time over multiple arbitrary requests (GraphQL Alpha offered consistency across multiple requests as long as they were for pages of a paginated query).

### Versioning

APIs for traversing different versions of packages and objects have been added. You can now list a package or object's versions, or go from one version of a package or object to another version by number, or the latest version.

### Splitting up query APIs

Paginated query APIs were previously responsible for 3 kinds of query pattern, which are broken up into 2 separate APIs:

- A dedicated multi-get API that accepts a list of keys and returns a list of results.
- A query API that offers the original core functionality: Efficient paginated results without having to supply a checkpoint range, but for limited combinations of filters.

### Relaxed consistency cursors

Cursors in GraphQL Alpha indicated the checkpoint that pagination started at. Future pages would be fetched as if from this checkpoint. This is helpful for paginating owned objects of an address but cannot express queries that update over time (like tracking a stream of events in real time). Cursors in GraphQL Beta have relaxed this constraint â€” only cursors for pages whose results do not flow in the same direction as time (such as owned object queries) remember their checkpoint.

The old behavior is reproducible by explicitly setting the checkpoint to query from (see the [Consistency](#consistency) section).

### Preserving Entity IDs

The service retains the ability to identify entities that have been pruned when they are referred to by other entities. For example, even if an object's previous transaction has been pruned, the service is still able to return the transaction digest.

### Unpruned point lookups

Point look-ups (accessing an object by its ID and version, a transaction by its digest, a checkpoint by its sequence number, and so on) are generally unpruned if GraphQL has access to an Archival Service.

### More detailed retention API

The service provides more details about the retention of its underlying data through the `ServiceConfig.availableRange` field.

### Governance

APIs related to governance and staking are removed in favor of using view functions to access the data at its source of truth on-chain.

### Owned Coin Pagination

As there is no longer a dedicated API for fetching the coins owned by an address, whenever coins are returned by an owned object API (such as `Query.objects` with an `owner` filter or `IAddressable.objects`), they are grouped by coin type and sorted in descending balance order.

### Dry-run, gas estimation, and coin selection

Dry-run now supports the same input schema as `gRPC`'s [`SimulateTransaction`](/references/fullnode-protocol#sui-rpc-v2-Transaction) in JSON form. This means that it can also accept transactions where the inputs have not been fully resolved or serialized, perform gas estimation, and coin selection. The feature is now called `simulateTransaction`.

## Example queries

The following queries show some common tasks you can perform with GraphQL.

### Find the reference gas price for latest epoch

<Tabs groupId="graphql">
<TabItem label="Beta" value="beta">
```graphql
query {
  epoch {
    referenceGasPrice
  }
}
```
</TabItem>
<TabItem label="Alpha (deprecated)" value="alpha">
```graphql
query {
  epoch {
    referenceGasPrice
  }
}
```
</TabItem>
</Tabs>

### Find a specific historical epoch

Find the total stake rewards, the reference gas price, the number of checkpoints and the total gas fees for epoch 100. In the query, the `epochId` argument is optional and defaults to the latest epoch.

<Tabs groupId="graphql">
<TabItem label="Beta" value="beta">
```graphql
query {
  epoch(epochId: 100)
  {
    epochId
    totalStakeRewards
    referenceGasPrice
    totalCheckpoints
    totalGasFees
    totalStakeSubsidies
    storageFund {
      totalObjectStorageRebates
      nonRefundableBalance
    }
  }
}
```
</TabItem>
<TabItem label="Alpha (deprecated)" value="alpha">
```graphql
query {
  epoch(id: 100)
  {
    epochId
    totalStakeRewards
    referenceGasPrice
    totalCheckpoints
    totalGasFees
    totalStakeSubsidies
    storageFund {
      totalObjectStorageRebates
      nonRefundableBalance
    }
  }
}
```
</TabItem>
</Tabs>

### Find a transaction by its digest

Get a transaction by its digest and show information such as the gas sponsor address, the gas price, the gas budget, and effects from executing that transaction.

<Tabs groupId="graphql">
<TabItem label="Beta" value="beta">
```graphql
query {
  transaction(digest: "FdK...qK2") {
    gasInput {
      gasSponsor {
        address
      }
      gasPrice
      gasBudget
    }
    effects {
      status
      timestamp
      checkpoint {
        sequenceNumber
      }
      epoch {
        epochId
        referenceGasPrice
>>>>>>> afb3e1eb2f (init)
      }
    }
  }
}
```
<<<<<<< HEAD

</details>

## Variables

Variables offer a way to introduce dynamic inputs to a re-usable or static query. Declare variables in the parameters to a `query` or `mutation`, using the `$` symbol and its type (in this example `Int`), which must be a `scalar`, `enum`, or `input` type. In the query body, refer to it by its name prefixed with the `$` symbol.

If you declare a variable but don't use it, or define it in the query, the query fails to execute. To learn more, read the GraphQL documentation on [variables](https://graphql.org/learn/queries/#variables).

In the following example, a variable supplies the ID of the epoch being queried:

```graphql
query ($epochID: Int) {
  epoch(id: $epochID) {
    referenceGasPrice
  }
}
```

**Variables**:
```json
{
   "epochID": 100
}
```

### Within the GraphQL IDE

When using the [GraphQL online integrated development environment (IDE)](https://graphql.mainnet.sui.io/graphql), supply variables as a JSON object to the query in the **Variables** pane at the bottom of the main editing window. You receive a warning if you supply a variable but don't declare it.

### Within requests

When making a request to the GraphQL service using a tool such as `curl`, pass the query and variables as two fields of a single JSON object:

```sh
$ curl -X POST https://sui-testnet.mystenlabs.com/graphql \
    --header 'Content-Type: application/json' \
    --data '{
      "query": "query ($epochID: Int) { epoch(id: $epochID) { referenceGasPrice } }",
      "variables": { "epochID": 100 }
  }'
```

## Fragments

Fragments are reusable units that you can include in queries as needed. To learn more, consult the official [GraphQL documentation](https://graphql.org/learn/queries/#fragments). The following example uses fragments to factor out a reusable snippet representing a Move value:

=======
</TabItem>
<TabItem label="Alpha (deprecated)" value="alpha">
```graphql
query {
  transactionBlock(digest: "FdK...qK2") {
    gasInput {
      gasSponsor {
        address
      }
      gasPrice
      gasBudget
    }
    effects {
      status
      timestamp
      checkpoint {
        sequenceNumber
      }
      epoch {
        epochId
        referenceGasPrice
      }
    }
  }
}
```
</TabItem>
</Tabs>

### Find the last 10 transactions that are not a system transaction

<Tabs groupId="graphql">
<TabItem label="Beta" value="beta">
:::caution

This example demonstrates future functionality.

:::

```graphql
query {
  transactions(last: 10, filter: {kind: PROGRAMMABLE_TX}) {
    nodes {
      digest
      kind {
        __typename
      }
    }
  }
}
```
</TabItem>
<TabItem label="Alpha (deprecated)" value="alpha">
```graphql
query {
  transactionBlocks(last: 10, filter: {kind: PROGRAMMABLE_TX}) {
    nodes {
      digest
      kind {
        __typename
      }
    }
  }
}
```
</TabItem>
</Tabs>



### Find all transactions that touched a given object

Find all the transactions that touched (modified/transferred/deleted) a given object. Useful when you want to trace the flow of a `Coin`, `StakeSui`, `NFT`, or similar object.

:::info

This example uses GraphQL [variables](/concepts/data-access/graphql-rpc.mdx#variables) and [pagination](/concepts/data-access/graphql-rpc.mdx#pagination).

:::

<Tabs groupId="graphql">
<TabItem label="Beta" value="beta">
```graphql
query ($objectID: SuiAddress!) {
  transactions(filter: {affectedObject: $objectID}) {
    nodes {
      sender {
        address
      }
      digest
      effects {
        objectChanges {
          nodes {
            address
          }
        }
      }
    }
  }
}
```
</TabItem>
<TabItem label="Alpha (deprecated)" value="alpha">
:::caution

This example demonstrates future functionality.

:::
```graphql
query ($objectID: SuiAddress!) {
  transactionBlocks(filter: {changedObject: $objectID}) {
    nodes {
      sender {
        address
      }
      digest
      effects {
        objectChanges {
          nodes {
            address
          }
        }
      }
    }
  }
}
```
</TabItem>
</Tabs>

#### Variables

When using the online IDE, copy the following JSON to the **Variables** window, below the main editor.

```json
{
  "objectID": "0x11c6ae8432156527fc2e12e05ac7db79f2e972510a823a4ef2e670f27ad7b52f"
}
```

### Filter transactions by a function

Find the last ten transactions that called the `public_transfer` function as a Move call transaction command.

:::info

This example makes use of the `last` filter. In this case, returns only the last `10` transactions known to the service.

:::

<Tabs groupId="graphql">
<TabItem label="Beta" value="beta">
:::caution

This example demonstrates future functionality.

:::
```graphql
{
  transactions(
    last: 10,
      filter: {
        function: "0x2::transfer::public_transfer"
      }
  ) {
    nodes { digest }
  }
}
```
</TabItem>
<TabItem label="Alpha (deprecated)" value="alpha">
```graphql
{
  transactionBlocks(
    last: 10,
      filter: {
        function: "0x2::transfer::public_transfer"
      }
  ) {
    nodes { digest }
  }
}
```
</TabItem>
</Tabs>

### Find transaction balance changes

Find the balance changes of all the transactions where a given address called a staking-related function. Useful when you want to get your staking or unstaking history.

<Tabs groupId="graphql">
<TabItem label="Beta" value="beta">
:::caution

This example demonstrates future functionality.

:::
```graphql
query ($address: SuiAddress!) {
  transactions(filter: {
    function: "0x3::sui_system::request_add_stake"
    sentAddress: $address
  }) {
    nodes {
      digest
      effects {
        balanceChanges {
          nodes {
            owner {
              address
            }
            amount
          }
        }
      }
    }
  }
}
```
</TabItem>
<TabItem label="Alpha (deprecated)" value="alpha">
```graphql
query ($address: SuiAddress!) {
  transactionBlocks(filter: {
    function: "0x3::sui_system::request_add_stake"
    sentAddress: $address
  }) {
    nodes {
      digest
      effects {
        balanceChanges {
          nodes {
            owner {
              address
            }
            amount
          }
        }
      }
    }
  }
}
```
</TabItem>
</Tabs>

#### Variables

When using the online IDE, copy the following JSON to the **Variables** window, below the main editor.

```json
{
  "address": "0xa9ad44383140a07cc9ea62d185c12c4d9ef9c6a8fd2f47e16316229815862d23"
}
```

### Fetch a dynamic field on an object

:::info

This example uses aliases and [fragments](/concepts/data-access/graphql-rpc.mdx#fragments).

:::

<Tabs groupId="graphql">
<TabItem label="Beta" value="beta">
>>>>>>> afb3e1eb2f (init)
```graphql
query DynamicField {
  object(
    address: "0xb57fba584a700a5bcb40991e1b2e6bf68b0f3896d767a0da92e69de73de226ac"
  ) {
    dynamicField(
      name: {
        type: "0x2::kiosk::Lock",
        bcs: "NLArx1UJguOUYmXgNG8Pv8KbKXLjWtCi6i0Yeq1Vhfw=",
      }
    ) {
      ...DynamicFieldSelect
    }
  }
}

fragment DynamicFieldSelect on DynamicField {
  name {
    ...MoveValueFields
  }
  value {
    ...DynamicFieldValueSelection
  }
}

fragment DynamicFieldValueSelection on DynamicFieldValue {
  __typename
  ... on MoveValue {
    ...MoveValueFields
  }
  ... on MoveObject {
    hasPublicTransfer
    contents {
      ...MoveValueFields
    }
  }
}

fragment MoveValueFields on MoveValue {
  type {
    repr
  }
  json
  bcs
}
```
<<<<<<< HEAD

## Pagination

GraphQL supports queries that fetch multiple kinds of potentially nested data. For example, the following query retrieves the first 10 transactions in epoch `97` along with the digest, sender's address, gas object returned after paying for the transaction, gas price, and gas budget:

```graphql
query {
  epoch(epochId: 97) {
    transactions(first: 10) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        digest
        sender {
          address
        }
        effects {
          gasEffects {
            gasObject {
              address
            }
          }
        }
        gasInput {
          gasPrice
          gasBudget
        }
      }
    }
  }
}
```

If there are too many transactions to return in a single response, the service applies a [limit](#limits) on the maximum page size for variable size responses (like the `transactionBlock` query) and you must fetch further results through [pagination](https://graphql.org/learn/pagination/).

### Connections

Fields that return a paginated response accept the following optional parameters:

- `first`: Limit on page size that is met by dropping excess results from the end.

- `after`: Cursor that bounds the results from below, exclusively.

- `last`: Limit on page size that is met by dropping excess results from the start.

- `before`: Cursor that bounds the results from above, exclusively.

They also return a type that conforms to the [GraphQL Cursor Connections Specification](https://relay.dev/graphql/connections.htm), meaning its name ends in `Connection`, and it contains at minimum the following fields:

- `pageInfo` of type <UnsafeLink href="/references/sui-api/sui-graphql/beta/reference/types/objects/page-info">PageInfo</UnsafeLink>, which indicates whether there are more pages before or after the page returned.

- `nodes`: The content of the paginated response as a list of the type being paginated (`TransactionBlock` in the previous example).

- `edges`: Similar to `nodes` but associating each node with its [cursor](#cursors).

### Cursors

Cursors are opaque identifiers for paginated results. The only valid source for a cursor parameter (like `after` and `before`) is a cursor field from a previous paginated response (like `PageInfo.startCursor`, `PageInfo.endCursor`, or `Edge.cursor`). The underlying format of the cursor is an implementation detail, and is not guaranteed to remain fixed across versions of the GraphQL service, so do not rely on it. Generating cursors out of thin air is not expected or supported.

Cursors are used to bound results from below (with `after`) and above (with `before`). In both cases, the bound is exclusive, meaning it does not include the result that the cursor points to in the bounded region.

#### Consistency

Cursors for queries that paginate live objects also guarantee **consistent** pagination. If a paginated query reads the state of the network at a specific checkpoint (checkpoint `X`), the query returns cursors that can be used by subsequent requests. When a future call fetches the next page of results, it uses the previous query's cursors and continues reading from the network as it existed at checkpoint `X`, even if newer checkpoints are available. Currently, the available range offers roughly 1 hour to finish pagination.

This property requires that cursors that are used together (such as when supplying an `after` and `before` bound) are fixed on the same checkpoint, otherwise the query produces an error.

### Page limits

After results are bounded using cursors, a page size limit is applied using the `first` and `last` parameters. The service requires these parameters to be less than or equal to the max page size [limit](#limits), and if you provide neither, it selects a default. In addition to setting a limit, `first` and `last` control where excess elements are discarded from. For example, if there are 10 potential results (R0, R1, through R9) after cursor bounds have been applied, then:

- A limit of `first: 3` would select `R0`, `R1`, `R2`.

- A limit of `last: 3` would select `R7`, `R8`, `R9`.

:::info

It is an error to apply both a `first` and a `last` limit.

:::

### Examples

To see these principles put into practice, consult the examples for [paginating forwards](/guides/developer/advanced/graphql-rpc.mdx#page-forward) and [paginating backwards](/guides/developer/advanced/graphql-rpc.mdx#page-back).

## Limits

The GraphQL service for Sui RPC is rate-limited on all available instances to keep network throughput optimized and to protect against excessive or abusive calls to the service.

### Rate limits

Queries are rate-limited at the number of attempts per minute to ensure high availability of the service to all users.

### Query limits

In addition to rate limits, queries are also validated against a number of rules on their complexity, such as the number of nodes, the depth of the query, or their payload size. Query the `serviceConfig` field to retrieve these limits. An example of how to query for some of the available limits follows:

```graphql
{
  serviceConfig {
    maxQueryDepth
    maxQueryNodes
    maxOutputNodes
    defaultPageSize
    maxPageSize
    queryTimeoutMs
    maxQueryPayloadSize
    maxTypeArgumentDepth
    maxTypeArgumentWidth
    maxTypeNodes
    maxMoveValueDepth
=======
</TabItem>
<TabItem label="Alpha (deprecated)" value="alpha">
```graphql
query DynamicField {
  object(
    address: "0xb57fba584a700a5bcb40991e1b2e6bf68b0f3896d767a0da92e69de73de226ac"
  ) {
    dynamicField(
      name: {
        type: "0x2::kiosk::Lock",
        bcs: "NLArx1UJguOUYmXgNG8Pv8KbKXLjWtCi6i0Yeq1Vhfw=",
      }
    ) {
      ...DynamicFieldSelect
    }
  }
}

fragment DynamicFieldSelect on DynamicField {
  name {
    ...MoveValueFields
  }
  value {
    ...DynamicFieldValueSelection
  }
}

fragment DynamicFieldValueSelection on DynamicFieldValue {
  __typename
  ... on MoveValue {
    ...MoveValueFields
  }
  ... on MoveObject {
    hasPublicTransfer
    contents {
      ...MoveValueFields
    }
  }
}

fragment MoveValueFields on MoveValue {
  type {
    repr
  }
  data
  bcs
}
```
</TabItem>
</Tabs>



### Fetch all dynamic fields on an object

Paginate over the dynamic fields of an object. This works even when the object in question is [wrapped](/guides/developer/objects/object-ownership/wrapped.mdx) by using the <a href="/references/sui-api/sui-graphql/alpha/reference/operations/queries/owner.mdx" data-noBrokenLinkCheck='true'>owner query</a>. It can be used for iterating over the elements of on-chain data structures, like tables and bags. See [The Move Book](https://move-book.com/programmability/dynamic-collections.html) to learn more about dynamic collections available in Move.

:::info

This example uses [fragments](/concepts/data-access/graphql-rpc.mdx#fragments) and [variables](/concepts/data-access/graphql-rpc.mdx#variables).

:::

<Tabs groupId="graphql">
<TabItem label="Beta" value="beta">
```graphql
query ($id: SuiAddress!) {
  address(address: $id) {
    dynamicFields {
      nodes {
        name { ...Value }
        value {
          __typename
          ... on MoveValue {
            ...Value
          }
          ... on MoveObject {
            contents {
              ...Value
            }
          }
        }
      }
    }
  }
}

fragment Value on MoveValue {
  type {
    repr
  }
  json
}
```
</TabItem>
<TabItem label="Alpha (deprecated)" value="alpha">
```graphql
query ($id: SuiAddress!) {
  owner(address: $id) {
    dynamicFields {
      nodes {
        name { ...Value }
        value {
          __typename
          ... on MoveValue {
            ...Value
          }
          ... on MoveObject {
            contents {
              ...Value
            }
          }
        }
      }
    }
  }
}

fragment Value on MoveValue {
  type {
    repr
  }
  json
}
```
</TabItem>
</Tabs>

### Paginate checkpoints forward five at a time {#page-forward}

Set up a paginated query starting at the genesis checkpoint, reading five checkpoints at a time in increasing order of sequence number. The value of `pageInfo.hasNextPage` determines whether there is another page to read. The value of `pageInfo.endCursor` is used as the cursor to read `$after`.

:::info

This example uses GraphQL [variables](/concepts/data-access/graphql-rpc.mdx#variables) and [pagination](/concepts/data-access/graphql-rpc.mdx#pagination).

:::

<Tabs groupId="graphql">
<TabItem label="Beta" value="beta">
```graphql
query ($after: String) {
  checkpoints(first: 5, after: $after) {
    pageInfo {
      hasNextPage
      endCursor
    }
    nodes {
      digest
      timestamp
    }
  }
}
```
</TabItem>
<TabItem label="Alpha (deprecated)" value="alpha">
```graphql
query ($after: String) {
  checkpoints(first: 5, after: $after) {
    pageInfo {
      hasNextPage
      endCursor
    }
    nodes {
      digest
      timestamp
    }
  }
}
```
</TabItem>
</Tabs>

### Paginate checkpoints backwards five at a time {#page-back}

Set up a paginated query starting at the latest indexed checkpoint, reading five checkpoints at a time in decreasing order of sequence number. The value of `pageInfo.hasPreviousPage` determines whether there is another page to read. The value of `pageInfo.startCursor` is used as the cursor to read `$before`.

:::info

This example uses GraphQL [variables](/concepts/data-access/graphql-rpc.mdx#variables) and [pagination](/concepts/data-access/graphql-rpc.mdx#pagination).

:::

<Tabs groupId="graphql">
<TabItem label="Beta" value="beta">
```graphql
query ($before: String) {
  checkpoints(last: 5, before: $before) {
    pageInfo {
      hasPreviousPage
      startCursor
    }
    nodes {
      digest
      timestamp
    }
  }
}
```
</TabItem>
<TabItem label="Alpha (deprecated)" value="alpha">
```graphql
query ($before: String) {
  checkpoints(last: 5, before: $before) {
    pageInfo {
      hasPreviousPage
      startCursor
    }
    nodes {
      digest
      timestamp
    }
  }
}
```
</TabItem>
</Tabs>

### Execute a transaction

Transaction execution takes 2 arguments, `transactionDataBcs` and `signatures`. `transactionDataBcs` is the serialized unsigned transaction data, which the [Sui Client CLI](/references/cli/client.mdx) `client call` command can generate. Pass the `--serialize-unsigned-transaction` flag to the command to call a Move function. The [Sui Keytool CLI](/references/cli/keytool.mdx) command `sui keytool sign` can generate the `signatures`.

<Tabs groupId="graphql">
<TabItem label="Beta" value="beta">
```graphql
mutation ($tx: String!, $sigs: [String!]!) {
  executeTransaction(transactionDataBcs: $tx, signatures: $sigs) {
    errors
    effects {
      status
      epoch {
        startTimestamp
      }
      gasEffects {
        gasSummary {
          computationCost
        }
      }
    }
  }
}
```
</TabItem>
<TabItem label="Alpha (deprecated)" value="alpha">
```graphql
mutation ($tx: String!, $sigs: [String!]!) {
  executeTransactionBlock(txBytes: $tx, signatures: $sigs) {
    errors
    effects {
      status
      epoch {
        startTimestamp
      }
      gasEffects {
        gasSummary {
          computationCost
        }
      }
    }
  }
}
```
</TabItem>
</Tabs>

#### Variables

When using the online IDE, copy the following JSON to the **Variables** window, below the main editor.

```json
{
  "tx": "AAACACAZXApmrHgzTs3FGDyXWka+wmMCy2IwOdKLmTWHb5PnFQEASlCnLAw4qfzLF3unH9or5/L7YpOlReaSEWfoEwhTqpavSxAAAAAAACCUFUCOn8ljIxcG9O+CA1bzqjunqr4DLDSzSoNCkUvu2AEBAQEBAAEAALNQHmLi4jgC5MuwwmiMvZEeV5kuyh+waCS60voE7fpzAa3v/tOFuqDvQ+bjBpKTfjyL+6yIg+5eC3dKReVwghH/rksQAAAAAAAgxtZtKhXTr1zeFAo1JzEqVKn9J1H74ddbCJNVZGo2I1izUB5i4uI4AuTLsMJojL2RHleZLsofsGgkutL6BO36c+gDAAAAAAAAQEIPAAAAAAAA",
  "sigs": [
    "AB4ZihXxUMSs9Ju5Cstuuf/hvbTvvycuRk2TMuagLYNJgQuAeXmKyJF9DAXUtL8spIsHrDQgemn4NmojcNl8HQ3JFqhnaTC8gMX4fy/rGgqgL6CDcbikawUUjC4zlkflwg=="
  ]
}
```

## Migrating to GraphQL from JSON-RPC {#migrate}

The examples in the following sections demonstrate the typical API calls. The calls are tabbed to show both the JSON-RPC call and the equivalent GraphQL structure. For a comprehensive list of all available GraphQL features, consult the [reference](/references/sui-graphql).

### Example 1: Get total transactions

Get the total number of transactions in the network.

<Tabs groupId="migrating-json-rpc">

<TabItem value="json-rpc1" label="JSON-RPC">

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "sui_getTotalTransactionBlocks",
  "params": []
}
```

</TabItem>
<TabItem value="graphql1" label="GraphQL">

```graphql
query {
  checkpoint {
    networkTotalTransactions
>>>>>>> afb3e1eb2f (init)
  }
}
```

<<<<<<< HEAD
## Retention

Different queries are subject to their own retention policies. For example, live object set queries work only for recent checkpoints (measured in minutes or hours), while transaction pagination might be available only back to certain checkpoints (measured in weeks or months), depending on the filters applied. Data outside these ranges is pruned. You can query the upper and lower bounds of that range for your query as follows:

```graphql
{
  serviceConfig {
    retention(type: "Query", field: "transactions", filter: "affectedAddress") {
      first { sequenceNumber }
      last { sequenceNumber }
=======
</TabItem>
</Tabs>

### Example 2: Get a specific transaction

Get the transaction by its digest.

<Tabs groupId="migrating-json-rpc">

<TabItem value="json-rpc2" label="JSON-RPC">

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "sui_getTransactionBlock",
  "params": [
    "Hay2tj3GcDYcE3AMHrej5WDsHGPVAYsegcubixLUvXUF",
    {
      "showInput": true,
      "showRawInput": false,
      "showEffects": true,
      "showEvents": true,
      "showObjectChanges": false,
      "showBalanceChanges": false
    }
  ]
}
```

</TabItem>
<TabItem value="graphql2" label="GraphQL">

```graphql
query {
  transaction(digest: "Hay2tj3GcDYcE3AMHrej5WDsHGPVAYsegcubixLUvXUF") {
    gasInput {
      gasSponsor {
        address
      }
      gasPrice
      gasBudget
    }
    effects {
      status
      timestamp
      checkpoint {
        sequenceNumber
      }
      epoch {
        epochId
        referenceGasPrice
      }
    }
  }
}
```
</TabItem>
</Tabs>

### Example 3: Get coin objects owned by an address

Return all `Coin<0x2::sui::SUI>` objects that an address owns.

<Tabs groupId="migrating-json-rpc">

<TabItem value="json-rpc3" label="JSON-RPC">

```json
query {
  "jsonrpc": "2.0",
  "id": 1,
  "method": "suix_getCoins",
  "params": [
    "0x5094652429957619e6efa79a404a6714d1126e63f551f4b6c7fb76440f8118c9", //owner
    "0x2::sui::SUI",                                                      //coin type
    "0xe5c651321915b06c81838c2e370109b554a448a78d3a56220f798398dde66eab", //cursor
    3 //limit
  ]
}
```

</TabItem>
<TabItem value="graphql3" label="GraphQL">

```graphql
query {
  address(address: "0x5094652429957619e6efa79a404a6714d1126e63f551f4b6c7fb76440f8118c9") {
    objects(
      first: 3,
      after: "vBIzCwAAAADMAQBQlGUkKZV2Gebvp5pASmcU0RJuY/VR9LbH+3ZED4EYyQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAARjb2luAAAAAAAAAARDb2luAAAAAAAAAAEAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAA3N1aQAAAAAAAAADU1VJAAAAAAAAAAAB/////XBZUf9feyhb9cW+AOBraL10O9t0D9JAr+tIq2wXDJdl5/zP5w==",
      filter: { type: "0x2::coin::Coin<0x2::sui::SUI>" }
    ) {
      nodes {
        address
      }
>>>>>>> afb3e1eb2f (init)
    }
  }
}
```

<<<<<<< HEAD
The results are the first and last checkpoint for which pagination continues to work and produce a consistent result.

## Related links

<RelatedLink to="/guides/developer/advanced/graphql-rpc.mdx" />
<RelatedLink to="/references/sui-graphql.mdx" />
<RelatedLink to="/concepts/data-access/graphql-indexer" />
=======
:::info

The cursor is now passed in the `after` (or `before`) fields on the connection, and the limit in the `first` or `last` fields.

:::

</TabItem>
</Tabs>

## New features

The previous examples show GraphQL calls that perform the same function as their JSON-RPC equivalent. There is functionality available to GraphQL that can't be replicated with JSON-RPC, such as: 

- Time travel queries with checkpoint `{ query { ... } }`.
- Nested dynamic field look-ups (and paginating dynamic fields with their contents in 1 request).
- Fetching live objects by owner kind and type (such as all shared objects of a certain type).
- Fetching deserialized input and output object contents from a transaction that has just executed.

The following examples demonstrate some of the functions not available with JSON-RPC.

### Example 4: Getting objects by type

Fetch the latest versions of objects of type `0x2::package::Publisher` that are currently live on-chain.

```graphql
query {
  objects(filter: { type: "0x2::package::Publisher" }) {
    nodes {
      address
      digest
      asMoveObject {
        contents { json }
      }
    }
  }
}
```

### Example 5: Paging through package versions

Find all versions of the Sui framework and list their modules:

```graphql
query {
  packageVersions(address: "0x2") {
    nodes {
      version
      modules {
        nodes {
          name
        }
      }
    }
  } 
}
```

## Related links

<RelatedLink to="/concepts/data-access/graphql-rpc.mdx" />
<RelatedLink to="/references/sui-graphql.mdx" />
<RelatedLink to="/concepts/data-access/graphql-indexer" />
<RelatedLink href="https://graphql.testnet.sui.io/graphql" label="Sui Testnet GraphiQL" desc="Sui GraphiQL IDE for Testnet." />
<RelatedLink href="https://graphql.mainnet.sui.io/graphql" label="Sui Mainnet GraphiQL" desc="Sui GraphiQL IDE for Mainnet." />
>>>>>>> afb3e1eb2f (init)
