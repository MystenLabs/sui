{/* Copyright (c) Mysten Labs, Inc. */}
{/* SPDX-License-Identifier: Apache-2.0 */}

---
title: Address Balances Migration Guide
description: Migrating from Coin objects to address balances on Sui.
---

Address balances introduce a canonical balance system for fungible assets tied to Sui addresses. This replaces the UTXO-style `Coin<T>` model with direct address-owned balances, simplifying transaction construction and eliminating coin selection complexity.

## Overview

Previously, balances on Sui were computed by summing the values of all `Coin<T>` objects owned by an address. With address balances, each address may additionally have one address-owned balance for each currency type `T`. The total balance is the sum of all `Coin<T>` objects plus the address balance value for that coin type.

`Coin<T>` and address balances coexist. Existing coins remain functional and can still be transferred with `transfer::public_transfer`. However, address balances provide significant operational advantages:
- No coin selection logic required
- Automatic deposit merging into a single canonical balance
- Stateless transaction construction without querying object states
- Direct gas payment from address SUI balances

## Funding Transactions from Address Balances

### Withdrawing Funds

To use address balance funds in a programmable transaction, add a `FundsWithdrawalArg` to declare the withdrawal:

```rust
// Rust
use sui_types::transaction::{FundsWithdrawalArg, WithdrawalTypeArg, Reservation, WithdrawFrom};

let withdrawal_arg = FundsWithdrawalArg {
    reservation: Reservation::MaxAmountU64(amount),
    type_arg: WithdrawalTypeArg::Balance(coin_type),
    withdraw_from: WithdrawFrom::Sender,
};
```

The helper `FundsWithdrawalArg::balance_from_sender(amount, balance_type)` provides a convenient constructor.

In your PTB, pass the withdrawal input to either:
- `0x2::balance::redeem_funds<T>()` to obtain a `Balance<T>`
- `0x2::coin::redeem_funds<T>()` to obtain a `Coin<T>`

```rust
// Rust example: withdraw and transfer
let mut builder = ProgrammableTransactionBuilder::new();

let withdraw_arg = FundsWithdrawalArg::balance_from_sender(
    withdraw_amount,
    sui_types::gas_coin::GAS::type_tag(),
);
let withdraw_input = builder.funds_withdrawal(withdraw_arg).unwrap();

// Redeem to coin
let coin = builder.programmable_move_call(
    SUI_FRAMEWORK_PACKAGE_ID,
    Identifier::new("coin").unwrap(),
    Identifier::new("redeem_funds").unwrap(),
    vec!["0x2::sui::SUI".parse().unwrap()],
    vec![withdraw_input],
);

builder.transfer_arg(recipient, coin);
```

You may have multiple `FundsWithdrawalArg` inputs in a PTB, even for the same coin type.

### Splitting and Joining Withdrawals

Withdrawals can be split and merged within a PTB:

```move
// Split a sub-withdrawal from an existing withdrawal
public fun withdrawal_split<T: store>(withdrawal: &mut Withdrawal<T>, sub_limit: u256): Withdrawal<T>

// Join two withdrawals together (must have same owner)
public fun withdrawal_join<T: store>(withdrawal: &mut Withdrawal<T>, other: Withdrawal<T>)
```

### TypeScript SDK

The TypeScript SDK's `CoinWithBalance` intent automatically selects address balance funds or coins as needed:

```typescript
import { Transaction, Inputs } from '@mysten/sui/transactions';

const tx = new Transaction();

// CoinWithBalance handles address balance vs coin selection automatically
tx.add(coinWithBalance({ type: '0x2::sui::SUI', balance: 1000n }));
```

For manual PTB construction with address balance withdrawals:

```typescript
const tx = new Transaction();

const withdrawal = tx.addInput(
    'withdrawal',
    Inputs.FundsWithdrawal({
        reservation: {
            $kind: 'MaxAmountU64',
            MaxAmountU64: String(amount),
        },
        typeArg: {
            $kind: 'Balance',
            Balance: coinType,
        },
        withdrawFrom: {
            $kind: 'Sender',
            Sender: true,
        },
    }),
);

// Redeem the withdrawal to a coin
const coin = tx.moveCall({
    target: '0x2::coin::redeem_funds',
    typeArguments: [coinType],
    arguments: [withdrawal],
});
```

## Sending Funds to Address Balances

To deposit funds into a recipient's address balance instead of transferring a coin object:

### Move

```move
// Send a Balance<T> to an address balance
public fun send_funds<T>(balance: Balance<T>, recipient: address)

// Send a Coin<T> to an address balance (converts to balance internally)
public fun send_funds<T>(coin: Coin<T>, recipient: address)
```

### PTB Construction

Replace `transfer::public_transfer(coin, recipient)` with:

```rust
// Rust
builder.programmable_move_call(
    SUI_FRAMEWORK_PACKAGE_ID,
    Identifier::new("coin").unwrap(),
    Identifier::new("send_funds").unwrap(),
    vec![coin_type],
    vec![coin_arg, recipient_arg],
);
```

### CLI

```bash
# Send from gas coin to address balance
sui client ptb \
    --split-coins gas '[5000000]' \
    --assign coin \
    --move-call 0x2::coin::send_funds '<0x2::sui::SUI>' coin @<recipient_address>

# Send from another coin
sui client ptb \
    --split-coins @<coin_id> '[5000000]' \
    --assign coin \
    --move-call 0x2::coin::send_funds '<coin_type>' coin @<recipient_address>
```

## Paying Gas from Address Balances

To pay gas from your address balance instead of a gas coin:

1. Leave `gas_data.payment` empty (no gas coins)
2. Use `TransactionExpiration::ValidDuring` with epoch constraints
3. Include a chain identifier and nonce for replay protection

```rust
TransactionData::V1(TransactionDataV1 {
    kind: tx_kind,
    sender,
    gas_data: GasData {
        payment: vec![],  // Empty - gas paid from address balance
        owner: sender,    // Gas owner (sender or sponsor)
        price: rgp,
        budget: 10_000_000,
    },
    expiration: TransactionExpiration::ValidDuring {
        min_epoch: Some(current_epoch),
        max_epoch: Some(current_epoch),  // At most min_epoch + 1
        min_timestamp: None,
        max_timestamp: None,
        chain: chain_identifier,
        nonce: unique_nonce,
    },
})
```

Requirements for address balance gas payments:
- `gas_data.payment` must be empty
- `expiration` must be `ValidDuring` with both `min_epoch` and `max_epoch` specified
- `max_epoch` must be at most `min_epoch + 1` (single epoch or 1-epoch range)
- Timestamp-based expiration is not currently supported
- The transaction kind must be `ProgrammableTransaction`

### Sponsored Transactions

For sponsored transactions with address balance gas:

```rust
TransactionData::V1(TransactionDataV1 {
    kind: tx_kind,
    sender,
    gas_data: GasData {
        payment: vec![],
        owner: sponsor,  // Sponsor's address balance pays gas
        price: rgp,
        budget: budget,
    },
    expiration: TransactionExpiration::ValidDuring {
        min_epoch: Some(epoch),
        max_epoch: Some(epoch),
        min_timestamp: None,
        max_timestamp: None,
        chain: chain_id,
        nonce: nonce,
    },
})
```

Both sender and sponsor must sign. Storage rebates are credited to the sponsor's address balance.

## Querying Address Balances via RPC

### JSON-RPC

Use the existing balance methods. A new `fundsInAddressBalance` field indicates address balance holdings:

```bash
# Get single balance
curl -s https://fullnode.testnet.sui.io \
    -H 'Content-Type: application/json' \
    -d '{
        "jsonrpc":"2.0",
        "id":1,
        "method":"suix_getBalance",
        "params":["<address>", "0x2::sui::SUI"]
    }'
```

Response:
```json
{
    "coinType": "0x2::sui::SUI",
    "coinObjectCount": 2,
    "totalBalance": "99998990120",
    "lockedBalance": {},
    "fundsInAddressBalance": "5000000"
}
```

The `totalBalance` includes both coin objects and address balance funds.

```bash
# Get all balances
curl -s https://fullnode.testnet.sui.io \
    -H 'Content-Type: application/json' \
    -d '{
        "jsonrpc":"2.0",
        "id":1,
        "method":"suix_getAllBalances",
        "params":["<address>"]
    }'
```

### gRPC

Use `GetBalance` and `ListBalances` from `StateService`:

```bash
# Get balance for specific coin type
buf curl --protocol grpc https://fullnode.testnet.sui.io/sui.rpc.v2.StateService/GetBalance \
    -d '{
        "owner": "<address>",
        "coin_type": "0x2::sui::SUI"
    }'
```

Response:
```json
{
    "balance": {
        "coinType": "0x2::sui::SUI",
        "balance": "99998990120",
        "addressBalance": "5000000",
        "coinBalance": "99993990120"
    }
}
```

Fields:
- `coinBalance`: Total held in coin objects
- `addressBalance`: Amount held in address balance
- `balance`: Sum of the two

```bash
# List all balances
buf curl --protocol grpc https://fullnode.testnet.sui.io/sui.rpc.v2.StateService/ListBalances \
    -d '{"owner": "<address>"}'
```

### GraphQL

```graphql
# Single balance
{
    address(address: "<address>") {
        balance(coinType: "0x2::sui::SUI") {
            coinType { repr }
            addressBalance
            coinBalance
            totalBalance
        }
    }
}

# All balances
{
    address(address: "<address>") {
        balances {
            nodes {
                coinType { repr }
                addressBalance
                coinBalance
                totalBalance
            }
        }
    }
}
```

## Computing Balance Changes from Checkpoint Data

Balance changes from a transaction combine coin object changes and accumulator events.

### Algorithm

1. **Subtract input coins**: For each input coin object, subtract its value from `(owner, coin_type)`
2. **Add output coins**: For each mutated/created coin object, add its value to `(owner, coin_type)`
3. **Process accumulator events**: For each accumulator event with a `Balance<T>` type:
   - `Split` operation: Subtract the amount (funds withdrawn)
   - `Merge` operation: Add the amount (funds deposited)

```rust
use sui_types::balance_change::{derive_balance_changes, BalanceChange};

let balance_changes: Vec<BalanceChange> = derive_balance_changes(
    &effects,
    &input_objects,
    &output_objects,
);
```

### Accumulator Events

Accumulator events are embedded in `TransactionEffects`. Access them via:

```rust
use sui_types::effects::TransactionEffectsAPI;

let events = effects.accumulator_events();
for event in events {
    let address = event.write.address.address;
    let balance_type = &event.write.address.ty;

    // Only Balance<T> types represent balance changes
    if let Some(coin_type) = Balance::maybe_get_balance_type_param(balance_type) {
        let amount = match &event.write.value {
            AccumulatorValue::Integer(v) => *v as i128,
            _ => continue,
        };

        let signed_amount = match event.write.operation {
            AccumulatorOperation::Split => -amount,  // Withdrawal
            AccumulatorOperation::Merge => amount,   // Deposit
        };

        // (address, coin_type, signed_amount) represents the balance change
    }
}
```

### Key Types

```rust
pub struct BalanceChange {
    pub address: SuiAddress,
    pub coin_type: TypeTag,
    pub amount: i128,  // Negative = spent, positive = received
}
```

## Converting Existing Coins to Address Balances

Migration is optional. The SDK automatically selects coins or address balances as needed.

To consolidate coins into address balances:

```bash
sui client ptb \
    --merge-coins @<coin1> '[@<coin2>, @<coin3>]' \
    --move-call 0x2::coin::send_funds '<0x2::sui::SUI>' @<coin1> @<your_address>
```

Or using `CoinWithBalance` in TypeScript:

```typescript
const tx = new Transaction();
const coin = tx.add(coinWithBalance({ type: '0x2::sui::SUI', balance: totalAmount }));
tx.moveCall({
    target: '0x2::coin::send_funds',
    typeArguments: ['0x2::sui::SUI'],
    arguments: [coin, tx.pure.address(yourAddress)],
});
```

This may earn storage rebates from deleted coin objects.

## Backward Compatibility

### Existing Contracts

Contracts that accept `Coin<T>` or `Balance<T>` remain callable. The `redeem_funds` functions convert withdrawals to the expected types within the PTB.

### Legacy Clients

A JSON-RPC compatibility layer presents "fake coins" representing address balance reservations. This preserves basic functionality for clients that cannot upgrade, but should not be relied upon for new development.

## Framework Functions Reference

### balance.move

```move
// Send balance to an address's funds accumulator
public fun send_funds<T>(balance: Balance<T>, recipient: address)

// Redeem a withdrawal to get Balance<T>
public fun redeem_funds<T>(withdrawal: Withdrawal<Balance<T>>): Balance<T>

// Create a withdrawal from an object's balance
public fun withdraw_funds_from_object<T>(obj: &mut UID, value: u64): Withdrawal<Balance<T>>
```

### coin.move

```move
// Redeem a withdrawal and create a Coin<T>
public fun redeem_funds<T>(withdrawal: Withdrawal<Balance<T>>, ctx: &mut TxContext): Coin<T>

// Send a coin to an address balance
public fun send_funds<T>(coin: Coin<T>, recipient: address)
```

### funds_accumulator.move

```move
// Withdrawal struct - created via FundsWithdrawalArg or withdraw_from_object
public struct Withdrawal<phantom T: store> has drop {
    owner: address,
    limit: u256,
}

// Get withdrawal limit
public fun withdrawal_limit<T: store>(withdrawal: &Withdrawal<T>): u256

// Get withdrawal owner
public fun withdrawal_owner<T: store>(withdrawal: &Withdrawal<T>): address

// Split a sub-withdrawal
public fun withdrawal_split<T: store>(withdrawal: &mut Withdrawal<T>, sub_limit: u256): Withdrawal<T>

// Join withdrawals (must have same owner)
public fun withdrawal_join<T: store>(withdrawal: &mut Withdrawal<T>, other: Withdrawal<T>)
```
