{/* Copyright (c) Mysten Labs, Inc. */}
{/* SPDX-License-Identifier: Apache-2.0 */}

---
title: Address Balances Migration Guide
description: Migrating from Coin objects to address balances on Sui.
---

Address balances introduce a canonical balance system for fungible assets tied to Sui addresses. This replaces the UTXO-style `Coin<T>` model with direct address-owned balances, simplifying transaction construction and eliminating coin selection complexity.

For the full specification, see [SIP-58: Sui Address Balances](https://github.com/sui-foundation/sips/blob/main/sips/sip-58.md).

## Overview

Previously, balances on Sui were computed by summing the values of all `Coin<T>` objects owned by an address. With address balances, each address may additionally have one address-owned balance for each currency type `T`. The total balance is the sum of all `Coin<T>` objects plus the address balance value for that coin type.

`Coin<T>` and address balances coexist. Existing coins remain functional and can still be transferred with `transfer::public_transfer`. However, address balances provide significant operational advantages:
- No coin selection logic required
- Automatic deposit merging into a single canonical balance
- Stateless transaction construction without querying object states
- Direct gas payment from SUI address balances

## Funding Transactions from Address Balances

### Before: Coin Selection

With the coin-based model, funding a transaction requires:

1. **Query owned coins**: Call `suix_getCoins` or `suix_getAllCoins` to retrieve all `Coin<T>` objects owned by the address
2. **Select coins**: Implement coin selection logic to choose a set of coins whose values sum to at least the required amount
3. **Handle object references**: Include the exact `ObjectRef` (object ID, version, digest) for each selected coin in the transaction
4. **Merge if needed**: If multiple coins are selected, add `MergeCoins` commands to combine them before use
5. **Manage concurrency**: Track which coins are "in flight" to avoid double-spending across parallel transactions

[TypeScript SDK - SuiClient.getCoins](https://sdk.mystenlabs.com/typedoc/classes/_mysten_sui.client.SuiClient.html#getCoins):

```typescript
// Before: Coin-based funding
const coins = await client.getCoins({ owner: address, coinType: '0x2::sui::SUI' });

// Select coins that sum to required amount
let selected = [];
let total = 0n;
for (const coin of coins.data) {
    selected.push(coin);
    total += BigInt(coin.balance);
    if (total >= requiredAmount) break;
}

if (total < requiredAmount) {
    throw new Error('Insufficient balance');
}

// Use selected coins in transaction
const tx = new Transaction();
if (selected.length > 1) {
    tx.mergeCoins(selected[0].coinObjectId, selected.slice(1).map(c => c.coinObjectId));
}
const [coin] = tx.splitCoins(selected[0].coinObjectId, [requiredAmount]);
```

### After: Address Balance Withdrawals

With address balances, declare the amount needed and the protocol handles the rest.

[TypeScript SDK - CoinWithBalance](https://sdk.mystenlabs.com/typescript/transaction-building/intents#coinwithbalance):

```typescript
// After: Address balance funding
const tx = new Transaction();

// CoinWithBalance handles everything automatically
const coin = tx.add(coinWithBalance({ type: '0x2::sui::SUI', balance: requiredAmount }));
```

The SDK's `CoinWithBalance` intent automatically selects address balance funds or coins as needed. No object queries, no coin selection, no concurrency management.

For manual PTB construction, add a `FundsWithdrawalArg` to declare the withdrawal.

[Source: sui-types/src/transaction.rs - FundsWithdrawalArg](https://github.com/MystenLabs/sui/blob/main/crates/sui-types/src/transaction.rs):

```rust
// Rust
use sui_types::transaction::{FundsWithdrawalArg, WithdrawalTypeArg, Reservation, WithdrawFrom};

let withdrawal_arg = FundsWithdrawalArg {
    reservation: Reservation::MaxAmountU64(amount),
    type_arg: WithdrawalTypeArg::Balance(coin_type),
    withdraw_from: WithdrawFrom::Sender,
};
```

The helper `FundsWithdrawalArg::balance_from_sender(amount, balance_type)` provides a convenient constructor.

In your PTB, pass the withdrawal input to either:
- `0x2::balance::redeem_funds<T>()` to obtain a `Balance<T>`
- `0x2::coin::redeem_funds<T>()` to obtain a `Coin<T>`

[Source: sui-types/src/programmable_transaction_builder.rs](https://github.com/MystenLabs/sui/blob/main/crates/sui-types/src/programmable_transaction_builder.rs):

```rust
// Rust example: withdraw and transfer
let mut builder = ProgrammableTransactionBuilder::new();

let withdraw_arg = FundsWithdrawalArg::balance_from_sender(
    withdraw_amount,
    sui_types::gas_coin::GAS::type_tag(),
);
let withdraw_input = builder.funds_withdrawal(withdraw_arg).unwrap();

// Redeem to coin
let coin = builder.programmable_move_call(
    SUI_FRAMEWORK_PACKAGE_ID,
    Identifier::new("coin").unwrap(),
    Identifier::new("redeem_funds").unwrap(),
    vec!["0x2::sui::SUI".parse().unwrap()],
    vec![withdraw_input],
);

builder.transfer_arg(recipient, coin);
```

You may have multiple `FundsWithdrawalArg` inputs in a PTB, even for the same coin type.

### Splitting and Joining Withdrawals

Withdrawals can be split and merged within a PTB.

[Source: sui-framework/sources/funds_accumulator.move](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/funds_accumulator.move):

```move
// Split a sub-withdrawal from an existing withdrawal
public fun withdrawal_split<T: store>(withdrawal: &mut Withdrawal<T>, sub_limit: u256): Withdrawal<T>

// Join two withdrawals together (must have same owner)
public fun withdrawal_join<T: store>(withdrawal: &mut Withdrawal<T>, other: Withdrawal<T>)
```

### TypeScript SDK

For manual PTB construction with address balance withdrawals, use `Inputs.FundsWithdrawal`.

[TypeScript SDK - Inputs](https://github.com/MystenLabs/ts-sdks/blob/main/packages/sui/src/transactions/Inputs.ts):

```typescript
import { Transaction, Inputs } from '@mysten/sui/transactions';

const coinType = '0x2::sui::SUI';
const amount = 1_000_000_000n; // 1 SUI in MIST

const tx = new Transaction();

// Create a FundsWithdrawal input to withdraw from sender's address balance
const withdrawal = tx.addInput(
    'withdrawal',
    Inputs.FundsWithdrawal({
        reservation: {
            $kind: 'MaxAmountU64',
            MaxAmountU64: String(amount),
        },
        typeArg: {
            $kind: 'Balance',
            Balance: coinType,
        },
        withdrawFrom: {
            $kind: 'Sender',
            Sender: true,
        },
    }),
);

// Redeem the withdrawal to a Coin<T>
const coin = tx.moveCall({
    target: '0x2::coin::redeem_funds',
    typeArguments: [coinType],
    arguments: [withdrawal],
});

// Use the coin (e.g., transfer to recipient)
tx.transferObjects([coin], recipient);
```

The `FundsWithdrawal` input takes three fields:
- `reservation`: Specifies the maximum amount to withdraw. Use `{ $kind: 'MaxAmountU64', MaxAmountU64: string }`.
- `typeArg`: The balance type. Use `{ $kind: 'Balance', Balance: coinType }` where `coinType` is like `'0x2::sui::SUI'`.
- `withdrawFrom`: The source of funds. Use `{ $kind: 'Sender', Sender: true }` for the transaction sender, or `{ $kind: 'Sponsor', Sponsor: true }` for the gas sponsor.

#### Withdrawing from Sponsor's Address Balance

To withdraw from the gas sponsor's address balance instead of the sender's:

```typescript
const withdrawal = tx.addInput(
    'withdrawal',
    Inputs.FundsWithdrawal({
        reservation: {
            $kind: 'MaxAmountU64',
            MaxAmountU64: String(amount),
        },
        typeArg: {
            $kind: 'Balance',
            Balance: coinType,
        },
        withdrawFrom: {
            $kind: 'Sponsor',
            Sponsor: true,
        },
    }),
);
```

This requires the transaction to have a sponsor (via `tx.setSponsor()`) and the sponsor must sign.

## Sending Funds

### Before: Coin Transfers

To send funds to another address with coins:

1. **Select or create a coin**: Either use an existing coin of the exact amount, or split from a larger coin
2. **Transfer the object**: Use `transfer::public_transfer` to send the coin object to the recipient
3. **Recipient receives an object**: The recipient now owns a new `Coin<T>` object they must manage

[TypeScript SDK - Transaction.transferObjects](https://sdk.mystenlabs.com/typescript/transaction-building/basics#transferobjects):

```typescript
// Before: Transfer a coin object
const tx = new Transaction();
const [coin] = tx.splitCoins(tx.gas, [amount]);
tx.transferObjects([coin], recipient);
```

[Source: sui-framework/sources/transfer.move](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/transfer.move):

```move
// Before: In Move contract
public fun send_payment(coin: Coin<SUI>, recipient: address) {
    transfer::public_transfer(coin, recipient);
}
```

Each transfer creates a new object for the recipient, contributing to object proliferation. Recipients accumulate many small coin objects over time, requiring periodic consolidation.

### After: Address Balance Deposits

With address balances, funds merge automatically into the recipient's canonical balance.

[Source: sui-framework/sources/coin.move - send_funds](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/coin.move#L176):

```typescript
// After: Send to address balance
const tx = new Transaction();
const [coin] = tx.splitCoins(tx.gas, [amount]);
tx.moveCall({
    target: '0x2::coin::send_funds',
    typeArguments: ['0x2::sui::SUI'],
    arguments: [coin, tx.pure.address(recipient)],
});
```

```move
// After: In Move contract
public fun send_payment(coin: Coin<SUI>, recipient: address) {
    coin::send_funds(coin, recipient);
}
```

The recipient's balance increases without creating new objects. Multiple deposits from different senders all merge into one balance.

### Move Functions

[Source: sui-framework/sources/balance.move - send_funds](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/balance.move#L102):

```move
// Send a Balance<T> to an address balance
public fun send_funds<T>(balance: Balance<T>, recipient: address)
```

[Source: sui-framework/sources/coin.move - send_funds](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/coin.move#L176):

```move
// Send a Coin<T> to an address balance (converts to balance internally)
public fun send_funds<T>(coin: Coin<T>, recipient: address)
```

### CLI

[Sui CLI Reference - PTB](https://docs.sui.io/references/cli/ptb):

```bash
# Send from gas coin to address balance
sui client ptb \
    --split-coins gas '[5000000]' \
    --assign coin \
    --move-call 0x2::coin::send_funds '<0x2::sui::SUI>' coin @<recipient_address>

# Send from another coin
sui client ptb \
    --split-coins @<coin_id> '[5000000]' \
    --assign coin \
    --move-call 0x2::coin::send_funds '<coin_type>' coin @<recipient_address>
```

## Paying Gas from Address Balances

### Before: Gas Coin Management

With coin-based gas payment:

1. **Query gas coins**: Fetch owned SUI coins to find suitable gas payment objects
2. **Select gas coin(s)**: Choose coin(s) with sufficient balance for the gas budget
3. **Include object references**: Provide exact `ObjectRef` for each gas coin in `gas_data.payment`
4. **Handle gas coin mutations**: The gas coin is mutated by the transaction, changing its version

[Source: sui-types/src/transaction.rs - GasData](https://github.com/MystenLabs/sui/blob/main/crates/sui-types/src/transaction.rs):

```rust
// Before: Gas paid from coin objects
TransactionData::V1(TransactionDataV1 {
    kind: tx_kind,
    sender,
    gas_data: GasData {
        payment: vec![gas_coin_ref],  // Must have current ObjectRef
        owner: sender,
        price: rgp,
        budget: 10_000_000,
    },
    expiration: TransactionExpiration::None,
})
```

Gas coin management creates coordination challenges:
- Must query current gas coin state before each transaction
- Parallel transactions require separate gas coins or careful sequencing
- Gas coin version changes after each transaction

### After: Stateless Gas Payment

With address balance gas payment, no gas coin queries needed.

[Source: sui-types/src/transaction.rs - TransactionExpiration::ValidDuring](https://github.com/MystenLabs/sui/blob/main/crates/sui-types/src/transaction.rs):

```rust
// After: Gas paid from address balance
TransactionData::V1(TransactionDataV1 {
    kind: tx_kind,
    sender,
    gas_data: GasData {
        payment: vec![],  // Empty - gas paid from address balance
        owner: sender,
        price: rgp,
        budget: 10_000_000,
    },
    expiration: TransactionExpiration::ValidDuring {
        min_epoch: Some(current_epoch),
        max_epoch: Some(current_epoch),  // At most min_epoch + 1
        min_timestamp: None,
        max_timestamp: None,
        chain: chain_identifier,
        nonce: unique_nonce,
    },
})
```

Requirements for address balance gas payments:
- `gas_data.payment` must be empty
- `expiration` must be `ValidDuring` with both `min_epoch` and `max_epoch` specified
- `max_epoch` must be at most `min_epoch + 1` (single epoch or 1-epoch range)
- Timestamp-based expiration is not currently supported
- The transaction kind must be `ProgrammableTransaction`

The `nonce` field provides replay protection for stateless transactions. Use a unique value (e.g., random number, incrementing counter) for each transaction.

### Sponsored Transactions

#### Before: Sponsored Gas with Coins

Gas sponsorship with coins requires coordination between user and sponsor:

1. User constructs transaction without gas
2. Sponsor selects gas coin(s) and adds to transaction
3. Both parties sign
4. Risk: sponsor's gas coins could be locked if user doesn't complete signing

#### After: Sponsored Gas with Address Balances

[Source: sui-types/src/transaction.rs](https://github.com/MystenLabs/sui/blob/main/crates/sui-types/src/transaction.rs):

```rust
TransactionData::V1(TransactionDataV1 {
    kind: tx_kind,
    sender,
    gas_data: GasData {
        payment: vec![],
        owner: sponsor,  // Sponsor's address balance pays gas
        price: rgp,
        budget: budget,
    },
    expiration: TransactionExpiration::ValidDuring {
        min_epoch: Some(epoch),
        max_epoch: Some(epoch),
        min_timestamp: None,
        max_timestamp: None,
        chain: chain_id,
        nonce: nonce,
    },
})
```

Both sender and sponsor must sign. Storage rebates are credited to the sponsor's address balance.

Benefits over coin-based sponsorship:
- No gas coin locking risk
- Sponsor doesn't need to manage gas coin inventory
- Enables permissionless public gas stations

## Querying Balances via RPC

### Before: Summing Coin Objects

To determine total balance with coins:

[TypeScript SDK - SuiClient.getAllCoins](https://sdk.mystenlabs.com/typedoc/classes/_mysten_sui.client.SuiClient.html#getAllCoins):

```typescript
// Before: Sum all coin objects
const coins = await client.getAllCoins({ owner: address, coinType: '0x2::sui::SUI' });
const totalBalance = coins.data.reduce((sum, coin) => sum + BigInt(coin.balance), 0n);
```

Or use the convenience method that does this server-side.

[JSON-RPC Reference - suix_getBalance](https://docs.sui.io/sui-api-ref#suix_getbalance):

```bash
curl -s https://fullnode.testnet.sui.io \
    -H 'Content-Type: application/json' \
    -d '{"jsonrpc":"2.0","id":1,"method":"suix_getBalance","params":["<address>", "0x2::sui::SUI"]}'
```

### After: Including Address Balances

The same RPC methods now include address balance information. A new `fundsInAddressBalance` field indicates address balance holdings.

[JSON-RPC Reference - suix_getBalance](https://docs.sui.io/sui-api-ref#suix_getbalance):

```bash
# JSON-RPC
curl -s https://fullnode.testnet.sui.io \
    -H 'Content-Type: application/json' \
    -d '{
        "jsonrpc":"2.0",
        "id":1,
        "method":"suix_getBalance",
        "params":["<address>", "0x2::sui::SUI"]
    }'
```

Response:
```json
{
    "coinType": "0x2::sui::SUI",
    "coinObjectCount": 2,
    "totalBalance": "99998990120",
    "lockedBalance": {},
    "fundsInAddressBalance": "5000000"
}
```

The `totalBalance` includes both coin objects and address balance funds. To get only the coin-based balance, subtract `fundsInAddressBalance` from `totalBalance`.

[JSON-RPC Reference - suix_getAllBalances](https://docs.sui.io/sui-api-ref#suix_getallbalances):

```bash
# Get all balances
curl -s https://fullnode.testnet.sui.io \
    -H 'Content-Type: application/json' \
    -d '{
        "jsonrpc":"2.0",
        "id":1,
        "method":"suix_getAllBalances",
        "params":["<address>"]
    }'
```

### gRPC

Use `GetBalance` and `ListBalances` from `StateService`.

[gRPC Reference - GetBalanceRequest](https://docs.sui.io/references/fullnode-protocol#sui-rpc-v2-GetBalanceRequest):

```bash
buf curl --protocol grpc https://fullnode.testnet.sui.io/sui.rpc.v2.StateService/GetBalance \
    -d '{
        "owner": "<address>",
        "coin_type": "0x2::sui::SUI"
    }'
```

Response:
```json
{
    "balance": {
        "coinType": "0x2::sui::SUI",
        "balance": "99998990120",
        "addressBalance": "5000000",
        "coinBalance": "99993990120"
    }
}
```

Fields:
- `coinBalance`: Total held in coin objects
- `addressBalance`: Amount held in address balance
- `balance`: Sum of the two

[gRPC Reference - ListBalancesRequest](https://docs.sui.io/references/fullnode-protocol#sui-rpc-v2-ListBalancesRequest):

```bash
# List all balances
buf curl --protocol grpc https://fullnode.testnet.sui.io/sui.rpc.v2.StateService/ListBalances \
    -d '{"owner": "<address>"}'
```

### GraphQL

[GraphQL Reference - IAddressable.balance](https://docs.sui.io/references/sui-api/sui-graphql/beta/reference/types/interfaces/iaddressable):

```graphql
# Single balance
{
    address(address: "<address>") {
        balance(coinType: "0x2::sui::SUI") {
            coinType { repr }
            addressBalance
            coinBalance
            totalBalance
        }
    }
}

# All balances
{
    address(address: "<address>") {
        balances {
            nodes {
                coinType { repr }
                addressBalance
                coinBalance
                totalBalance
            }
        }
    }
}
```

## Computing Balance Changes from Checkpoint Data

### Before: Coin Object Diffs

To compute balance changes from checkpoint data with coins only:

1. Get input objects (coins at their pre-transaction versions)
2. Get output objects (coins at their post-transaction versions)
3. For each `(address, coin_type)` pair, sum output coin values minus input coin values

```rust
// Before: Coin-only balance changes
fn derive_coin_balance_changes(
    input_objects: &[Object],
    output_objects: &[Object],
) -> BTreeMap<(SuiAddress, TypeTag), i128> {
    let mut balances = BTreeMap::new();

    // Subtract input coins
    for obj in input_objects {
        if let Some((owner, coin_type, value)) = extract_coin_info(obj) {
            *balances.entry((owner, coin_type)).or_default() -= value as i128;
        }
    }

    // Add output coins
    for obj in output_objects {
        if let Some((owner, coin_type, value)) = extract_coin_info(obj) {
            *balances.entry((owner, coin_type)).or_default() += value as i128;
        }
    }

    balances
}
```

### After: Coins Plus Accumulator Events

With address balances, you must also process accumulator events from `TransactionEffects`.

[Source: sui-types/src/balance_change.rs](https://github.com/MystenLabs/sui/blob/main/crates/sui-types/src/balance_change.rs):

```rust
// After: Include accumulator events
use sui_types::balance_change::{derive_balance_changes, BalanceChange};

let balance_changes: Vec<BalanceChange> = derive_balance_changes(
    &effects,
    &input_objects,
    &output_objects,
);
```

The algorithm:
1. **Subtract input coins**: For each input coin object, subtract its value from `(owner, coin_type)`
2. **Add output coins**: For each mutated/created coin object, add its value to `(owner, coin_type)`
3. **Process accumulator events**: For each accumulator event with a `Balance<T>` type:
   - `Split` operation: Subtract the amount (funds withdrawn from address balance)
   - `Merge` operation: Add the amount (funds deposited to address balance)

### Accessing Accumulator Events

Accumulator events are embedded in `TransactionEffects`.

[Source: sui-types/src/effects/mod.rs - TransactionEffectsAPI](https://github.com/MystenLabs/sui/blob/main/crates/sui-types/src/effects/mod.rs):

```rust
use sui_types::effects::TransactionEffectsAPI;

let events = effects.accumulator_events();
for event in events {
    let address = event.write.address.address;
    let balance_type = &event.write.address.ty;

    // Only Balance<T> types represent balance changes
    if let Some(coin_type) = Balance::maybe_get_balance_type_param(balance_type) {
        let amount = match &event.write.value {
            AccumulatorValue::Integer(v) => *v as i128,
            _ => continue,
        };

        let signed_amount = match event.write.operation {
            AccumulatorOperation::Split => -amount,  // Withdrawal
            AccumulatorOperation::Merge => amount,   // Deposit
        };

        // (address, coin_type, signed_amount) represents the balance change
    }
}
```

### Key Types

[Source: sui-types/src/balance_change.rs](https://github.com/MystenLabs/sui/blob/main/crates/sui-types/src/balance_change.rs):

```rust
pub struct BalanceChange {
    pub address: SuiAddress,
    pub coin_type: TypeTag,
    pub amount: i128,  // Negative = spent, positive = received
}
```

## Converting Existing Coins to Address Balances

Migration is optional. The SDK automatically selects coins or address balances as needed.

To consolidate coins into address balances:

[Sui CLI Reference - PTB](https://docs.sui.io/references/cli/ptb):

```bash
sui client ptb \
    --merge-coins @<coin1> '[@<coin2>, @<coin3>]' \
    --move-call 0x2::coin::send_funds '<0x2::sui::SUI>' @<coin1> @<your_address>
```

Or using `CoinWithBalance` in TypeScript:

[TypeScript SDK - CoinWithBalance](https://sdk.mystenlabs.com/typescript/transaction-building/intents#coinwithbalance):

```typescript
const tx = new Transaction();
const coin = tx.add(coinWithBalance({ type: '0x2::sui::SUI', balance: totalAmount }));
tx.moveCall({
    target: '0x2::coin::send_funds',
    typeArguments: ['0x2::sui::SUI'],
    arguments: [coin, tx.pure.address(yourAddress)],
});
```

This may earn storage rebates from deleted coin objects.

## Backward Compatibility

### Existing Contracts

Contracts that accept `Coin<T>` or `Balance<T>` remain callable. The `redeem_funds` functions convert withdrawals to the expected types within the PTB.

### Legacy Clients

A JSON-RPC compatibility layer presents "fake coins" representing address balance reservations. This preserves basic functionality for clients that cannot upgrade, but should not be relied upon for new development.

## Framework Functions Reference

### balance.move

[Source: sui-framework/sources/balance.move](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/balance.move):

```move
// Send balance to an address's funds accumulator
public fun send_funds<T>(balance: Balance<T>, recipient: address)

// Redeem a withdrawal to get Balance<T>
public fun redeem_funds<T>(withdrawal: Withdrawal<Balance<T>>): Balance<T>

// Create a withdrawal from an object's balance
public fun withdraw_funds_from_object<T>(obj: &mut UID, value: u64): Withdrawal<Balance<T>>
```

### coin.move

[Source: sui-framework/sources/coin.move](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/coin.move):

```move
// Redeem a withdrawal and create a Coin<T>
public fun redeem_funds<T>(withdrawal: Withdrawal<Balance<T>>, ctx: &mut TxContext): Coin<T>

// Send a coin to an address balance
public fun send_funds<T>(coin: Coin<T>, recipient: address)
```

### funds_accumulator.move

[Source: sui-framework/sources/funds_accumulator.move](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/funds_accumulator.move):

```move
// Withdrawal struct - created via FundsWithdrawalArg or withdraw_from_object
public struct Withdrawal<phantom T: store> has drop {
    owner: address,
    limit: u256,
}

// Get withdrawal limit
public fun withdrawal_limit<T: store>(withdrawal: &Withdrawal<T>): u256

// Get withdrawal owner
public fun withdrawal_owner<T: store>(withdrawal: &Withdrawal<T>): address

// Split a sub-withdrawal
public fun withdrawal_split<T: store>(withdrawal: &mut Withdrawal<T>, sub_limit: u256): Withdrawal<T>

// Join withdrawals (must have same owner)
public fun withdrawal_join<T: store>(withdrawal: &mut Withdrawal<T>, other: Withdrawal<T>)
```
