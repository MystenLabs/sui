---
title: Build A Registry Using Derived Objects
description: 
keywords: []
---

At its core, a registry is just a mapping from a key to a record. Package managers use a registry of name to version to make sure your projects include the right dependencies. On a blockchain, this registry is an on-chain object that owns or references entries. On Sui, there are different approaches you can take to create this registry pattern. One of the most efficient ways is through the use of derived objects. 

Using the derived object approach, you create a registry object that you must have to create the objects in the registry. 

```move
module examples::derived_usernames {
    use sui::derived_object;
    use sui::table::{Self, Table};

    const ERegistryAlreadyExists: u64 = 0;

    /// A tiny parent object that defines the namespace.
    /// It does NOT store children; it only records claimed keys via dynamic fields internally.
    public struct Registry has key {
        id: UID,
        usernames: Table<address, Username>,
    }

    /// The per-key top-level object. It's not stored inside `Registry`.
    public struct Username has key, store {
        id: UID,
        username: vector<u8>,
    }

    /// Initializes a fresh Registry object and shares it so anyone can use it
    public fun create_registry(ctx: &mut TxContext) {
        let registry = Registry { 
            id: object::new(ctx), 
            usernames: table::new(ctx),
        };
        transfer::share_object(registry);
    }

    /// Claim a derived Username for the transaction sender (`key = sender address`).
    /// - Enforces one-per-user uniqueness at the parent level.
    /// - Creates a top-level, OWNED object (fast path for future edits).
    #[allow(lint(self_transfer))]
    public fun register(reg: &mut Registry, name: vector<u8>, ctx: &mut TxContext) {
        let sender = ctx.sender();
        // Optional: preflight check (returns true if the key was already claimed at any point)
        assert!(!derived_object::exists(&reg.id, ctx.sender()), ERegistryAlreadyExists);

        // Claim returns a fresh UID whose address is deterministically derived from (parent, key).
        // This mutates the parent only to mark the key as claimed, but does NOT store the child.
        let uid: UID = derived_object::claim(&mut reg.id, sender);

        // Materialize the derived object and hand it to the user as an OWNED object.
        let uname = Username { id: uid, username: name };
        transfer::public_transfer(uname, sender);
    }

    /// Users can mutate their owned Username directly (no parent involved).
    public fun set(uname: &mut Username, new_name: vector<u8>) {
        uname.username = new_name;
    }

    /// (Optional) Compute the *address* of a derived Username for a given owner.
    /// This is read-only and does not reserve/claim anything.
    public fun derived_address_for(reg: &Registry, owner: address): address {
        let pid: ID = object::id(reg);
        derived_object::derive_address(pid, owner)
    }
}

```


