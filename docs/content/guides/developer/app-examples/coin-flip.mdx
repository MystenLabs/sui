---
title: Coin Flip
description: Learn Sui through a coin flip dApp that covers the full end-to-end flow of building a Sui Move module and connecting it to a React Sui dApp.
keywords: [ react app, react dApp, react example, on-chain randomness, randomness, shared objects, one-time witness, assets, address-owned objects, events, storage rebates, gas sponsorship, enoki, example app, example dApp ]
---

This example walks you through building a Coin Flip dApp, covering the full end-to-end flow of building your Sui Move module and connecting it to your React Sui dApp. This Coin Flip dApp utilizes Sui's native on-chain randomness to create a provably fair coin game on the Sui blockchain. The user (human) plays against the house (module) and places a bet on either heads or tails. The user then either receives double their bet, or gets nothing, depending on the outcome of the game.

The guide is split into two parts:

1. [Smart Contracts](#smart-contracts): The Move code that sets up the coin flip logic.
1. [Frontend](#frontend): A UI that enables the players to place bets and take profits, and the admin to manage the house. 

<ImportContent source="prerequisites.mdx" mode="snippet" />

:::tip Additional resources

Source code location for the complete dApp (smart contracts and frontend):
- [Satoshi Coin Flip repository](https://github.com/MystenLabs/satoshi-coin-flip)

:::

## What the guide teaches

- **On-chain randomness:** The guide teaches you how to use [Sui's native on-chain randomness](concepts/cryptography/transaction-auth/randomness.mdx) to create provably fair games without relying on external services.
- **Shared objects:** The guide teaches you how to use [shared objects](concepts/object-ownership/shared.mdx), in this case to create a globally accessible `HouseData` object.
- **One-time witnesses:** The guide teaches you how to use [one-time witnesses](concepts/sui-move-concepts.mdx#one-time-witness) to ensure only a single instance of the `HouseData` object ever exists.
- **Asserts:** The guide teaches you how to use [asserts](https://move-book.com/move-basics/assert-and-abort.html?highlight=asserts#assert) to abort functions due to certain conditions not being met.
- **Address-owned objects:** The guide teaches you how to use [address-owned objects](concepts/object-ownership/address-owned.mdx) when necessary.
- **Events:** The guide teaches you how to emit events in your contracts, which can be used to track on-chain activity. For more information on events, see [Using Events](../sui-101/using-events.mdx) for practical usage of events on Sui or [Events in The Move Book](https://move-book.com/programmability/events.html) to learn about event structure and how to emit them in Move.
- **Storage rebates:** The guide shows you best practices regarding [storage fee rebates](concepts/tokenomics.mdx#storage-fund-rewards).
- **Gas sponsorship:** The guide demonstrates how to use [Enoki](https://docs.enoki.mystenlabs.com/) for transaction sponsorship, enabling gas-free experiences for end users.
- **Type-safe Move bindings:** The guide shows you how to use [@mysten/codegen](https://sdk.mystenlabs.com/typescript/codegen) to auto-generate TypeScript bindings from your Move contracts, ensuring type safety across your full-stack application.


## Smart contracts {#smart-contracts}

In this part of the guide, you write the Move contracts that manage the house and set up the coin-flip logic. The first step is to [set up a Move package](/guides/developer/getting-started/hello-world.mdx) for storing your Move modules.

:::info

To follow along with this guide, set your new Move package to `satoshi_flip`.

:::

### `house_data` module

This example uses several modules to create a package for the Satoshi Coin Flip game. The first module is `house_data.move`. You need to store the game's data somewhere, and in this module you create a [shared object](concepts/object-ownership/shared.mdx) for all house data.

Create a new file in the `sources` directory with the name `house_data.move` and populate the file with the following code:

```move title='house_data.move'
module satoshi_flip::house_data {

  use sui::balance::{Self, Balance};
  use sui::sui::SUI;
  use sui::coin::{Self, Coin};
  use sui::package::{Self};

  // Error codes
  const ECallerNotHouse: u64 = 0;
  const EInsufficientBalance: u64 = 1;

```

There are few details to take note of in this code:

1. The first line declares the module name as `house_data` within the package `satoshi_flip`.
1. Seven lines begin with the `use` keyword, which enables this module to use types and functions declared in other modules (in this case, they are all coming from the Sui standard library).
1. Two error codes. These codes are used in assertions and unit tests to ensure that the program is running as intended.

Next, add some more code to this module:

```move title='house_data.move'
  /// Configuration and Treasury object, managed by the house.
  public struct HouseData has key {
    id: UID,
    balance: Balance<SUI>,
    house: address,
    max_stake: u64,
    min_stake: u64,
    fees: Balance<SUI>,
    base_fee_in_bp: u16
  }

  /// A one-time use capability to initialize the house data; created and sent
  /// to sender in the initializer.
  public struct HouseCap has key {
    id: UID
  }

  /// Used as a one time witness to generate the publisher.
  public struct HOUSE_DATA has drop {}

  fun init(otw: HOUSE_DATA, ctx: &mut TxContext) {
    // Creating and sending the Publisher object to the sender.
    package::claim_and_keep(otw, ctx);

    // Creating and sending the HouseCap object to the sender.
    let house_cap = HouseCap {
      id: object::new(ctx)
    };

    transfer::transfer(house_cap, ctx.sender());
  }
```

- The first struct, `HouseData`, stores the most essential information pertaining to the game.
- The second struct, `HouseCap`, is a capability that initializes the house data.
- The third struct, `HOUSE_DATA`, is a one-time witness that ensures only a single instance of this `HouseData` ever exists.
- The `init` function creates and sends the `Publisher` and `HouseCap` objects to the sender. See [Module Initializer](https://move-book.com/programmability/module-initializer.html) in The Move Book for more information.

So far, you've set up the data structures within the module. Now, create a function that initializes the house data and shares the `HouseData` object:

```move title='house_data.move'
  public fun initialize_house_data(house_cap: HouseCap, coin: Coin<SUI>, ctx: &mut TxContext) {
    assert!(coin.value() > 0, EInsufficientBalance);

    let house_data = HouseData {
      id: object::new(ctx),
      balance: coin.into_balance(),
      house: ctx.sender(),
      max_stake: 50_000_000_000, // 50 SUI, 1 SUI = 10^9.
      min_stake: 1_000_000_000, // 1 SUI.
      fees: balance::zero(),
      base_fee_in_bp: 100 // 1% in basis points.
    };

    let HouseCap { id } = house_cap;
    object::delete(id);

    transfer::share_object(house_data);
  }
```

With the house data initialized, you also need to add some functions that enable some important administrative tasks for the house to perform:

```move title='house_data.move'
  public fun top_up(house_data: &mut HouseData, coin: Coin<SUI>, _: &mut TxContext) {
    coin::put(&mut house_data.balance, coin)
  }

  public fun withdraw(house_data: &mut HouseData, ctx: &mut TxContext) {
    // Only the house address can withdraw funds.
    assert!(ctx.sender() == house_data.house(), ECallerNotHouse);

    let total_balance = balance(house_data);
    let coin = coin::take(&mut house_data.balance, total_balance, ctx);
    transfer::public_transfer(coin, house_data.house());
  }

  public fun claim_fees(house_data: &mut HouseData, ctx: &mut TxContext) {
    // Only the house address can withdraw fee funds.
    assert!(ctx.sender() == house_data.house(), ECallerNotHouse);

    let total_fees = fees(house_data);
    let coin = coin::take(&mut house_data.fees, total_fees, ctx);
    transfer::public_transfer(coin, house_data.house());
  }

  public fun update_max_stake(house_data: &mut HouseData, max_stake: u64, ctx: &mut TxContext) {
    // Only the house address can update the base fee.
    assert!(ctx.sender() == house_data.house(), ECallerNotHouse);

    house_data.max_stake = max_stake;
  }

  public fun update_min_stake(house_data: &mut HouseData, min_stake: u64, ctx: &mut TxContext) {
    // Only the house address can update the min stake.
    assert!(ctx.sender() == house_data.house(), ECallerNotHouse);

    house_data.min_stake = min_stake;
  }
```

All of these functions contain an `assert!` call that ensures only the house can call them:

- `top_up`: Add to the balance of the house to ensure that there is enough SUI for future games.
- `withdraw`: Withdraw the entire balance of the house object.
- `claim_fees`: Withdraw the accumulated fees of the house object.
- `update_max_stake`, `update_min_stake`: Update the maximum and minimum stake allowed in the game, respectively.

You have established the data structure of this module, but without the appropriate functions this data is not accessible. Now add helper functions that return mutable references, read-only references, and test-only functions:

```move title='house_data.move'
  // --------------- Mutable References ---------------

  public(package) fun borrow_balance_mut(house_data: &mut HouseData): &mut Balance<SUI> {
    &mut house_data.balance
  }

  public(package) fun borrow_fees_mut(house_data: &mut HouseData): &mut Balance<SUI> {
    &mut house_data.fees
  }

  public(package) fun borrow_mut(house_data: &mut HouseData): &mut UID {
    &mut house_data.id
  }

  // --------------- Read-only References ---------------

  /// Returns a reference to the house id.
  public(package) fun borrow(house_data: &HouseData): &UID {
    &house_data.id
  }

  /// Returns the balance of the house.
  public fun balance(house_data: &HouseData): u64 {
    house_data.balance.value()
  }

  /// Returns the address of the house.
  public fun house(house_data: &HouseData): address {
    house_data.house
  }

  /// Returns the max stake of the house.
  public fun max_stake(house_data: &HouseData): u64 {
    house_data.max_stake
  }

  /// Returns the min stake of the house.
  public fun min_stake(house_data: &HouseData): u64 {
    house_data.min_stake
  }

  /// Returns the fees of the house.
  public fun fees(house_data: &HouseData): u64 {
    house_data.fees.value()
  }

  /// Returns the base fee.
  public fun base_fee_in_bp(house_data: &HouseData): u16 {
    house_data.base_fee_in_bp
  }

  // --------------- Test-only Functions ---------------

  #[test_only]
  public fun init_for_testing(ctx: &mut TxContext) {
    init(HOUSE_DATA {}, ctx);
  }
}
```

And with that, your `house_data.move` code is complete.

### `single_player_satoshi` module

Lastly, you need a game module and object that can create a new game, distribute funds after the game, and potentially cancel games. Because this is a one-player game, create an [address-owned object](concepts/object-ownership/address-owned.mdx) rather than a [shared object](/concepts/object-ownership/shared.mdx).

Create the game module. In the `sources` directory, create a new file called `single_player_satoshi.move` and populate with the following:

```move title='single_player_satoshi.move'
module satoshi_flip::single_player_satoshi {
  use std::string::String;

  use sui::coin::{Self, Coin};
  use sui::balance::Balance;
  use sui::sui::SUI;
  use sui::event::emit;
  use sui::random::{Self, Random};

  use satoshi_flip::house_data::HouseData;

  const EPOCHS_CANCEL_AFTER: u64 = 7;
  const GAME_RETURN: u8 = 2;
  const PLAYER_WON_STATE: u8 = 1;
  const HOUSE_WON_STATE: u8 = 2;
  const CHALLENGED_STATE: u8 = 3;
  const HEADS: vector<u8> = b"H";
  const TAILS: vector<u8> = b"T";

  const EStakeTooLow: u64 = 0;
  const EStakeTooHigh: u64 = 1;
  const ECanNotChallengeYet: u64 = 2;
  const EInvalidGuess: u64 = 3;
  const EInsufficientHouseBalance: u64 = 4;
  const EGameDoesNotExist: u64 = 5;

  public struct NewGame has copy, drop {
    game_id: ID,
    player: address,
    guess: String,
    user_stake: u64,
    fee_bp: u16
  }

  public struct Outcome has copy, drop {
    game_id: ID,
    status: u8
  }
```

This code follows the same pattern as the others. First, you include the respective imports, although this time the imports are not only from the standard library but also include modules created previously in this example. You also create several constants (in upper case), as well as constants used for errors (Pascal case prefixed with `E`).

Lastly in this section, you also create structs for two events to emit. Indexers consume emitted events, which enables you to track these events through API services, or your own indexer. In this case, the events are for when a new game begins (`NewGame`) and for the outcome of a game when it has finished (`Outcome`).

Add a struct to the module:

```move title='single_player_satoshi.move'
  public struct Game has key, store {
    id: UID,
    guess_placed_epoch: u64,
    total_stake: Balance<SUI>,
    guess: String,
    player: address,
    fee_bp: u16
  }
```

The `Game` struct represents a single game and all its information, including the epoch the player placed the bet (`guess_placed_epoch`), bet (`total_stake`), `guess`, address of the `player`, and the fee the house collects (`fee_bp`).

Now take a look at the main function in this game, `finish_game`:

```move title='single_player_satoshi.move'
  entry fun finish_game(game_id: ID, random_state: &Random, house_data: &mut HouseData, ctx: &mut TxContext) {
    // Ensure that the game exists.
    assert!(game_exists(house_data, game_id), EGameDoesNotExist);

    let Game {
      id,
      guess_placed_epoch: _,
      mut total_stake,
      guess,
      player,
      fee_bp
    } = dof::remove<ID, Game>(house_data.borrow_mut(), game_id);

    object::delete(id);

    // Step 1: Generate on-chain randomness.
    let mut generator = random::new_generator(random_state, ctx);
    let random_result = random::generate_bool(&mut generator);

    // Step 2: Determine winner - compare player's guess with random result.
    let player_won = map_guess(guess) == (if (random_result) { 1 } else { 0 });

    // Step 3: Distribute funds based on result.
    let status = if (player_won) {
      // Step 3.a: If player wins transfer the game balance as a coin to the player.
      // Calculate the fee and transfer it to the house.
      let stake_amount = total_stake.value();
      let fee_amount = fee_amount(stake_amount, fee_bp);
      let fees = total_stake.split(fee_amount);
      house_data.borrow_fees_mut().join(fees);

      // Calculate the rewards and take it from the game stake.
      transfer::public_transfer(total_stake.into_coin(ctx), player);
      PLAYER_WON_STATE
    } else {
      // Step 3.b: If house wins, then add the game stake to the house_data.house_balance (no fees are taken).
      house_data.borrow_balance_mut().join(total_stake);
      HOUSE_WON_STATE
    };

    emit(Outcome {
      game_id,
      status
    });
  }
```

- First, the function makes sure the `Game` object exists, then deletes it, as after the game concludes the metadata is no longer needed. Freeing up unnecessary storage is not only recommended, but [incentivized through rebates on storage fees](concepts/tokenomics.mdx#storage-fund-rewards).
- In step 1, the function uses Sui's native randomness module to generate a cryptographically secure random boolean. The `Random` shared object is provided by the Sui framework and ensures fair, verifiable randomness.
- In step 2, the function compares the player's guess (heads = 0, tails = 1) with the random result to determine the winner.
- In step 3, if the player won, meaning the player's guess matched the random result, the logic transfers fees from the stake to the house, then distributes the rest of the principle plus an equal amount from the house's balance back to the player. If the player loses, the logic transfers the entire stake to the house, and takes no fees.
- Lastly, the game emits its outcome as an event.

Now add a function that handles game disputes:

```move title='single_player_satoshi.move'
  public fun dispute_and_win(house_data: &mut HouseData, game_id: ID, ctx: &mut TxContext) {
    // Ensure that the game exists.
    assert!(game_exists(house_data, game_id), EGameDoesNotExist);

    let Game {
      id,
      guess_placed_epoch,
      total_stake,
      guess: _,
      player,
      vrf_input: _,
      fee_bp: _
    } = dof::remove(house_data.borrow_mut(), game_id);

    object::delete(id);

    let caller_epoch = ctx.epoch();
    let cancel_epoch = guess_placed_epoch + EPOCHS_CANCEL_AFTER;
    // Ensure that minimum epochs have passed before user can cancel.
    assert!(cancel_epoch <= caller_epoch, ECanNotChallengeYet);

    transfer::public_transfer(total_stake.into_coin(ctx), player);

    emit(Outcome {
      game_id,
      status: CHALLENGED_STATE
    });
  }
```

This function, `dispute_and_win`, ensures that no bet can live in “purgatory”. After a certain amount of time passes, the player can call this function and get all of their funds back.

The rest of the functions are accessors and helper functions used to retrieve values, check if values exist, initialize the game, and so on:

```move title='single_player_satoshi.move'
  // --------------- Read-only References ---------------

  public fun guess_placed_epoch(game: &Game): u64 {
    game.guess_placed_epoch
  }

  public fun stake(game: &Game): u64 {
    game.total_stake.value()
  }

  public fun guess(game: &Game): u8 {
    map_guess(game.guess)
  }

  public fun player(game: &Game): address {
    game.player
  }

  public fun vrf_input(game: &Game): vector<u8> {
    game.vrf_input
  }

  public fun fee_in_bp(game: &Game): u16 {
    game.fee_bp
  }

  // --------------- Helper functions ---------------

  /// Public helper function to calculate the amount of fees to be paid.
  public fun fee_amount(game_stake: u64, fee_in_bp: u16): u64 {
    ((((game_stake / (GAME_RETURN as u64)) as u128) * (fee_in_bp as u128) / 10_000) as u64)
  }

  /// Helper function to check if a game exists.
  public fun game_exists(house_data: &HouseData, game_id: ID): bool {
    dof::exists_(house_data.borrow(), game_id)
  }

  /// Helper function to check that a game exists and return a reference to the game Object.
  /// Can be used in combination with any accessor to retrieve the desired game field.
  public fun borrow_game(game_id: ID, house_data: &HouseData): &Game {
    assert!(game_exists(house_data, game_id), EGameDoesNotExist);
    dof::borrow(house_data.borrow(), game_id)
  }

  /// Internal helper function used to create a new game.
  fun internal_start_game(guess: String, coin: Coin<SUI>, house_data: &mut HouseData, fee_bp: u16, ctx: &mut TxContext): (ID, Game) {
    // Ensure guess is valid.
    map_guess(guess);
    let user_stake = coin.value();
    // Ensure that the stake is not higher than the max stake.
    assert!(user_stake <= house_data.max_stake(), EStakeTooHigh);
    // Ensure that the stake is not lower than the min stake.
    assert!(user_stake >= house_data.min_stake(), EStakeTooLow);
    // Ensure that the house has enough balance to play for this game.
    assert!(house_data.balance() >= user_stake, EInsufficientHouseBalance);

    // Get the house's stake.
    let mut total_stake = house_data.borrow_balance_mut().split(user_stake);
    coin::put(&mut total_stake, coin);

    let id = object::new(ctx);
    let game_id = object::uid_to_inner(&id);

    let new_game = Game {
      id,
      guess_placed_epoch: ctx.epoch(),
      total_stake,
      guess,
      player: ctx.sender(),
      fee_bp
    };

    emit(NewGame {
      game_id,
      player: ctx.sender(),
      guess,
      user_stake,
      fee_bp
    });

    (game_id, new_game)
  }

  /// Helper function to map (H)EADS and (T)AILS to 0 and 1 respectively.
  /// H = 0
  /// T = 1
  fun map_guess(guess: String): u8 {
    let heads = HEADS;
    let tails = TAILS;
    assert!(guess.bytes() == heads || guess.bytes() == tails, EInvalidGuess);

    if (guess.bytes() == heads) {
      0
    } else {
      1
    }
  }
}
```

## Finished package

This represents a complete example of a coin flip backend in Move using Sui's native on-chain randomness. The game module, `single_player_satoshi`, provides a secure and fair gaming experience with cryptographically verifiable randomness generated entirely on-chain.

Key advantages of this approach:
- **No external dependencies**: Randomness is generated natively by Sui's randomness beacon
- **Trustless**: No need to trust a backend service or VRF provider
- **Gas-efficient**: Single transaction to finish a game, with randomness generated in the same call
- **Verifiable**: Random outcomes can be verified in transaction effects

You can view the full source code for all the modules in the [Satoshi Coin Flip repository](https://github.com/MystenLabs/satoshi-coin-flip).

Now that you have written your contracts, it's time to deploy them.

### Deployment {#deployment}

<ImportContent source="initialize-sui-client-cli.mdx" mode="snippet" />

Next, configure the Sui CLI to use `testnet` as the active environment, as well. If you haven't already set up a `testnet` environment, do so by running the following command in a terminal or console:

```sh
$ sui client new-env --alias testnet --rpc https://fullnode.testnet.sui.io:443
```

Run the following command to activate the `testnet` environment:

```sh
$ sui client switch --env testnet
```

<ImportContent source="publish-to-devnet-with-coins.mdx" mode="snippet" />

The output of this command contains a `packageID` value that you need to save to use the package.

Partial snippet of CLI deployment output.

```sh
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Object Changes                                                                                           │
├──────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Created Objects:                                                                                         │
│  ┌──                                                                                                     │
│  │ ObjectID: 0x17e9468127384cfff5523940586f5617a75fac8fd93f143601983523ae9c9f31                          │
│  │ Sender: 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654                            │
│  │ Owner: Account Address ( 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654 )         │
│  │ ObjectType: 0x2::package::UpgradeCap                                                                  │
│  │ Version: 75261540                                                                                     │
│  │ Digest: 9ahkhuGYTNYi5GucCqmUHyBuWoV2R3rRqBu553KBPVv8                                                  │
│  └──                                                                                                     │
│  ┌──                                                                                                     │
│  │ ObjectID: 0xa01d8d5ba121e7771547e749a787b4dd9ff8cc32e341c898bab5d12c46412a23                          │
│  │ Sender: 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654                            │
│  │ Owner: Account Address ( 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654 )         │
│  │ ObjectType: 0x2::package::Publisher                                                                   │
│  │ Version: 75261540                                                                                     │
│  │ Digest: Ba9VU2dUqg3NHkwQ4t5AKDLJQuiFZnnxvty2xREQKWm9                                                  │
│  └──                                                                                                     │
│  ┌──                                                                                                     │
│  │ ObjectID: 0xfa1f6edad697afca055749fedbdee420b6cdba3edc2f7fd4927ed42f98a7e63a                          │
│  │ Sender: 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654                            │
│  │ Owner: Account Address ( 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654 )         │
│  │ ObjectType: 0x4120b39e5d94845aa539d4b830743a7433fd8511bdcf3841f98080080f327ca8::house_data::HouseCap  │
│  │ Version: 75261540                                                                                     │
│  │ Digest: 5326hf6zWgdiNgr63wvwKkhUNtnTFkp82e9vfS5QHy3n                                                  │
│  └──                                                                                                     │
│ Mutated Objects:                                                                                         │
│  ┌──                                                                                                     │
│  │ ObjectID: 0x0e4eb516f8899e116a26f927c8aaddae8466c8cdc3822f05c15159e3a8ff8006                          │
│  │ Sender: 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654                            │
│  │ Owner: Account Address ( 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654 )         │
│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                            │
│  │ Version: 75261540                                                                                     │
│  │ Digest: Ezmi94kWCfjRzgGTwnXehv9ipPvYQ7T6Z4wefPLRQPPY                                                  │
│  └──                                                                                                     │
│ Published Objects:                                                                                       │
│  ┌──                                                                                                     │
│  │ PackageID: 0x4120b39e5d94845aa539d4b830743a7433fd8511bdcf3841f98080080f327ca8                         │
│  │ Version: 1                                                                                            │
│  │ Digest: 5XbJkgx8RSccxaHoP3xinY2fMMhwKJ7qoWfp349cmZBg                                                  │
│  │ Modules: house_data, single_player_satoshi                                               │
│  └──                                                                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────╯
```

Save the `PackageID` and the `ObjectID` of the `HouseCap` object you receive in your own response to [connect to your frontend](#connecting-your-package).

In this case, the `PackageID` is `0x4120b39e5d94845aa539d4b830743a7433fd8511bdcf3841f98080080f327ca8` and the `HouseCap` ID is `0xfa1f6edad697afca055749fedbdee420b6cdba3edc2f7fd4927ed42f98a7e63a`.

### Next steps

Well done. You have written and deployed the Move package. 🎉 

To turn this into a complete dApp, you need to [create a frontend](#frontend).

## Frontend {#frontend}

In this final part of the dApp example, you build a frontend (UI) that allows end users to place bets and take profits, and lets the admin manage the house.

This example demonstrates two important new technologies in the Sui ecosystem:

**Gas Sponsorship with Enoki**: [Enoki](https://docs.enoki.mystenlabs.com/) enables transaction sponsorship, allowing you to create gas-free experiences for your users. The frontend uses Enoki's sponsorship API (via Vercel serverless functions) to sponsor game transactions, so players don't need SUI tokens to play (i.e., for paying the transaction gas fees). Enoki handles the sponsorship logic, validates allowed Move call targets, and executes sponsored transactions securely.

**Type-Safe Contract Bindings with @mysten/codegen**: The [@mysten/codegen](https://www.npmjs.com/package/@mysten/codegen) package auto-generates TypeScript bindings from your Move contracts. This provides compile-time type safety when calling Move functions from your frontend, preventing runtime errors and improving developer experience with autocomplete and type checking.

:::info

To skip building the frontend and test out your newly deployed package, use the provided [Satoshi Coin Flip repository](https://github.com/MystenLabs/satoshi-coin-flip) (the `app/` directory contains the complete frontend) and follow the instructions in the example's `README.md` file.

:::

<Tabs className="tabsHeadingCentered--small">
<TabItem value="prereq" label="Prerequisites">

- [x] [Install the latest version of Sui](/guides/developer/getting-started/sui-install).

- [x] [Deploy the complete `satoshi_flip` Move package](#smart-contracts) and understand its design.

- [x] Install [`pnpm`](https://pnpm.io/installation) or [`yarn`](https://classic.yarnpkg.com/lang/en/docs/install/#mac-stable) to use as the package manager.

</TabItem>
</Tabs>


:::tip Additional resources

- [Sui TypeScript SDK](https://sdk.mystenlabs.com/typescript) for basic usage on how to interact with Sui using TypeScript.
- [Sui dApp Kit](https://sdk.mystenlabs.com/dapp-kit) to learn basic building blocks for developing a dApp in the Sui ecosystem with React.js.
- [`@mysten/dapp`](https://sdk.mystenlabs.com/dapp-kit/create-dapp), used within this project to quickly scaffold a React-based Sui dApp.

:::

### Overview

The UI of this example demonstrates how to use the dApp Kit instead of serving as a production-grade product, so the Player and the House features are in the same UI to simplify the process. In a production solution, your frontend would only contain functionality dedicated to the Player, with a backend service carrying out the interactions with House functions in the smart contracts.

The UI has two columns:

- First column is dedicated to the Player, and all Player-related features live there
- Second column is dedicated to the House, and all House-related features live there

### Scaffold a new app

The first step is to set up the client app. Run the following command to scaffold a new app.

```sh
$ pnpm create @mysten/dapp --template react-client-dapp
```

or

```sh
$ yarn create @mysten/dapp --template react-client-dapp
```

### Project folder structure

Structure the project folder according to the UI layout, meaning that all Player-related React components reside in the `containers/Player` folder, while all House-related React components reside in the `containers/House` folder.

### Connecting your deployed package {#connecting-your-package}

Add the `packageId` value you saved from [deploying your package](#deployment) to a new `src/constants.ts` file in your project:

```ts
export const PACKAGE_ID =
  "0x4120b39e5d94845aa539d4b830743a7433fd8511bdcf3841f98080080f327ca8";
export const HOUSECAP_ID =
  "0xfa1f6edad697afca055749fedbdee420b6cdba3edc2f7fd4927ed42f98a7e63a";
```

### Exploring the code

The UI interacts with the [Single Player smart contract](guides/developer/app-examples/coin-flip.mdx#game-module) variant of the game. This section walks you through each step in the smart contract flow and the corresponding frontend code.

:::info

The following frontend code snippets include only the most relevant sections. Refer to the [Satoshi Coin Flip repository](https://github.com/MystenLabs/satoshi-coin-flip) (see the `app/` directory) for complete source code.

:::

The application uses React Router for navigation. The main layout is defined in `Root.tsx`:

```typescript title='routes/Root.tsx'
import { Outlet } from 'react-router-dom';
import { Toaster } from 'react-hot-toast';
import { Header } from '../components/Header/Header';
import { Footer } from '../components/Footer';
import { BalanceProvider } from '../contexts/Balance/BalanceProvider';
import { BackgroundElements } from '../components/General/BackgroundElements';

export default function Root() {
    return (
        <BalanceProvider>
            <Toaster position="bottom-center" />
            <div className="sticky top-0 z-50 flex w-full items-center justify-evenly bg-white px-5 py-3">
                <span className="text-[14px] text-[#4F4F4F] text-opacity-90">
                    [Satoshi Coin Flip] is provided for testnet purposes only and does not involve
                    real money or the opportunity to win real money.
                </span>
            </div>
            <Header />
            <main className="relative flex flex-[1] flex-col">
                <BackgroundElements />
                <div className="z-[1] flex flex-[1] flex-col items-center justify-center">
                    <Outlet />
                    <Footer />
                </div>
            </main>
        </BalanceProvider>
    );
}
```

The main application is initialized in `main.tsx` with Sui wallet providers and Enoki integration:

```typescript title='main.tsx'
import { QueryClientProvider, QueryClient } from '@tanstack/react-query';
import { SuiClientProvider, WalletProvider } from '@mysten/dapp-kit';
import { getFullnodeUrl } from '@mysten/sui/client';
import { namedPackagesPlugin, Transaction } from '@mysten/sui/transactions';
import { RouterProvider } from 'react-router-dom';
import { RegisterEnokiWallets } from './components/RegisterEnokiWallets';

// Register MVR plugin globally
const network = 'testnet';
const mvrPlugin = namedPackagesPlugin({
  url: `https://${network}.mvr.mystenlabs.com`,
  overrides: getMvrCache(network),
});
Transaction.registerGlobalSerializationPlugin('namedPackagesPlugin', mvrPlugin);

const queryClient = new QueryClient();

ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <SuiClientProvider
        networks={{
          testnet: { url: getFullnodeUrl('testnet') },
          mainnet: { url: getFullnodeUrl('mainnet') },
        }}
        defaultNetwork="testnet"
      >
        <WalletProvider autoConnect>
          <RegisterEnokiWallets />
          <RouterProvider router={router} />
        </WalletProvider>
      </SuiClientProvider>
    </QueryClientProvider>
  </React.StrictMode>,
);
```

Like other dApps, you need a "connect wallet" button to enable connecting users' wallets. The `Header` component includes wallet connection UI, balance display, and address information.

The home page renders the main game interface through the `CurrentGame` component:

```typescript title='pages/HomePage.tsx'
import { CurrentGame } from '../components/CurrentGame/CurrentGame';

const HomePage = () => {
    return (
        <CurrentGame />
    );
};

export default HomePage;
```

### Key differences from version 1

Source code locations for the V1 smart contracts and frontend:
- [Move package repository](https://github.com/MystenLabs/satoshi-coin-flip/tree/v1)
- [Frontend repository](https://github.com/sui-foundation/satoshi-coin-flip-frontend-example)

The frontend implementation has been significantly simplified compared to version 1:

**No Counter NFT required**: Version 1 required players to mint a `Counter` NFT for VRF input. Version 2 eliminates this entirely since randomness is handled on-chain using Sui's native randomness.

**Simplified game flow**: Creating and finishing a game now requires fewer transactions:
- **Start game**: Single transaction with player's guess and stake
- **Finish game**: Single transaction that generates randomness and distributes funds - no BLS signatures or VRF input required

**Gas sponsorship**: With Enoki integration, players can enjoy gas-free transactions. The frontend uses serverless API routes (`/api/sponsor/prepare` and `/api/sponsor/execute`) to handle sponsorship:

```typescript title='hooks/useSui.ts'
const enokiSponsorExecute = async ({
  transactionBlock,
}: {
  transactionBlock: Transaction;
}) => {
  if (!address) {
    throw new Error('No address found');
  }

  transactionBlock.setSender(address);
  const txBytes = await transactionBlock.build({ client, onlyTransactionKind: true });

  // Create sponsored transaction via Enoki endpoint
  const createSponsoredTransactionResp = await axios.post('/api/sponsor/prepare', {
    transactionKindBytes: toBase64(txBytes),
    sender: address,
  });
  const { bytes, digest } = createSponsoredTransactionResp.data;

  // Sign the sponsored transaction
  const { signature } = await signTransaction({
    transaction: bytes,
  });

  // Execute the sponsored transaction
  const executeSponsoredTransactionResp = await axios.post('/api/sponsor/execute', {
    digest,
    signature,
  });

  const { digest: txDigest } = executeSponsoredTransactionResp.data;
  await client.waitForTransaction({ digest: txDigest, timeout: 10_000 });
  return { digest: txDigest };
};
```

**Type-safe bindings**: Auto-generated TypeScript bindings from `@mysten/codegen` ensure type safety and provide autocomplete:

```typescript title='__generated__/satoshi_flip/single_player_satoshi.ts'
import { startGame, finishGame } from '../__generated__/satoshi_flip/single_player_satoshi';

// Type-safe Move call with auto-complete
startGame({
  package: PACKAGE_ID,
  arguments: {
    guess: 'H', // TypeScript knows this should be 'H' or 'T'
    coin: coinWithBalance({ balance: Number(GAME_BALANCE), useGasCoin: false })(tx),
    houseData: tx.object(HOUSE_DATA)
  }
})(tx);
```

### Core game logic

The main game logic is handled in the `useGame` hook. Let's examine how games are created and finished:

#### Starting a new game

```typescript title='hooks/useGame.ts'
const handleNewGame = async (choice: CoinSide) => {
  const tx = new Transaction();

  if (balance < +GAME_BALANCE / Number(MIST_PER_SUI)) {
    throw new Error('Low Balance');
  }

  // Use coinWithBalance utility to handle coin merging/splitting automatically
  const coin = coinWithBalance({
    balance: Number(GAME_BALANCE),
    useGasCoin: false // Important for Enoki sponsorship
  })(tx);

  startGame({
    package: PACKAGE_ID,
    arguments: {
      guess: choice === 'head' ? 'H' : 'T',
      coin,
      houseData: tx.object(HOUSE_DATA),
    },
  })(tx);

  const executionRes = await enokiSponsorExecute({ transactionBlock: tx });
  return client
    .getTransactionBlock({
      digest: executionRes.digest,
      options: {
        showEffects: true,
        showEvents: true,
      },
    })
    .then((resp) => {
      if (resp.effects?.status.status === 'success') {
        const events = resp.events;
        const createdGame = events?.find((o) => o.type.includes('::NewGame'))
          ?.parsedJson as {
          fee_bp: number;
          game_id: string;
          guess: string;
          player: string;
          user_stake: string;
        };
        const gameObjectId = createdGame.game_id;
        if (gameObjectId) {
          setCurrentGameId(gameObjectId);
          reFetchData();
          setCreateGameLoading(false);
          return playGame(gameObjectId);
        }
      }
    });
};
```

Key points about starting a game:

1. **No Counter NFT required**: Unlike version 1, no NFT minting is necessary
2. **coinWithBalance utility**: Automatically handles coin merging and splitting - no need for manual `splitCoins` calls
3. **Type-safe generated bindings**: The `startGame` function comes from auto-generated code and provides type safety
4. **Enoki sponsorship**: Uses `enokiSponsorExecute` for gas-free transactions
5. **Event parsing**: Retrieves the `game_id` from the emitted `NewGame` event to use for finishing the game

#### Finishing a game

```typescript title='hooks/useGame.ts'
const playGame = async (gameObjectId: string) => {
  if (!currentAccount?.address) {
    throw new Error('No wallet connected');
  }

  const tx = new Transaction();
  finishGame({
    package: PACKAGE_ID,
    arguments: {
      gameId: tx.object(gameObjectId),
      houseData: tx.object(HOUSE_DATA),
    },
  })(tx);

  try {
    const executionRes = await enokiSponsorExecute({ transactionBlock: tx });
    const result = await client.getTransactionBlock({
      digest: executionRes.digest,
      options: {
        showEffects: true,
        showEvents: true,
      },
    });

    if (result.effects?.status.status === 'success') {
      const events = result.events;
      const outcomeEvent = events?.find((event) =>
        event.type.includes('::Outcome')
      )?.parsedJson as { game_id: string; status: number };

      const playerWon = outcomeEvent?.status === 1;
      setGameResult(playerWon ? 'win' : 'loss');
      setTxnDigest(result.digest);
      reFetchData(); // Refresh balance after game completion
      refetchHistory(); // Refresh game history
      setIsLoading(false);
    }
  } catch (err) {
    console.log('Error finishing game:', err);
    toast.error('Something went wrong, game could not be finished.');
    setIsLoading(false);
  }
};
```

Key differences from version 1:

1. **No BLS signatures**: Version 1 required the house to sign VRF input with BLS private keys. Version 2 uses Sui's native randomness - no signatures needed
2. **No event subscriptions**: Instead of subscribing to events and automatically finishing games in the background, the UI directly calls `finishGame` after creating a game
3. **Simpler Move call**: Only requires `gameId` and `houseData` - no signed input or random object
4. **Anyone can finish**: Because randomness is handled on-chain, any user can finish any game - not just the house

The `Outcome` event contains the game result, which the frontend uses to display win/loss status to the player.

### Configuration management

The application uses environment variables for configuration:

```typescript title='hooks/useConfig.ts'
export const useConfig = ({ log = false }: useConfigProps) => {
  const ConfigSchema = z.object({
    VITE_SUI_NETWORK: z.string(),
    VITE_PACKAGE_ID: z.string(),
    VITE_HOUSE_DATA: z.string(),
    VITE_BACKEND_API: z.string(),
    VITE_ENOKI_API_KEY: z.string(),
  });

  const config = ConfigSchema.parse(import.meta.env);

  return {
    FULL_NODE: config.VITE_SUI_NETWORK,
    COIN_TYPE: '0x2::sui::SUI',
    GAME_BALANCE: '500000000', // 0.5 SUI
    PACKAGE_ID: config.VITE_PACKAGE_ID,
    HOUSE_DATA: config.VITE_HOUSE_DATA,
    API_BASE_URL: config.VITE_BACKEND_API,
    ENOKI_API_KEY: config.VITE_ENOKI_API_KEY,
  };
};
```

This centralized configuration ensures type safety with Zod validation and makes it easy to deploy to different networks.

Congratulations! You've explored the modern Satoshi Coin Flip implementation. You can carry these patterns forward when building your next Sui dApp with:
- Type-safe generated bindings from `@mysten/codegen`
- Gas-free transactions via Enoki sponsorship
- Sui's native randomness for trustless games
- Modern dApp Kit patterns for wallet integration
