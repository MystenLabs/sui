---
title: Trustless Swap - Backend
sidebar_label: Backend
---

# Part 2: Backend

:::note Multi-Page Guide

This is the second in a [three-part guide](./intro.mdx) on how to build an app for trustless atomic swaps on Sui.

:::

## Indexing

With the contract adapted to emit events, we can now write an indexer that keeps track of all active `Escrow` objects and exposes an API for querying objects by sender or recipient. The indexer will be backed by a Prisma DB with the following schema:

```ts
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

/// Our swap objects list
model Escrow {
  // Keeping an ID so we can use as a pagination cursor
  // There's an issue with BigInt for sqlite, so we're using a plain ID.
  id Int @id @default(autoincrement())
  objectId String @unique
  sender String?
  recipient String?
  keyId String?
  itemId String?
  swapped Boolean @default(false)
  cancelled Boolean @default(false)

  @@index([recipient])
  @@index([sender])
}

/// Saves the latest cursor for a given key.
model Cursor {
  id String @id
  eventSeq String
  txDigest String
}
```

The core of the indexer is an event loop, initialised in a function called `setupListeners`.

```ts
// indexer.ts
import { setupListeners } from './indexer/event-indexer';

setupListeners();
```

The indexer queries events related to the `escrow` module, using a `queryEvent` filter, and keeps track of a cursor representing the latest event it has processed so it can resume indexing from the right place even if it is restarted. The filter is looking for any events whose type is from the `escrow` module of our Move package:

```ts
// indexer/event-indexer.ts
import { SuiEventFilter, SuiEvent } from  '@mysten/sui.js/client';
import { CONFIG } from '../config';
import { prisma } from '../db';
import { getClient } from '../sui-utils';
import { handleEscrowObjects } from './escrow-handler';

type EventTracker = {
  type: string;
  filter: SuiEventFilter;
  callback: (events: SuiEvent[], type: string) => any;
};

const EVENTS_TO_TRACK: EventTracker[] = [
  {
    type: `${CONFIG.SWAP_CONTRACT.packageId}::escrow`,
    filter: {
      MoveEventModule: {
        module: 'escrow',
        package: CONFIG.SWAP_CONTRACT.packageId,
      },
    },
    callback: handleEscrowObjects,
  },
];

const getLatestCursor = async (tracker: EventTracker) => {
  const cursor = await prisma.cursor.findUnique({
    where: {
      id: tracker.type,
    },
  });

  return cursor || undefined;
};

export const setupListeners = async () => {
  for (const event of EVENTS_TO_TRACK) {
    runEventJob(getClient(CONFIG.NETWORK), event, await getLatestCursor(event));
  }
};
```

The core event job works by polling: It queries RPC for events following its latest cursor and sends them to a callback for processing. If it detects more than one page of new events, it will make an immediate subsequent request for the next page, otherwise it waits for the next polling interval before checking again:

```ts
// indexer/event-indexer.ts
import { EventId, SuiClient } from '@mysten/sui.js/client';

type SuiEventsCursor = EventId | null | undefined;

const executeEventJob = async (
  client: SuiClient,
  tracker: EventTracker,
  cursor: SuiEventsCursor,
): Promise<EventExecutionResult> => {
  try {
    // get the events from the chain.
    // For this implementation, we are going from start to finish.
    // This will also allow filling in a database from scratch!
    const { data, hasNextPage, nextCursor } = await client.queryEvents({
      query: tracker.filter,
      cursor,
      order: 'ascending',
    });

    // handle the data transformations defined for each event
    await tracker.callback(data, tracker.type);

    // We only update the cursor if we fetched extra data (which means there was a change).
    if (nextCursor && data.length > 0) {
      await saveLatestCursor(tracker, nextCursor);

      return {
        cursor: nextCursor,
        hasNextPage,
      };
    }
  } catch (e) {
    console.error(e);
  }
  // By default, we return the same cursor as passed in.
  return {
    cursor,
    hasNextPage: false,
  };
};

const runEventJob = async (client: SuiClient, tracker: EventTracker, cursor: SuiEventsCursor) => {
  const result = await executeEventJob(client, tracker, cursor);

  // Trigger a timeout. Depending on the result, we either wait 0ms or the polling interval.
  setTimeout(
    () => {
      runEventJob(client, tracker, result.cursor);
    },
    result.hasNextPage ? 0 : CONFIG.POLLING_INTERVAL_MS,
  );
};
```

The callback that gets called is responsible for reading the event and updating the database accordingly. For demo purposes, because we are using sqlite, we need to issue a separate `UPSERT` to the database for each escrowed object, but in a production setting, requests to the database should be batched to minimise round-trips to the database.

```ts
// indexer/escrow-handler.ts
import { SuiEvent } from '@mysten/sui.js/client';
import { Prisma } from '@prisma/client';

import { prisma } from '../db';

type EscrowEvent = EscrowCreated | EscrowCancelled | EscrowSwapped;

type EscrowCreated = {
  sender: string;
  recipient: string;
  escrow_id: string;
  key_id: string;
  item_id: string;
};

type EscrowSwapped = {
  escrow_id: string;
};

type EscrowCancelled = {
  escrow_id: string;
};

export const handleEscrowObjects = async (events: SuiEvent[], type: string) => {
  const updates: Record<string, Prisma.EscrowCreateInput> = {};

  for (const event of events) {
    if (!event.type.startsWith(type)) throw new Error('Invalid event module origin');
    const data = event.parsedJson as EscrowEvent;

    if (!Object.hasOwn(updates, data.escrow_id)) {
      updates[data.escrow_id] = {
        objectId: data.escrow_id,
      };
    }

    // Escrow cancellation case
    if (event.type.endsWith('::EscrowCancelled')) {
      const data = event.parsedJson as EscrowCancelled;
      updates[data.escrow_id].cancelled = true;
      continue;
    }

    // Escrow swap case
    if (event.type.endsWith('::EscrowSwapped')) {
      const data = event.parsedJson as EscrowSwapped;
      updates[data.escrow_id].swapped = true;
      continue;
    }

    const creationData = event.parsedJson as EscrowCreated;

    // Handle creation event
    updates[data.escrow_id].sender = creationData.sender;
    updates[data.escrow_id].recipient = creationData.recipient;
    updates[data.escrow_id].keyId = creationData.key_id;
    updates[data.escrow_id].itemId = creationData.item_id;
  }

  const promises = Object.values(updates).map((update) =>
    prisma.escrow.upsert({
      where: {
        objectId: update.objectId,
      },
      create: update,
      update,
    }),
  );
  await Promise.all(promises);
};
```

:::info Additional Resources

- [Full source code](https://github.com/MystenLabs/sui/tree/705ee1ed3ce8cfadc4597c6facb6769d7dfb5896/examples/trading/api)
- Reference: [JSON-RPC](https://docs.sui.io/sui-api-ref)

:::


## API service

The data that is captured by our indexer can then be served over an API, so that a front-end can read it. We will implement our API in TypeScript, to run on Node, using Express.

### API design

#### Query parameters

You want your API to accept the query string in the URL as the parameters for database `WHERE` query. Hence, you want a utility that can extract and parse the URL query string into valid query parameters for Prisma. With the `parseWhereStatement()` function, the callers filter the set of keys from the URL query string and transforms those corresponding key-value pairs into the correct format for Prisma.

```ts title='utils/api-queries.ts'
export enum WhereParamTypes {
	STRING,
	NUMBER,
	BOOLEAN,
}

export type WhereParam = {
	key: string;
	type: WhereParamTypes;
};

/** Parses a where statement based on the query params. */
export const parseWhereStatement = (query: Record<string, any>, acceptedParams: WhereParam[]) => {
	const params: Record<string, any> = {};
	for (const key of Object.keys(query)) {
		const whereParam = acceptedParams.find((x) => x.key === key);
		if (!whereParam) continue;

		const value = query[key];
		if (whereParam.type === WhereParamTypes.STRING) {
			params[key] = value;
		}
		if (whereParam.type === WhereParamTypes.NUMBER) {
			const number = Number(value);
			if (isNaN(number)) throw new Error(`Invalid number for ${key}`);

			params[key] = number;
		}

		// Handle boolean expected values.
		if (whereParam.type === WhereParamTypes.BOOLEAN) {
			let boolValue;
			if (value === 'true') boolValue = true;
			else if (value === 'false') boolValue = false;
			else throw new Error(`Invalid boolean for ${key}`);

			params[key] = boolValue;
		}
	}
	return params;
};
```

#### Query pagination

Pagination is another crucial part to ensure your API returns sufficient and/or ordered chunk of information instead of all the data that might be the vector for a DDOS attack. Similar to **WHERE parameters**, define a set of keys in the URL query string to be accepted as valid pagination parameters. The `parsePaginationForQuery()` utility function helps to achieve this by filtering the pre-determined keys `sort`, `limit`, `cursor` and parsing corresponding key-value pairs into `ApiPagination` that Prisma can consume.

In this example, the `id` field of the model in the database as the cursor that allows clients to continue subsequent queries with the next page.

```ts title='utils/api-queries.ts'
export type ApiPagination = {
	take?: number;
	orderBy: {
		id: 'asc' | 'desc';
	};
	cursor?: {
		id: number;
	};
	skip?: number;
};

/**
 * A helper to prepare pagination based on `req.query`.
 * Only primary key cursor + ordering for this example.
 */
export const parsePaginationForQuery = (body: Record<string, any>) => {
	const pagination: ApiPagination = {
		orderBy: {
			id: Object.hasOwn(body, 'sort') && ['asc', 'desc'].includes(body.sort) ? body.sort : 'desc',
		},
	};

	// Prepare pagination limit (how many items to return)
	if (Object.hasOwn(body, 'limit')) {
		const requestLimit = Number(body.limit);

		if (isNaN(requestLimit)) throw new Error('Invalid limit value');

		pagination.take = requestLimit > CONFIG.DEFAULT_LIMIT ? CONFIG.DEFAULT_LIMIT : requestLimit;
	} else {
		pagination.take = CONFIG.DEFAULT_LIMIT;
	}

	// Prepare cursor pagination (which page to return)
	if (Object.hasOwn(body, 'cursor')) {
		const cursor = Number(body.cursor);
		if (isNaN(cursor)) throw new Error('Invalid cursor');
		pagination.skip = 1;
		pagination.cursor = {
			id: cursor,
		};
	}

	return pagination;
};
```

### API endpoints

All the endpoints are defined in `server.ts`, particularly, there are two endpoints:

- `/locked` to query `Locked` objects.
- `/escrows` to query `Escrow` objects.

The implementation for both endpoints is pretty straightforward. You define a list of valid query keys, such as `deleted`, `creator`, `keyId`, and `objectId` for `Locked` data and `cancelled`, `swapped`, `recipient`, and `sender` for `Escrow` data. Pass the URL query string into the pre-defined utilities to output the correct parameters that Prisma can use.

```ts title='server.ts'
import { prisma } from './db';
import {
	formatPaginatedResponse,
	parsePaginationForQuery,
	parseWhereStatement,
	WhereParam,
	WhereParamTypes,
} from './utils/api-queries';

app.get('/locked', async (req, res) => {
	const acceptedQueries: WhereParam[] = [
		{
			key: 'deleted',
			type: WhereParamTypes.BOOLEAN,
		},
		{
			key: 'creator',
			type: WhereParamTypes.STRING,
		},
		{
			key: 'keyId',
			type: WhereParamTypes.STRING,
		},
		{
			key: 'objectId',
			type: WhereParamTypes.STRING,
		},
	];

	try {
		const locked = await prisma.locked.findMany({
			where: parseWhereStatement(req.query, acceptedQueries)!,
			...parsePaginationForQuery(req.query),
		});

		return res.send(formatPaginatedResponse(locked));
	} catch (e) {
		console.error(e);
		return res.status(400).send(e);
	}
});

app.get('/escrows', async (req, res) => {
	const acceptedQueries: WhereParam[] = [
		{
			key: 'cancelled',
			type: WhereParamTypes.BOOLEAN,
		},
		{
			key: 'swapped',
			type: WhereParamTypes.BOOLEAN,
		},
		{
			key: 'recipient',
			type: WhereParamTypes.STRING,
		},
		{
			key: 'sender',
			type: WhereParamTypes.STRING,
		},
	];

	try {
		const escrows = await prisma.escrow.findMany({
			where: parseWhereStatement(req.query, acceptedQueries)!,
			...parsePaginationForQuery(req.query),
		});

		return res.send(formatPaginatedResponse(escrows));
	} catch (e) {
		console.error(e);
		return res.status(400).send(e);
	}
});
```

## Next steps

With the code successfully deployed on Testnet, you can now [create a frontend](./frontend.mdx) to display the trading data and to allow users to interact with the Move modules.
