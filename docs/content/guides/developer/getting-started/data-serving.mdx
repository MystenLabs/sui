---
title: Access Sui Data
description: Overview of the types of data access mechanisms available in Sui
---

You can access Sui network data like [Transactions](/concepts/transactions.mdx), [Checkpoints](/concepts/cryptography/system/checkpoint-verification.mdx), [Objects](/concepts/object-model.mdx), [Events](/guides/developer/sui-101/using-events.mdx) and more through the available interfaces, in order to use in your application workflows, or to analyze the network behavior across applications or protocols of interest, or to perform audits on parts or whole of the network.

This document outlines the interfaces that are currently available to access the Sui network data, along with a overview of how that's gradually evolving for a great deveoper experience.

## Current data access interfaces

You can use either of the following mechanisms to access Sui network data currently:

- Directly connect to [JSON-RPC](/references/sui-api.mdx) hosted by a Sui [full node](guides/operator/sui-full-node.mdx) where the [Mainnet](https://fullnode.mainnet.sui.io:443) or [Testnet](https://fullnode.testnet.sui.io:443) or [Devnet](https://fullnode.devnet.sui.io:443) load balancer URLs abstract a few globally distributed full nodes, OR
- Set up your own [custom indexer](/guides/developer/advanced/custom-indexer.mdx) to continuously load the data of interest in a Postgres database, OR 
- Utilize a [RPC provider](https://sui.io/developers#dev-tools) (filter by `RPC`) or [Data indexer operator](https://github.com/sui-foundation/awesome-sui?tab=readme-ov-file#indexers--data-services) who have setup their own full nodes or indexing infrastructure.

:::info

You can use one of the [future-oriented interfaces]((#future-state-data-interfaces)) that are available in alpha or beta, but you must validate the relevant functionality, performance, and cost characteristics for your application before deciding to use those in production.

:::

### JSON-RPC

You can currently get real-time or historical data from a Sui full node. Retention period for historical data depends on the [pruning strategy](/guides/operator/data-management.mdx#sui-full-node-pruning-policies) implemented by a node operator, though currently all full nodes are by default configured to implicitly fall back on a [Mysten Labs managed key-value store for historical transaction data](/guides/operator/data-management.mdx#sui-full-node-key-value-store-backup).

:::caution

Websockets based JSON RPCs `suix_subscribeEvent` and `suix_subscribeTransaction` were deprecated in July 2024. You should not rely on those RPCs in your applications. Refer to [this section](#future-state-data-interfaces) to learn about a future alternative.

:::

### Custom indexer

If you need object version history or another type of historical data where you may not fully rely on a full node or RPC provider, or if you've specific query patterns that could be best served from a relational database, then you can setup your own [custom indexer](/guides/developer/advanced/custom-indexer.mdx) or reach out to a [Data indexer operator](https://github.com/sui-foundation/awesome-sui?tab=readme-ov-file#indexers--data-services) who may already have setup one. 

If you setup your own indexer, you are responsible for its ongoing maintenance and the related infrastructure & operational costs. You can reduce your costs by implementing a pruning strategy for the relational database by taking into account the retention needs of your application.

## Future data access interfaces

Primary interfaces to access Sui access data in future will be:

- Full node gRPC API will replace JSON-RPC on full nodes, and is currently available in alpha. If you already use the JSON-RPC or are starting to utilize it as a dependency for your use case, you would need to migrate to gRPC or GraphQL (see below) within a reasonable duration. Related migration timeline will be defined once the newer options are generally available (GA).
- [GraphQL RPC with Indexer 2.0](/references/sui-graphql.mdx) will replace the custom indexer mechanism and is currently available in beta. This will be a combination of a performant indexing mechanism that one could use to load and manage data in a postgres relational database, and a lightweight GraphQL RPC server that will be used to read data from that database.

You would still be able to utilize a [RPC provider](https://sui.io/developers#dev-tools) (filter by `RPC`) or a [Data indexer operator](https://github.com/sui-foundation/awesome-sui?tab=readme-ov-file#indexers--data-services) with the above options.

### gRPC API

As mentioned above, gRPC API will replace the JSON-RPC on full nodes, such that JSON-RPC will be deprecated when gRPC API is generally available. Apart from the message & request format changes between the two, the gRPC API will come with a couple of key functional differences:

- It will have streaming or subscription API endpoints such that you could consume real-time streaming data in your application without having to poll for those records. This support will be a proper replacement of the deprecated Webdockets support in JSON-RPC.
- It will not have a implicit fallback on the above mentioned [Mysten Labs managed key-value store for historical transaction data](/guides/operator/data-management.mdx#sui-full-node-key-value-store-backup). You would have an option to configure that dependency explicitly though, while other full-node operators or RPC providers will also be encouraged to run that key-value store.

:::info

The gRPC API is in alpha and not recommended for production use. Its public documentation is coming soon. Until then, you can refer to [this technical proto spec](https://github.com/MystenLabs/sui/blob/main/crates/sui-rpc-api/proto/sui.node.v2.proto).

:::

See below for a comparison with GraphQL RPC with Indexer 2.0.

### GraphQL RPC with Indexer 2.0

As mentioned above, [GraphQL RPC with Indexer 2.0](/references/sui-graphql.mdx) will replace the custom indexer mechanism, and over time will become a major option to get access to the Sui network data. Internally the indexer 2.0 framework will use the full node RPCs to ingest the data, initially using the currently generally available JSON-RPC, and later using the above mentioned gRPC API. 

GraphQL has been a key ask from many application builders, and the overall combination will come with following capabilities:

- Indexer 2.0 will be a declarative framework that you would be able to configure to load different kinds of network data into postgres relational tables in parallel. This change is being implemented to improve the performance of the data ingestion into the postgres database. 
  - In addition, you would be able to configure pruning for different tables in the postgres tables, allowing you to tune it for the desired combination of performance and cost characteristics.
- GraphQL Server will be a lightweight server component that you would be able to use to access the data from different tables in the postgres database. This component will allow for combination of expressive queries due to the inherent nature of GraphQL, which is appealing to the frontend developers.

:::info

GraphQL with Indexer 2.0 is in beta and its recommended that you thoroughly investigate its functional, performance and cost properties before using it in production. Check out [this getting started document](guides/developer/getting-started/graphql-rpc.mdx) that refers to Mysten Labs managed relevant infrastructure.

A sneak preview of how Indexer 2.0 could be setup is available [here](https://github.com/amnn/sui-sender-indexer).

:::

See below for a comparison with the gRPC API.

### When to use gRPC vs GraphQL with Indexer 2.0

You can use the high-level criteria mentioned in the following table to determine whether gRPC API or GraphQL RPC with Indexer 2.0 would better serve your use case. It's not an exhaustive list and it's expected that either of the options could work suitably for some of the use cases.

| **Dimension** | **gRPC API** | **GraphQL RPC with Indexer 2.0** |
 -------- | ------- | ------- |
| Type of application or data consumer | Ideal for Web3 exchanges, defi market maker apps, other defi protocols or apps with ultra low-latency needs | Ideal for webapp builders or builders with slightly relaxed latency needs |
| Query patterns | Okay to read data from different endpoints separately and combine on the client-side; faster serialization, parsing and validation due to binary format | Need easier docoupling of the client with the ability to combine different types of data in fewer calls |
| Retention period requirements | Default retention period will be 2 weeks with actual configuration dependent on the full node operator and their needs & goals; see history-related note after the table | Default retention period in postgres database will be 4 weeks with actual configuration depending on your or the data indexer operator's needs; see history-related note after the table |
| Streaming needs | Will include a streaming or subscription API before beta release | Subscription API is planned but will be available after GA |
| Incremental costs | Little to no incremental costs if already using full-node JSON-RPC | Somewhat significant incremental costs if already using full-node JSON-RPC and if retention period & query patterns differences are insignificant |

:::note

Above table only mention the default retention period for both options. The expectation is that it should be reasonable for you or a full node / data indexer operator to configure that to a few times higher without impacting the performance significantly, but relevant guidelines will be shared before each option's respective GA release. Those will include recommendations for how to access historical data beyond the configured retention period.

:::

Feel free to refer to the following articles outlining general differences between gRPC and GraphQL. Please validate the accuracy and authenticity of the differences using your own experiments.

- https://stackoverflow.blog/2022/11/28/when-to-use-grpc-vs-graphql/
- https://blog.postman.com/grpc-vs-graphql/