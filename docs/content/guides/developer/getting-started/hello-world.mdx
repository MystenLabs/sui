---
title: Hello, World!
description: 
keywords: [  ]
---

The basic unit of storage on Sui is an [**object**](/concepts/object-model.mdx). On other blockchains, storage is typically structured using key-value stores. On Sui, storage is centered around objects addressable on-chain by unique IDs. Every Sui smart contract is an object that is used to manipulate other objects on the network.

Objects can be immutable or mutable. Immutable objects cannot be transferred, changed, or deleted. Immutable objects are not owned by anyone and can be accessed by anyone on the network. Mutable objects can be transferred, changed, and deleted. They can be owned by a Sui address or shared to be made accessible to anyone on the network. 

Every object stored on-chain is referenced via its unique ID and a version number. Every transaction on the network takes objects as input, then reads, writes, and mutates the inputs to produce new or altered objects as output. Every object knows the hash of the transaction that produced it. 

When an object is modified by a transaction, the transaction's output writes the object's mutated contents to the same object ID but with a new version number. 

Sui has limits on the maximum transaction size (128KB) and number of objects (2,048) used in a transaction. For more information on limits, see [Building against Limits in The Move Book](https://move-book.com/guides/building-against-limits/).

## What is Move? 

[Move](/concepts/sui-move-concepts.mdx) a the programming language used on Sui to create smart contracts. It is platform agnostic and enables common libraries, tooling, and developer communities across blockchains with vastly different data and execution models. There are three ways to use Move in the context of Sui: Move packages, Move modules, and Move objects.

A Sui **Move package** is also referred to as a Move smart contract. It is a set of Move bytecode that has been published to the Sui network. It is immutable and cannot be changed or removed, however it can be upgraded. Upgrading creates a new version of the package object on-chain, leaving the original intact. All prior versions of a package still exist on-chain. Once published, other packages can import and use the modules it provides. Anyone can view a package's contents and use a Sui Explorer to see how its logic manipulates other objects. 

Every Move package on Sui includes one or more **Sui Move modules** that define the package's interaction with on-chain objects. Each module's name is the combination of the package's on-chain ID and the name of a module. A module's name is always unique within the package that contains it.

A Sui **Move object** is typed data governed by a Sui Move module from a Sui Move package. Each object value is a struct with fields that can contain primitive types, such as integers and addresses, other objects, and non-object structs.

<Tabs className="tabsHeadingCentered--small">
<TabItem value="prereq" label="Prerequisites">

- [x] [Install the latest version of Sui](/guides/developer/getting-started/sui-install.mdx).

- [x] [Configure the Sui client](/guides/developer/getting-started/configure-sui-client.mdx).

- [x] [Create a Sui address](/guides/developer/getting-started/get-address.mdx).

- [x] Download and install an IDE. The following are recommended, as they offer Move extensions:

    - [VSCode] (https://code.visualstudio.com/), corresponding [Move extension](https://marketplace.visualstudio.com/items?itemName=mysten.move)

    - [Emacs](https://www.gnu.org/software/emacs/), corresponding [Move extension](https://github.com/amnn/move-mode)

    - [Vim](https://www.vim.org/download.php), corresponding [Move extension](https://github.com/yanganto/move.vim)

    - [Zed](https://zed.dev/), corresponding [Move extension](https://github.com/Tzal3x/move-zed-extension)
    
    Alternatively, you can use the [Move web IDE](https://www.playmove.dev/), which does not require a download, however it does not support all functions necessary for this guide.

- [x] [Download and install Git](https://git-scm.com/downloads).

</TabItem>
</Tabs>

## Clone "Hello, world!""

To demonstrate objects, packages, and how to build your first Sui application, start by cloning the "Hello, world!"" example:

```
$ git clone https://github.com/MystenLabs/sui-stack-hello-world.git hello-world
$ cd hello-world
```

In this project, there are two important files that define the package's logic, information, and its dependencies:

- `move/hello-world/sources/greeting.move`: Defines a basic shared greeting object that can be used by any address to create, share, or update the object's text. 

- `move/hello-world/Move.toml`: The package's configuration file that defines the package name, dependencies, and addresses.

<details>

<summary> </summary>

```toml
[package]
name = "hello_world"
version = "0.0.1"
edition = "2024.beta"

[dependencies]
Sui = { git = "https://github.com/MystenLabs/sui.git", subdir = "crates/sui-framework/packages/sui-framework", rev = "framework/testnet" }

[addresses]
hello_world = "0x0"
```

</details>

### Viewing the smart contract code 

Open the `greeting.move` file in your IDE of choice. You will see the following Move code:

```move
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

/// This example demonstrates a basic use of a shared greeting.
/// Rules:
/// - anyone can create and share a Greeting object
/// - everyone can update the text of the Greeting object
module hello_world::greeting {
  use std::string;

  /// A shared greeting
  public struct Greeting has key {
    id: UID,
    text: string::String,
  }
 
  /// API call that creates a globally shared Greeting object initialized with "Hello world!"
  public fun new(ctx: &mut TxContext) { 
    let new_greeting = Greeting { 
      id: object::new(ctx),
      text: b"Hello world!".to_string()
    };
    transfer::share_object(new_greeting);
  }

  /// API call that updates text of Greeting object
  public fun update_text(greeting: &mut Greeting, new_text: string::String) {
    greeting.text = new_text;
  }
}
```

First, this code defines a module called `hello_world` that takes input of `greeting`:

```move 
module hello_world::greeting {
  use std::string;
  ...
}
```

Then, it defines a public struct called `Greeting` that contains a unique object ID and text:

```move 
  public struct Greeting has key {
    id: UID,
    text: string::String,
  }
```

Then, it defines the function `new` that makes an API call to the `Greeting` struct and initializes it with the text `"Hello world!"`, storing it in a new shared object:

```move 
  public fun new(ctx: &mut TxContext) { 
    let new_greeting = Greeting { 
      id: object::new(ctx),
      text: b"Hello world!".to_string()
    };
    transfer::share_object(new_greeting);
  }
```

Lastly, the package defines a function called `update_text` that can be called to update the text stored in `Greeting`:

```move
  public fun update_text(greeting: &mut Greeting, new_text: string::String) {
    greeting.text = new_text;
  }
```

### Resource safety 

A unique aspect of programming applications on Sui is the built-in resource safety. Move packages must satisfy the following resource safety parameters:

- All resources must be either moved into global storage or destroyed by the end of a transaction. 

- Resources cannot be copied. 

In the "Hello, world!" example, the struct `Greeting` is a resource type, as it has a `key` definition. `Greeting` is not copied within the module, as that is not allowed.

To satisfy the requirement that all resources must be moved or destroyed by the end of a transaction `Greeting` is assigned to `new_greeting`, which is then moved into global storage through the call to `transfer::share_object(new_greeting)`.

To mutate `Greeting`, the function `update_text` takes the input `(&mut Greeting)` rather than the resource itself. Resource safety is satisfied in this function, as the resource is not copied and is mutated via a reference. 

If you edited this code where `Greeting` did not move into storage, was not destroyed, or it was copied, the verifier would throw an error.

[Learn more about the Move Bytecode Verifier](https://github.com/MystenLabs/sui/blob/main/external-crates/move/move-execution/v1/crates/move-bytecode-verifier/README.md)

#### How does this differ from EVM applications?

The Ethereum Virtual Machine adopts a gas based resource safety strategy. Every opcode on an EVM chain has an associated gas price that makes transactions costly, preventing the network from running a single transaction indefinitely. 

## Build the Move package 

Move source files (.move) are human-readable, but the blockchain only understands bytecode.
Building translates your code into bytecode that the Sui VM can execute.


The build process fetches and compiles any dependencies your package needs (such as the Sui framework or other Move packages).

The compiler checks your code for syntax errors, type errors, and enforces important safety rules (like resource safety).
This helps catch mistakes before you try to publish or test your code.

Only after building can you run unit tests (sui move test) or publish your package to the blockchain.

sui move build


- Build package
    - Why do you need to build it
    - What happens when you build it

## Deploy the Move package 

1. Your Compiled Code Is Uploaded to the Blockchain
The bytecode for all modules in your package is sent to the Sui network.
The blockchain stores this code at a unique address called the PackageID.

2. A Package Object Is Created
Sui creates a new package object that represents your deployed code.
This object is immutable and can be referenced by other contracts or users.


3. Special Capability Objects May Be Created
For upgradable packages, Sui creates an UpgradeCap object, which allows the owner to upgrade the package in the future.
Example from deployment output:

│ ObjectType: 0x2::package::UpgradeCap
│ ObjectID:   0x7530c33e4cf3345236601d69303e3fab84efc294194a810dc1cfea13c009e77f


4. You Receive Important IDs
The deployment output includes:
PackageID: The address of your package on-chain.
UpgradeCap ObjectID (if applicable): Needed for future upgrades.


5. Other Contracts and Users Can Interact With Your Package
Once published, your package’s modules and public functions can be called by other contracts or users, using the PackageID.


6. Gas Is Consumed
Deploying a package is a transaction and requires gas (SUI tokens).


- Deploy package
    - Why do you need to deploy it (to interact with it)
    - What happens when you deploy it

## Interact with the Move package

- Interact with the package
    - Transactions
        - Basic transaction limits, constraints, etc
            - You cannot send 2 or more transactions simultaneously
            - Your wallet has locked objects.
                - For both of these conditions, you have to  wait till the current epoch ends before you can transact again
                    - Definition of epoch, GlossaryToolTip?
            - Link to detailed spec page on transaction constraints/limits/etc
        - Send a basic transaction
        - Link to Access Sui Data page

