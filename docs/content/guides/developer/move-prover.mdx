---
title: Sui Move Prover
---

The Sui Move Prover is a tool for verifying the correctness of Move smart contracts on the Sui blockchain. It is based on the Boogie verification engine and the Z3 SMT solver.

## Installation

For now, the Sui Move Prover lives in the [Move Nursery](https://github.com/MystenLabs/move-nursery) as a fork of the Sui framework.

TODO: Add instructions for installing the Sui Move Prover.

## Usage

To use the Move Prover you need to write specifications for your smart contract. The Move Prover will then verify that your smart contract satisfies these specifications.

### Example

Let's consider a simple example, the `withdraw` function of a simplified LP (Liquidity Pool) smart contract:

```move
module amm::simple_lp;

use sui::balance::{Balance, Supply, zero};

public struct LP<phantom A> has drop {}

public struct Pool<phantom A> has store {
    balance: Balance<A>,
    shares: Supply<LP<A>>,
}

public fun withdraw<T: key>(pool: &mut Pool<T>, shares_in: Balance<LP<T>>): Balance<T> {
    if (shares_in.value() == 0) {
        shares_in.destroy_zero();
        return zero()
    };

    let balance = pool.balance.value();
    let shares = pool.shares.supply_value();

    let balance_to_withdraw = (((shares_in.value() as u128) * (balance as u128)) / (shares as u128)) as u64;

    pool.shares.decrease_supply(shares_in);
    pool.balance.split(balance_to_withdraw)
}
```

To verify that the `withdraw` function is correct, we need to write a specification for it. The specification should describe the expected behavior of the function.

### The structure of a specification

Specs usually have the following structure:

```move
#[spec(verify)]
fun withdraw_spec<T: key>(pool: &mut Pool<T>, shares_in: Balance<LP<T>>): Balance<T> {

    // Conditions which must hold on the arguments of the function

    let result = withdraw(pool, shares_in);

    // Conditions which must hold as an effect of the function call

    result
}
```

Let's break down the above:

- The specification will be a new function `withdraw_spec` that takes the same arguments as the `withdraw` function and returns the same type.
- The function is annotated with `#[spec(verify)]` to indicate that it is a specification and that it will be verified using the Move Prover.
- The body of the spec function usually:
  - specifies the conditions which must hold on the arguments of the function
  - then calls the function to be verified
  - specifies the conditions which must hold as an effect of the function call
  - returns the result of the function call

### Example specification

Let's write a specification that says that the price of a share should not decrease when withdrawing funds:

```move
#[spec(verify)]
fun withdraw_spec<T: key>(pool: &mut Pool<T>, shares_in: Balance<LP<T>>): Balance<T> {
    requires(shares_in.value() <= pool.shares.supply_value());

    let old_pool = old!(pool);

    let result = withdraw(pool, shares_in);

    let old_balance = old_pool.balance.value().to_int();
    let new_balance = pool.balance.value().to_int();

    let old_shares = old_pool.shares.supply_value().to_int();
    let new_shares = pool.shares.supply_value().to_int();

    ensures(new_shares.mul(old_balance).lte(old_shares.mul(new_balance)));

    result
}
```

Let's break down the specification:

1. We specify the conditions which must hold on the arguments of the function. The number of shares to withdraw must be less than or equal to the total number of shares in the pool:

   ```
   shares_in.value() <= pool.shares.supply_value()
   ```

2. We save the old state of the pool in `old_pool`:

   ```
   let old_pool = old!(pool);
   ```

3. We call the function to be verified:

   ```
   let result = withdraw(pool, shares_in);
   ```

4. We compute the old and new balances and shares, and convert them to unbounded integers:

   ```
   let old_balance = old_pool.balance.value().to_int();
   let new_balance = pool.balance.value().to_int();

   let old_shares = old_pool.shares.supply_value().to_int();
   let new_shares = pool.shares.supply_value().to_int();
   ```

   Unbounded integers are a spec-only type which allow writing conditions without having to worry about overflows. The are only available in the spec environment.

5. We specify the conditions which must hold as an effect of the function call. The price of a share should not decrease when withdrawing funds:

   ```
   ensures(new_shares.mul(old_balance).lte(old_shares.mul(new_balance)));
   ```

   `ensures` is a spec-only keyword that specifies a condition which must hold as an effect of the function call.

   `mul` and `lte` are spec-only operators over the unbounded integer types described above.

6. Finally, we return the result of the function call:

   ```
   result
   ```

### Running the Move Prover

To run the Move Prover, you need to have the Move Prover installed and configured.

Use the following command to run the Move Prover:

```
sui move build --generate-boogie
```

When the specifications are correct, the output is empty. On error, the Move Prover will print a message and the location of the source of the error.

TODO: update the documentation once we create a better way to run the prover

### Full example for reference

And here is the full example for reference:

```move
module amm::simple_lp;

use sui::balance::{Balance, Supply, zero};

#[spec_only]
use prover::prover::{requires, ensures, asserts, old};

public struct LP<phantom A> has drop {}

public struct Pool<phantom A> has store {
    balance: Balance<A>,
    shares: Supply<LP<A>>,
}

public fun withdraw<T: key>(pool: &mut Pool<T>, shares_in: Balance<LP<T>>): Balance<T> {
    if (shares_in.value() == 0) {
        shares_in.destroy_zero();
        return zero()
    };

    let balance = pool.balance.value();
    let shares = pool.shares.supply_value();

    let balance_to_withdraw = (((shares_in.value() as u128) * (balance as u128)) / (shares as u128)) as u64;

    pool.shares.decrease_supply(shares_in);
    pool.balance.split(balance_to_withdraw)
}

// Verify that the price of the token is not decreased by withdrawing liquidity
#[spec(verify)]
fun withdraw_spec<T: key>(pool: &mut Pool<T>, shares_in: Balance<LP<T>>): Balance<T> {
    requires(shares_in.value() <= pool.shares.supply_value());

    let old_pool = old!(pool);

    let result = withdraw(pool, shares_in);

    let old_balance = old_pool.balance.value().to_int();
    let new_balance = pool.balance.value().to_int();

    let old_shares = old_pool.shares.supply_value().to_int();
    let new_shares = pool.shares.supply_value().to_int();

    ensures(new_shares.mul(old_balance).lte(old_shares.mul(new_balance)));

    result
}

```
