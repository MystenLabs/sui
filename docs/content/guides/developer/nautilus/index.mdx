---
title: Nautilus
description: Run secure, off-chain logic in trusted execution environments (TEEs), and verify it on-chain to trigger safe smart contract workflows.
---

Nautilus is a verifiable off-chain compute layer on Sui. It enables builders to delegate sensitive or resource-intensive tasks to a self-managed [trusted execution environment (TEE)](https://en.wikipedia.org/wiki/Trusted_execution_environment) or a TEE marketplace like [Marlin Oyster](/guides/developer/nautilus/marlin) while preserving trust on-chain through smart contract-based verification.

Nautilus supports hybrid decentralized applications that require private data handling, complex computations, or integration with external (Web2) systems. The framework ensures computations are tamper-resistant, isolated, and cryptographically verifiable.

It currently supports self-managed [AWS Nitro Enclave TEEs](https://aws.amazon.com/ec2/nitro/nitro-enclaves/) and Dockerized deployments through [Marlin](/guides/developer/nautilus/marlin). You can verify AWS-signed enclave attestations on-chain using Sui smart contracts written in Move. Refer to the [Github repo](https://github.com/MystenLabs/nautilus) for the reproducible build template.

## Features

:::important
Nautilus is NOT just about running code in privacy-preserving manner in a TEE. Part of the overall value proposition is **on-chain verification** of computation integrity:

1. PCRs (enclave measurements) must be registered and verified on-chain
2. Every computation result could optionally be verified on-chain
:::

A Nautilus application consists of 2 components:

- **Off-chain server:** Runs inside a TEE and handles computations like user input processing or scheduled tasks.

- **On-chain smart contract**: Written in Move, verifies TEE attestations before executing transactions.

## How it works

- Deploy the off-chain server to a self-managed TEE, such as AWS Nitro Enclaves, or use [Marlin Oyster](/guides/developer/nautilus/marlin) to deploy Dockerized Nautilus apps.

:::danger

The [provided reproducible build template](https://github.com/MystenLabs/nautilus) is intended as a starting point for building your own enclave. It is not feature complete, has not undergone a security audit, and is offered as a modification-friendly reference licensed under the Apache 2.0 license. 

**The template and its related documentation are provided as is without warranty of any kind for evaluation purposes only.***

You can adapt and extend it to fit your specific use case.

:::

- The TEE generates a cryptographic attestation that proves the integrity of the execution environment.

- Sui smart contracts verify the attestation on-chain before accepting the TEE output.

- The integrity of the TEE is auditable and anchored by the provider's root of trust.

Refer to [Nautilus design](/guides/developer/nautilus/nautilus-design.mdx) and [using Nautilus](/guides/developer/nautilus/using-nautilus.mdx) for details.

## Use cases

Nautilus supports several Web3 use cases for trustworthy and verifiable off-chain computation. Some examples include:

- **Trusted oracles**: Process off-chain data from Web2 services (weather, sports, financial data) or decentralized storage platforms like [Walrus](https://walrus.xyz) in a tamper-resistant way.

- **AI agents:** Nautilus is ideal for securely running AI models for inference or to execute agentic workflows to produce actionable outcomes, while providing data and model provenance on-chain.

- **DePIN solutions:** DePIN (Decentralized Physical Infrastructure) can leverage Nautilus for private data computation in IoT and supply chain networks.

- **Fraud prevention in multi-party systems:** Decentralized exchanges (DEXs) could use Nautilus for order matching and settlement, or layer 2 solutions could prevent collision and fraud by securely running computations between untrusted parties.

- **Identity management:** Nautilus can provide solutions in the identity management space that require on-chain verifiability for decentralized governance and proof of tamper resistance.

## Seal

When used together, Nautilus and [Seal](/guides/developer/nautilus/seal) enable powerful privacy-preserving use cases by combining secure and verifiable computation with secure key access. A common challenge with TEEs is persisting secret keys across restarts and different machines. Seal can address this by securely storing long-term keys and granting access only to properly attested TEEs. In this model, Nautilus handles computation over the encrypted data, while Seal controls key access. Applications that require a shared encrypted state can use both tools to privately process user requests and update encrypted data on public networks.
