---
title: Asset Tokenization
description: Learn how to tokenize assets on the Sui blockchain. Asset tokenization refers to the process of representing real-world assets, such as real estate, art, commodities, stocks, or other valuable assets, as digital tokens on the blockchain network.
---

Asset tokenization refers to the process of representing real-world assets, such as real estate, art, commodities, stocks, or other valuable assets, as digital tokens on the blockchain network. This involves converting the ownership or rights of an asset into digital tokens, which are then recorded and managed on the blockchain.

## High-level overview

The concept is to divide high-value assets into smaller, more affordable units, representing ownership or a fraction of the asset.

This strategy enables wider participation from investors who might want to mitigate risk by investing in a portion of a digital asset rather than being the sole owner, thereby expanding accessibility to a broader range of investors.

This pattern is similar to the [ERC1155](https://eips.ethereum.org/EIPS/eip-1155) multi-token standard with additional functionality. This makes it a suitable choice for Solidity based use cases that you might want to implement on Sui.

- **Asset creation**

  Each asset is fractionalized into a total supply, with each fraction represented as either a non-fungible token (NFT) or fungible token (FT) type collectible. This ensures that each individual fraction maintains a balance equal to or greater than 1, and when combined, all fractions collectively reach the total supply of the asset.

  Besides the total supply, each asset is defined by various other fields such as name, description, and more. These fields collectively form the metadata for the asset, and they remain consistent across all fractions of the asset.

- **NFTs vs FTs distinction**

  Each time a tokenized asset is minted, the system can create it with new metadata. If new metadata is incorporated, the tokenized asset becomes unique, transforming it into an NFT. In this case, its balance is limited to 1, signifying that only a single instance of this asset exists.

  If no additional metadata exists, the system categorizes the tokenized asset as an FT, allowing its balance to exceed 1, enabling multiple identical instances of the asset to exist.

  FTs possess the capability to merge (join) among themselves or be split when the balance is greater than 1. This functionality allows for the aggregation or division of units of the token, offering flexibility in handling varying quantities as needed.

  As previously mentioned, all the collectibles of tokenized assets, whether NFTs or FTs, when combined, can amount to the maximum total supply of the asset.

- **Burnability**

  When you create the asset, you can define whether the fractions of the asset are eligible for removal or destruction from circulation. The process of removing or destroying assets is called burning.

  If a tokenized asset is burnable, then burning a fraction causes the circulating supply to decrease by the balance of the burnt item. The total supply, however, remains constant, allowing you to mint the burned fractions again if needed, thus maintaining the predetermined total supply of the asset.

## Move packages

As with all smart contracts on Sui, Move provides the logic that powers asset tokenization.

### `asset_tokenization` package

:::info

This reference implementation uses the [Kiosk standard](../../../standards/kiosk.mdx) to ensure that tokenized assets operate within their defined policy. Use the implementation as presented to have marketable tokenized assets that support rules like royalties, commissions, and so on.

If Kiosk is not a requirement, then you can exclude the unlock module and some of the proxy's methods related to transfer policies.

:::

Select a module to view its details:

<Tabs groupId="modules">

<TabItem label="tokenized_asset" value="tokenized_asset">

The `tokenized_asset` module operates in a manner similar to the `coin` library.

When it receives a new One-Time Witness type, it creates a unique representation of a fractional asset. This module employs similar implementations to some methods found in the `Coin` module. It encompasses functionalities pertinent to asset tokenization, including new asset creation, minting, splitting, joining, and burning. See [One Time Witness](https://move-book.com/programmability/one-time-witness.html) in The Move Book for more information.

**Structs**

- `AssetCap`

  Generate an `AssetCap` for each new asset represented as a fractional NFT. In most scenarios, create it as an owned object, which you can then transfer to the platform's administrator for access-restricted method invocation.

  ```rust
  struct AssetCap<phantom T> {
      id: UID,
      // the current supply in circulation
      supply: Supply<T>,
      // the total max supply allowed to exist at any time
      total_supply: u64,
      // Determines if the asset can be burned or not
      burnable: bool
  }
  ```

- `AssetMetadata`

  The `AssetMetadata` struct defines the metadata representing the entire asset to fractionalize. This should be a shared object.

  ```rust
  struct AssetMetadata<phantom T> has key, store {
          id: UID,
          /// Name of the asset
          name: String,
          // the total max supply allowed to exist at any time
          total_supply: u64,
          /// Symbol for the asset
          symbol: ascii::String,
          /// Description of the asset
          description: String,
          /// URL for the asset logo
          icon_url: Option<Url>
      }
  ```

- `TokenizedAsset`

  The `TokenizedAsset` is minted with a specified balance that is less than or equal to the remaining supply. If the `VecMap` of an asset is populated with values, indicating multiple unique entries, it is considered an NFT. Conversely, if the `VecMap` of an asset is not populated, indicating an absence of individual entries, it is considered an FT.

  ```rust
  struct TokenizedAsset<phantom T> has key, store {
          id: UID,
          /// The balance of the tokenized asset
          balance: Balance<T>,
          /// If the VecMap is populated, it is considered an NFT, else the asset is considered an FT.
          metadata: VecMap<String, String>,
          /// URL for the asset image (optional)
          image_url: Option<Url>,
      }
  ```

- `PlatformCap`

  The `PlatformCap` refers to the capability issued to the individual who deploys the contract. This capability grants specific permissions or authority related to the platform's functionalities, allowing the deployer certain controlled actions or access rights within the deployed contract.

  ```rust
  /// Capability that is issued to the one deploying the contract
  struct PlatformCap has key, store { id: UID }
  ```

**Functions**

- `init`

  This function creates a `PlatformCap` and transfers it to the transaction sender.

  ```rust
  fun init(ctx: &mut TxContext) {}
  ```

- `new_asset`

  This function holds the responsibility of creating a fresh representation of an asset, defining its crucial attributes. Upon execution, it returns 2 distinct objects: the `AssetCap` and `AssetMetadata`. These objects encapsulate the necessary information and characteristics defining the asset within the system.

  ```rust
  public fun new_asset<T: drop>(
          witness: T,
          total_supply: u64,
          symbol: ascii::String,
          name: String,
          description: String,
          icon_url: Option<Url>,
          burnable: bool,
          ctx: &mut TxContext
      ): (AssetCap<T>, AssetMetadata<T>) {}
  ```

- `mint`

  The function performs the minting of a tokenized asset. If new metadata is introduced during this process, the tokenized asset becomes unique, resulting in the creation of an NFT with a balance set to 1. Alternatively, if no new metadata is added, the system classifies the tokenized asset as an FT, permitting its balance to surpass 1, as specified by a provided argument. Upon execution, the function returns the tokenized asset object.

  ```rust
  public fun mint<T>(
          cap: &mut AssetCap<T>,
          keys: vector<String>,
          values: vector<String>,
          value: u64,
          ctx: &mut TxContext
      ): TokenizedAsset<T> {}
  ```

- `split`

  This function receives a tokenized asset of the FT type and a balance greater than 1, along with a value less than the object's balance, and performs a split operation on the tokenized asset. The operation divides the existing tokenized asset into 2 separate tokenized assets. The newly created tokenized asset has a balance equal to the given value, while the balance of the provided object is reduced by the specified value. Upon completion, the function returns the newly created tokenized asset. This function does not accept or operate on tokenized assets of the NFT type.

  ```rust
  public fun split<T>(
          self: &mut TokenizedAsset<T>,
          split_amount: u64,
          ctx: &mut TxContext
      ): TokenizedAsset<T> {}
  ```

- `join`

  This function receives 2 tokenized assets of the FT type and performs a join operation, merging them into 1. The function increases the balance of the first tokenized asset by adding the balance of the second tokenized asset to it, and then destroys the second tokenized asset. This function does not accept or operate on tokenized assets of the NFT type.

  ```rust
  public fun join<T>(self: &mut TokenizedAsset<T>, other: TokenizedAsset<T>) {}
  ```

- `burn`

  This function receives a tokenized asset and performs the burning operation, consuming the object and removing it from circulation. As a result, the current circulating supply decreases by the balance of the burned tokenized asset. However, the total supply remains unaffected and constant. If the asset fractions were configured as burnable during creation, you can later mint the burned balance and restore it to circulation. This function can operate on both NFT and FT types.

  ```rust
  public fun burn<T>(cap: &mut AssetCap<T>, tokenized_asset: TokenizedAsset<T>): u64 {}
  ```

- `total_supply`

  This function returns the maximum supply of the asset.

  ```rust
  public fun total_supply<T>(cap: &AssetCap<T>): u64 {}
  ```

- `supply`

  This function returns the current circulating supply of the asset.

  ```rust
  public fun supply<T>(cap: &AssetCap<T>): u64 {}
  ```

- `balance`

  This function returns the balance of a tokenized asset.

  ```rust
  public fun balance<T>(tokenized_asset: &TokenizedAsset<T>): u64 {}
  ```

- `is_nft`

  This function returns `true` if a tokenized asset is an NFT, `false` otherwise.

  ```rust
  public fun is_nft<T>(tokenized_asset: &TokenizedAsset<T>): bool {}
  ```

</TabItem>

<TabItem label="proxy" value="proxy">

The `proxy` module provides an interface allowing interaction with the asset tokenization functionality while adhering to the constraints of the Kiosk standard and transfer policy rules.

This module allows kiosk owners to place their tokenized assets inside a kiosk and lock them if they wish to sell or transfer them. Otherwise, if not used with a kiosk, the owner is free to perform any available function from the `tokenized_asset` module without any restrictions.

**Functions**

- `burn_in_kiosk`

  This function performs the burning operation of the asset within a kiosk. Provide the kiosk and its corresponding `KioskOwnerCap`, along with the tokenized asset `ID` to burn and the `AssetCap` object for this asset type. Upon execution, the function destroys the tokenized asset, reducing the current circulating supply by the balance of the burned tokenized asset. This function can operate on both NFT and FT types.

  ```rust
  public fun burn_in_kiosk<T>(
          kiosk: &mut Kiosk,
          cap: &KioskOwnerCap,
          asset_cap: &mut AssetCap<T>,
          tokenized_asset_id: ID,
          policy: &TransferPolicy<TokenizedAsset<T>>,
          ctx: &mut TxContext
      ) {}
  ```

- `list_with_purchase_cap`

  This function offers the same functionality as `kiosk::list_with_purchase_cap`.

  ```rust
  public fun list_with_purchase_cap<T>(
          kiosk: &mut Kiosk,
          cap: &KioskOwnerCap,
          item_id: ID,
          min_price: u64,
          ctx: &mut TxContext
      ): PurchaseCap<TokenizedAsset<T>> {}
  ```

- `purchase_with_cap`

  This function offers the same functionality as `kiosk::purchase_with_cap`.

  ```rust
  public fun purchase_with_cap<T>(
          kiosk: &mut Kiosk,
          purchase_cap: PurchaseCap<TokenizedAsset<T>>,
          payment: Coin<SUI>,
      ): (TokenizedAsset<T>, TransferRequest<TokenizedAsset<T>>) {}
  ```

- `return_purchase_cap`

  This function offers the same functionality as `kiosk::return_purchase_cap`.

  ```rust
  public fun return_purchase_cap<T>(
          kiosk: &mut Kiosk,
          purchase_cap: PurchaseCap<TokenizedAsset<T>>,
      ) {}
  ```

- `join_in_kiosk`

  This function performs the join operation inside a kiosk, similar to `join` from the `tokenized_asset` module. Provide the kiosk and its corresponding `KioskOwnerCap`, along with the 2 tokenized assets IDs to join and the `TransferPolicy` object for this asset type. The function increases the balance of the first tokenized asset by adding the balance of the second tokenized asset to it, and then destroys the second tokenized asset. This function can only operate on tokenized assets of the FT type.

  ```rust
  public fun join_in_kiosk<T>(
          kiosk: &mut Kiosk,
          cap: &KioskOwnerCap,
          tokenized_asset_id_1: ID,
          tokenized_asset_id_2: ID,
          policy: &TransferPolicy<TokenizedAsset<T>>,
          ctx: &mut TxContext
      ) {}
  ```

- `split_in_kiosk`

  This function performs the split operation inside a kiosk, similar to `split` from the `tokenized_asset` module. Provide the kiosk and its corresponding `KioskOwnerCap`, the tokenized asset `ID` to split, the desired split amount, and the `TransferPolicy` object for this asset type. The function reduces the provided tokenized asset balance by the split amount, creates a new tokenized asset with a balance equal to the split amount, places it in the kiosk, and locks it. This function can only operate on tokenized assets of the FT type.

  ```rust
  public fun split_in_kiosk<T>(
          kiosk: &mut Kiosk,
          cap: &KioskOwnerCap,
          tokenized_asset_id: ID,
          split_amount: u64,
          policy: &TransferPolicy<TokenizedAsset<T>>,
          ctx: &mut TxContext
      ) {}
  ```

</TabItem>

<TabItem label="unlock" value="unlock">

The `unlock` module defines the unlock rule, which allows an NFT or FT tokenized asset to be taken from the kiosk (unlocked). This situation might occur when the owner intends to join 2 FTs, burn an FT or NFT, or split an FT. Such situations require the asset to be unlocked first in order to proceed.

However, this is permitted only for the asset's kiosk owner and the policy administrator.

**Functions**

- `unlock`

  This function allows the kiosk owner to unlock their tokenized assets when using a protected transfer policy. The owner can perform certain actions like burn, join, and split inside the kiosk because the proxy module allows it. However, to unlock an item in general, the owner needs to use this function with the `ProtectedTP` object, which represents a capability object that permits unlocking tokenized assets from the kiosk.

  ```rust
  public fun unlock<T>(
          tokenized_asset: TokenizedAsset<T>,
          transfer_request: TransferRequest<TokenizedAsset<T>>,
          protected_tp: &ProtectedTP<TokenizedAsset<T>>,
          _ctx: &mut TxContext
      ): TokenizedAsset<T> {}
  ```

</TabItem>

</Tabs>

:::tip

For more information about the `asset_tokenization` package, see the annotated source code for each module: [tokenized_asset.move](https://github.com/MystenLabs/asset-tokenization/blob/main/move/asset_tokenization/sources/tokenized_asset.move), [proxy.move](https://github.com/MystenLabs/asset-tokenization/blob/main/move/asset_tokenization/sources/proxy.move), and [unlock.move](https://github.com/MystenLabs/asset-tokenization/blob/main/move/asset_tokenization/sources/unlock.move).

:::

### Deploying `asset_tokenization` package

The `asset_tokenization` package does not require any modifications before deploying. You can deploy the package directly on the desired Sui network using `sui client publish`. For more information on packages, see [Build and Test Packages](../../../developer/sui-101/building-ptb.mdx).

Capture the package address from the publish response to use it in constructing the deployer package later.

### `deployer` package

In the `deployer` package, define the template for representing the asset that you want to tokenize. In the typical definition, instantiate a new representation of an asset using a One-Time Witness pattern. This involves utilizing a one-time-use type that guarantees a specific operation or initialization occurs only once within the contract, typically employed in scenarios where unique asset creation or initialization is crucial. See [One Time Witness](https://move-book.com/programmability/one-time-witness.html) in The Move Book for more information.

**Modules**

This package includes 2 modules, `template` and `genesis`. The template module is the blueprint to instantiate each new representation of a tokenized asset, which occurs through calls to the genesis module. The genesis module contains the logic that performs bytecode manipulation to instantiate template modules.

- `template`

  The `template` module provides the structure to tokenize different assets. For each distinct asset you tokenize, you must instantiate the template module through the genesis module. Achieve this by invoking the `create_type` function defined within the genesis module, which, in turn, dynamically instantiates the `template` module. This process establishes a new and distinct instance of the template module for each asset you tokenize. See [Bytecode manipulation](#bytecode-manipulation) for more information.

  The template module encompasses the following components:

  **Structs**

  - `TEMPLATE`

    As mentioned earlier, the One-Time Witness pattern demands the `TEMPLATE` struct to have only the `drop` ability and a single instance. The execution of a unique instance occurs right after the instantiation of this module. Consequently, we gain the assurance that the struct `TEMPLATE` serves as a witness, enabling the creation of a unique asset representation.

  - `TemplateEvent`

    The `TemplateEvent` is triggered upon creation of a new asset representation, making it straightforward to observe the transaction where this event occurred. It contains the `AssetCap` object ID and the `AssetMetadata` object ID associated with the newly created asset, providing you with the IDs of these objects, which are essential for subsequent interactions with the asset.

  **Functions**

  - `init`

    The `init` function operates similar to `new_asset` from the `tokenized_asset` module. During the execution of the `init` function, it spawns an instance of the `AssetCap` and `AssetMetadata` objects. Each distinct asset you tokenize corresponds to unique instances of these objects.

    In the `init` function, you can access distinct parameters to supply to the function. For example, modify the field values the struct accepts, such as `total_supply`, `burnable`, `name`, `description`, and `icon_url`, by supplying different values to the function. These modifications alter the behavior and appearance of each newly instantiated module, resulting in unique instances of the asset template.

    For example:

    ```rust
    fun init(otw: TEMPLATE, ctx: &mut TxContext) {
            let (asset_cap, metadata) = tokenized_asset::new_asset(
                otw,
                1000,
                ascii::string(b"SYMBOL"),
                string::utf8(b"NAME"),
                string::utf8(b"DESCRIPTION"),
                option::none(),
                false,
                ctx
            );

            let asset_cap_id = object::id(&asset_cap);
            let metadata_id = object::id(&metadata);

            event::emit(TemplateEvent {
                asset_cap: asset_cap_id,
                metadata: metadata_id,
            });

            transfer::public_transfer(asset_cap, tx_context::sender(ctx));
            transfer::public_share_object(metadata);
        }
    ```

- `genesis`

  The genesis module contains the logic that performs the bytecode manipulation on the `template` module and publishes it, resulting in the instantiation of a module. The outcome is a module representing a distinct asset for tokenization, identifiable by its unique type.

  **Functions**

  - `create_type`

    The `create_type` function forms the foundation of the deployer package, orchestrating the bytecode manipulation process.

    When you invoke this function from the client side (TypeScript), it instantiates a module by taking bytes of the `template` module (and the Move standard library module `ascii`) and substituting `TEMPLATE` with the given name (the first argument). Finally, it publishes the module, essentially creating a module with a user-defined type representing a distinct tokenized asset.

    ```rust
    /// Create a new type by mangling the TEMPLATE module and publish it as a package to the chain.
    /// - `name` is the new name of the TEMPLATE type (struct). It will be used to replace
    ///   all instances of "TEMPLATE" in the module bytecode
    /// - `modules` are the bytecode of the TEMPLATE and dependencies (must match the REPLACEABLE definition - the ASCII module)
    /// - `deps` are the dependencies to use for the new package (ex. `std`, `sui` and `asset_tokenization`)
    public fun create_type(
            _: &PlatformCap,
            name: String,
            mut modules: vector<vector<u8>>,
            mut deps: vector<address>,
            ctx: &mut TxContext
        ) {

            let name_bytes = name.into_bytes();

            assert!(modules.length() == 2, EInvalidModulesLength);
            assert!(name_bytes.length() <= TEMPLATE_LENGTH, ETypeNameTooLong);

            // dependencies should be in order: [std, sui, asset_tokenization]
            deps.push_back(@std);
            deps.push_back(@sui);
            deps.push_back(@asset_tokenization);

            while (name_bytes.length() < TEMPLATE_LENGTH) {
                name_bytes.push_back(PADDING);
            };

            // replace the "TEMPLATE" with `name_bytes` in both modules (template and ascii module)
            let mut i = 0;
            while (i < modules.length()) {
                replace(&mut modules[i], &name_bytes);
                i = i + 1;
            };

            sui::package::claim_and_keep(sui::package::publish(ticket(modules, deps), ctx), ctx);
        }
    ```

    In the comment section of the `create_type` function, you can observe the anticipated inputs and their descriptions. When examining the function's structure, make note of the bytecode manipulation components responsible for substituting the `TEMPLATE` string with the desired name to tokenize.

  To gain a deeper understanding of the logic, refer to the source code for this [module](https://github.com/MystenLabs/asset-tokenization/blob/main/move/deployer/sources/genesis.move).

#### Bytecode manipulation

The bytecode manipulation technique uses the `std::string::bytes` function to replace `TEMPLATE` occurrences in both the template module and the ascii module (dependency of the template module) with the asset name you specify. This manipulation occurs when you call the `create_type` function from the `genesis` module. After the substitution, the function publishes the modified package to the network.

This is particularly useful for instantiating multiple similar modules with slight variations (the asset name) when representing different types of tokenized assets, eliminating the need to define a new module manually for each variation. Although this topic is much more complex, this is a high-level overview.

### Deploying `deployer` package

After deploying the `asset_tokenization` package, you need to update the [Move.toml](https://github.com/MystenLabs/asset-tokenization/blob/main/move/deployer/Move.toml) file in the deployer package to point the dependencies to the `asset_tokenization` package's address you captured when it was published. If you didn't capture the package address when you published it, you can also use a network explorer to locate it.

Next, deploy the `deployer` package using `sui client publish`. Capture the package address from the publish response to use it in constructing the template package later.

## TypeScript setup

The TypeScript portion of the setup establishes a local project along with a set of predefined functions. These functions streamline the interaction process with the `asset_tokenization` and `deployer` packages, facilitating testing and usage procedures.

Clone the [Asset Tokenization](https://github.com/MystenLabs/asset-tokenization) repository or download the project's setup portion and store it in a directory of your preference. Next, navigate into the setup directory and install the dependencies and the executable commands:

```bash
$ cd setup
$ npm install
$ npm run call --help
```

These commands prepare the project for execution and interaction with the smart contracts you deployed earlier.

### Template files

The template module and its dependencies are stored as template files to be used when instantiating a new asset type through bytecode manipulation. Each template file contains a module's bytecode.

Template files are located in the [`setup/templates`](https://github.com/MystenLabs/asset-tokenization/tree/main/setup/templates) directory and you can use the following command to regenerate them to support your deployed contracts after you deploy the `asset_tokenization` package and update dependencies in the `deployer` package:

```bash
$ npm run generate-templates
```

### `.env` file

The [`.env.example`](https://github.com/MystenLabs/asset-tokenization/blob/main/setup/.env.example) file outlines the variables that the setup relies on. At a minimum, you need to set values for the first 4 environment variables to use most of the predefined functions.

```text
DEPLOYER_PACKAGE=<>
ASSET_TOKENIZATION_PACKAGE=<>
PLATFORM_CAP=<>
PRIVATE_KEY=<>
ASSET_CAP=<>
ASSET_METADATA=<>
ASSET_TYPE=<>
KIOSK_ID=<>
TRANSFER_POLICY=<>
PROTECTED_TP=<>
TOKENIZED_ASSET=<>
FT1=<>
FT2=<>
```

In a console or terminal located in the setup directory, create an `.env` file from the template by executing:

```bash
$ cp .env.example .env
```

Populate the first 4 environment variables, which are the minimum requirements to start interacting with the deployed contracts.

- `DEPLOYER_PACKAGE`: Package address of the deployed `deployer` package.
- `ASSET_TOKENIZATION_PACKAGE`: Package address of the deployed `asset_tokenization` package.
- `PLATFORM_CAP`: Object ID of `PlatformCap`, which you can capture from the transaction digest from publishing the `asset_tokenization` package. If you don't have the transaction digest, you can find the `PlatformCap` object ID with the [`sui client objects`](../../../references/cli/client.mdx#sui-client-objects) CLI command or in a Sui network explorer, like [Sui Explorer](https://suiscan.xyz/mainnet/home).
- `PRIVATE_KEY`: The private key from a wallet you own, granting you access to interact with the blockchain. Convert the private key from base64 to hex format using any online tool or programmatically. Store the hex encoded private key in this field. Never share your private key.

Use the remaining environment variables in the `.env` file as placeholders to capture and store IDs from the results of the predefined functions, which allows you to streamline the process of running the scripts and interacting with your tokenized assets. See the specific function for more information about where to find a specific ID.

The `.env` file is never pushed to GitHub through the `.gitignore`, so your information stays secure.

### Deploying template package

To begin the tokenization process, you must create a module that represents the new asset for tokenization by instantiating the template module. Use the predefined function `deployTemplate` to create and publish a package with the asset name you provide. Supply the desired asset name and execute the command from the setup directory:

```bash
npm run call deploy-template ASSET1
```

This command instantiates a template module with the provided asset name, performs bytecode manipulation, and publishes the resulting package to the network. The console response provides details about the published package. Look for the asset type and store it in the `.env` file (`ASSET_TYPE`). Additionally, capture the `AssetCap` and `AssetMetadata` object IDs from the `TemplateEvent` emitted in the console and store them in the corresponding fields within the `.env` file (`ASSET_CAP` and `ASSET_METADATA`).

Now you have the necessary object IDs stored in the `.env` file and can begin using the predefined functions for your asset.

For reference, the `deployTemplate` file is located in the [`setup/src/functions`](https://github.com/MystenLabs/asset-tokenization/tree/main/setup/src/functions) directory. Examine this file to observe how template files are incorporated into the function. The following code snippet illustrates this point:

```typescript
...
  const tx = new Transaction();

  // Get bytecodes of the template and dependencies
  const template = readFileSync("./templates/template", {
    encoding: "base64",
  });

  const ascii = readFileSync("./templates/ascii", { encoding: "base64" });

  const modules = [template, ascii];

  const [upgradeCap] = tx.moveCall({
    target: `${packageId}::genesis::create_type`,
    arguments: [
      tx.object(platformCap),
      tx.pure(bcs.string().serialize(assetName).toBytes()),
      tx.pure(bcs.vector(bcs.vector(bcs.U8)).serialize(modules).toBytes()),
      tx.pure(
        bcs
          .vector(bcs.Address)
          .serialize([
            normalizeSuiObjectId(assetTokenizationPackage),
            normalizeSuiObjectId(packageId),
          ])
          .toBytes()
      ),
      tx.pure(
        bcs
          .vector(bcs.Address)
          .serialize([normalizeSuiObjectId(packageId)])
          .toBytes()
      ),
    ],
  });

  tx.transferObjects(
    [upgradeCap],
    tx.pure(signer.getPublicKey().toSuiAddress(), "address")
  );
...
```

As mentioned in the [Bytecode manipulation](#bytecode-manipulation) section, the modules that you need to publish are the template and the genesis, hence the reason you have 2 elements in the `modules` array. It's also important to include any dependencies defined in the `Move.toml` file of the involved packages. The `packageId` used previously is the address the `asset_tokenization` package has been deployed to.

## TypeScript

Now, you can begin interacting with the deployed smart contract and your tokenized asset.

In a terminal or console within the project's setup directory, utilize the following commands:

- **Create Transfer Policy**

  First, create a `TransferPolicy` and a `ProtectedTP` with the following command:

  ```sh
  $ npm run call create-tp
  ```

  After executing the command, the console displays the effects of the transaction.

  By searching the transaction digest on a Sui network explorer, you can locate the created objects. Subsequently, select and save the `TransferPolicy ID` and the `ProtectedTP ID` from these objects into the respective fields within your .env file.

- **Add Rules**

  In the project's file `transferPolicyRules.ts` located in the directory `setup/src/functions`, you can modify the code to include the desired rules for your transfer policy.

  Code snippet to be modified:

  ```rust
  // A demonstration of using all the available rule add/remove functions.
      // You can chain these commands.
      tpTx
          .addFloorPriceRule('1000')
          .addLockRule()
          .addRoyaltyRule(percentageToBasisPoints(10), 0)
          // .addPersonalKioskRule()
          // .removeFloorPriceRule()
          // .removeLockRule()
          // .removeRoyaltyRule()
          // .removePersonalKioskRule()
  ```

  By running the command `npm run call tp-rules`, the rules are added to your transfer policy.

  Now, investors can trade the fractions of your asset according to the rules you've set.

- **Select Kiosk**

  You must place the tokenized assets within a kiosk if marketable assets are desired. Subsequently, you can list and sell them to other users. Lock the objects in the kiosk to prevent any future unauthorized usage outside the defined policy that you set.

  Best practices recommend a single, comprehensive kiosk for all operations. However, this might not always be the case. Therefore, this project requires the use of only 1 personal kiosk to ensure consistency and better management, even if you own multiple kiosks.

  To enforce this rule, execute the command `npm run call select-kiosk`. This provides you with the specific kiosk ID to use for this project.

  Then, store the provided Kiosk ID in the appropriate field within your .env file.

- **Mint**

  In the project's file `mint.ts`, found in the directory `setup/src/functions`, you can edit the code to mint the desired type (NFT/FT) and balance for your asset.

  As previously mentioned, if additional metadata is provided, the tokenized asset is treated as an NFT with a value of 1. However, if there is no extra metadata, the tokenized asset is regarded as an FT, and you have the flexibility to select its balance, which can exceed 1.

  Here is an example from the code that needs modification:

  ```rust
  // example without metadata -> FT
  function getVecMapValues() {

    const keys : string[] = [];
    const values : string[] = [];

    return { keys, values };
  }
  ```

  or

  ```rust
  // example with metadata -> NFT
  function getVecMapValues() {
  	const keys = [
  	  "Piece",
  	  "Is it Amazing?",
  	  "In a scale from 1 to 10, how good?",
    ];
    const values = ["8/100", "Yes", "11"];

    return { keys, values };
  }
  ```

  Upon executing the command `npm run call mint`, a new tokenized asset is minted. You can save the object's `ID` in the .env file for future reference.

- **Lock**

  Locking the objects within the kiosk is crucial to prevent any unauthorized usage beyond the established policy.

  Upon executing the command `npm run call lock`, your newly minted tokenized asset is secured within your kiosk.

  Before running the command, make sure that the field `TOKENIZED_ASSET` within your `.env` file is populated with the object you intend to lock.

- **Mint and Lock**

  Executing the command `npm run call mint-lock` performs both the mint and lock functions sequentially, ensuring the minted asset is created and immediately locked within the kiosk.

- **List**

  Now that your tokenized asset is placed and locked within your kiosk, you can proceed to list it for sale.

  In the project's file `listItem.ts`, found in the directory `setup/src/functions`, you can adjust the code to specify the desired asset for listing.

  Code snippet to be modified:

  ```rust
  const SALE_PRICE = '100000';
    kioskTx
      .list({
          itemId,
          itemType,
          price: SALE_PRICE,
      })
      .finalize();
  ```

  By running the command `npm run call list`, your tokenized asset is listed and made available for sale.

- **Purchase**

  When a user intends to purchase an item, it needs to be listed for sale. After the user selects the item to buy, they are required to modify the following snippet of code found in the file `purchaseItem.ts`, located in the `setup/src/functions` directory.

  ```rust
  const item = {
      itemType: tokenizedAssetType,
      itemId: tokenized_asset ?? tokenizedAssetID,
      price: "100000",
      sellerKiosk: targetKioskId,
  };
  ```

  Apart from specifying the item and its type, the buyer must set the specific price and the seller's kiosk ID to execute the purchase transaction successfully, accomplished by running `npm run call purchase`.

- **Join**

  When you execute the command `npm run call join`, 2 specified tokenized assets of the FT type are merged together. Before running the command, make sure that the fields `FT1` and `FT2` within your `.env` file are populated with the objects you intend to merge.

- **Burn**

  When you intend to burn a tokenized asset, execute the command `npm run call burn`. Following this action, the specified asset is destroyed. Before running the command, make sure that the field `TOKENIZED_ASSET` within your `.env` file is populated with the object you intend to burn.

- **Get Balance**

  By executing the command `npm run call get-balance`, you can retrieve the balance value associated with the specified tokenized asset.

- **Get Supply**

  By executing the command `npm run call get-supply`, you can retrieve the value representing the current circulating supply of the asset.

- **Get Total Supply**

  By executing the command `npm run call get-total-supply`, you can retrieve the value representing the current circulating supply of the asset.
