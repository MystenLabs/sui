---
title: Asset Tokenization
description: Learn how to tokenize assets on the Sui blockchain. Asset tokenization refers to the process of representing real-world assets, such as real estate, art, commodities, stocks, or other valuable assets, as digital tokens on the blockchain network.
---

Asset tokenization refers to the process of representing real-world assets, such as real estate, art, commodities, stocks, or other valuable assets, as digital tokens on the blockchain network. This involves converting the ownership or rights of an asset into digital tokens, which are then recorded and managed on the blockchain.

## High-level overview

The concept is to divide high-value assets into smaller, more affordable units, representing ownership or a fraction of the asset.

This strategy enables wider participation from investors who might want to mitigate risk by investing in a portion of a digital asset rather than being the sole owner, thereby expanding accessibility to a broader range of investors.

This pattern is similar to the [ERC1155](https://eips.ethereum.org/EIPS/eip-1155) multi-token standard with additional functionality. This makes it a suitable choice for Solidity based use cases that you might want to implement on Sui.

- **Asset creation**

  Each asset is fractionalized into a total supply, with each fraction represented as either a non-fungible token (NFT) or fungible token (FT) type collectible. This ensures that each individual fraction maintains a balance equal to or greater than 1, and when combined, all fractions collectively reach the total supply of the asset.

  Besides the total supply, each asset is defined by various other fields such as name, description, and more. These fields collectively form the metadata for the asset, and they remain consistent across all fractions of the asset.

- **NFTs vs FTs distinction**

  Each time a tokenized asset is minted, there's a possibility for it to be created with new metadata. If new metadata is incorporated, the tokenized asset is deemed unique, transforming it into an NFT. In this case, its balance is limited to 1, signifying that only a single instance of this asset exists.

  If there's no additional metadata, the tokenized asset is categorized as an FT, allowing its balance to exceed 1, enabling multiple identical instances of the asset to exist.

  FTs possess the capability to merge (join) among themselves or be split when the balance is greater than 1. This functionality allows for the aggregation or division of units of the token, offering flexibility in handling varying quantities as needed.

  As previously mentioned, all the collectibles of tokenized assets, whether NFTs or FTs, when combined, can amount to the maximum total supply of the asset.

- **Burnability**

  When you create the asset, you can define whether the fractions of the asset are eligible for removal or destruction from circulation. Burning refers to the process of removing or destroying assets.

  If a tokenized asset is burnable, then burning a fraction causes the circulating supply to decrease by the balance of the burnt item. The total supply, however, remains constant, allowing you to mint the burned fractions again if needed, thus maintaining the predetermined total supply of the asset.

## Move packages

As with all smart contracts on Sui, Move provides the logic that powers asset tokenization.

### `asset_tokenization` package

:::info

This reference implementation uses the [Kiosk standard](../../../standards/kiosk.mdx) to ensure that tokenized assets operate within their defined policy. Use the implementation as presented to have marketable tokenized assets that support rules like royalties, commissions, and so on.

If using Kiosk is not a requirement, then you can exclude the unlock module and some of the proxy's methods related to transfer policies.

:::

Select a module to view its details:

<Tabs groupId="modules">

<TabItem label="tokenized_asset" value="tokenized_asset">

The `tokenized_asset` module operates in a manner similar to the `coin` library.

When it receives a new One-Time Witness type, it creates a unique representation of a fractional asset. This module employs similar implementations to some methods found in the `Coin` module. It encompasses functionalities pertinent to asset tokenization, including new asset creation, minting, splitting, joining, and burning. See [One-Time Witness](https://move-book.com/programmability/one-time-witness.html) in The Move Book for more information.

**Structs**

- `AssetCap`

  Generate an `AssetCap` for each new asset represented as a fractional NFT. In most scenarios, you should create it as an owned object, which you can then transfer to the platform's administrator for access-restricted method invocation.

  ```rust
  struct AssetCap<phantom T> {
      id: UID,
      // the current supply in circulation
      supply: Supply<T>,
      // the total max supply allowed to exist at any time
      total_supply: u64,
      // Determines whether the asset can be burned or not
      burnable: bool
  }
  ```

- `AssetMetadata`

  The `AssetMetadata` struct defines the metadata representing the entire asset to fractionalize. This should be a shared object.

  ```rust
  struct AssetMetadata<phantom T> has key, store {
          id: UID,
          /// Name of the asset
          name: String,
          // the total max supply allowed to exist at any time
          total_supply: u64,
          /// Symbol for the asset
          symbol: ascii::String,
          /// Description of the asset
          description: String,
          /// URL for the asset logo
          icon_url: Option<Url>
      }
  ```

- `TokenizedAsset`

  The `TokenizedAsset` is minted with a specified balance that is less than or equal to the remaining supply. If the `VecMap` of an asset is populated with values, indicating multiple unique entries, it is considered an NFT. Conversely, if the `VecMap` of an asset is not populated, indicating an absence of individual entries, it is considered an FT.

  ```rust
  struct TokenizedAsset<phantom T> has key, store {
          id: UID,
          /// The balance of the tokenized asset
          balance: Balance<T>,
          /// If the VecMap is populated, it is considered an NFT, else the asset is considered an FT.
          metadata: VecMap<String, String>,
          /// URL for the asset image (optional)
          image_url: Option<Url>,
      }
  ```

- `PlatformCap`

  The `PlatformCap` refers to the capability issued to the individual who deploys the contract. This capability grants specific permissions or authority related to the platform's functionalities, allowing the deployer certain controlled actions or access rights within the deployed contract.

  ```rust
  /// Capability that is issued to the one deploying the contract
  struct PlatformCap has key, store { id: UID }
  ```

**Functions**

- `init`

  This function creates a `PlatformCap` and sends it to the sender.

  ```rust
  fun init(ctx: &mut TxContext) {}
  ```

- `new_asset`

  This function creates a new representation of an asset, defining its crucial attributes. Upon execution, it returns 2 distinct objects: the `AssetCap` and `AssetMetadata`. These objects encapsulate the necessary information and characteristics defining the asset within the system.

  ```rust
  public fun new_asset<T: drop>(
          witness: T,
          total_supply: u64,
          symbol: ascii::String,
          name: String,
          description: String,
          icon_url: Option<Url>,
          burnable: bool,
          ctx: &mut TxContext
      ): (AssetCap<T>, AssetMetadata<T>) {}
  ```

- `mint`

  This function mints a tokenized asset. If new metadata is introduced during this process, the resulting tokenized asset is considered unique, resulting in the creation of an NFT with a balance set to 1. Alternatively, if no new metadata is added, the tokenized asset is classified as an FT, permitting its balance to surpass 1, as specified by a provided argument. Upon execution, the function returns the tokenized asset object.

  ```rust
  public fun mint<T>(
          cap: &mut AssetCap<T>,
          keys: vector<String>,
          values: vector<String>,
          value: u64,
          ctx: &mut TxContext
      ): TokenizedAsset<T> {}
  ```

- `split`

  You provide this function with a tokenized asset of the FT type and a balance greater than 1, along with a value less than the object's balance, and it performs a split operation on the tokenized asset. The operation divides the existing tokenized asset into 2 separate tokenized assets. The newly created tokenized asset has a balance equal to the given value, while the balance of the provided object is reduced by the specified value. Upon completion, the function returns the newly created tokenized asset. This function does not accept or operate on tokenized assets of the NFT type.

  ```rust
  public fun split<T>(
          self: &mut TokenizedAsset<T>,
          split_amount: u64,
          ctx: &mut TxContext
      ): TokenizedAsset<T> {}
  ```

- `join`

  This function allows an FT type tokenized asset to merge with another FT type tokenized asset with the same underlying type. The balance of the recipient tokenized asset increases by the balance of the absorbed tokenized asset. This function does not accept or operate on tokenized assets of the NFT type.

  ```rust
  public fun join<T>(self: &mut TokenizedAsset<T>, other: TokenizedAsset<T>) {}
  ```

- `burn`

  This function accepts a tokenized asset and destroys it, if permitted by the asset policy. Following the burn operation, the circulating supply decreases accordingly, while the total supply remains unchanged. This function returns the value of the balance from the burned tokenized asset.

  ```rust
  public fun burn<T>(
          cap: &mut AssetCap<T>,
          tokenized_asset: TokenizedAsset<T>,
      ): u64 {}
  ```

**View Functions**

- `total_supply`

  Use this function to retrieve the maximum allowed total supply of an asset.

  ```rust
  public fun total_supply<T>(metadata: &AssetMetadata<T>): u64 {}
  ```

- `supply`

  Use this function to retrieve the current circulating supply of an asset.

  ```rust
  public fun supply<T>(cap: &AssetCap<T>): u64 {}
  ```

- `balance`

  Use this function to retrieve the balance of a tokenized asset.

  ```rust
  public fun balance<T>(tokenized_asset: &TokenizedAsset<T>): u64 {}
  ```

- `is_nft`

  Use this function to confirm whether a tokenized asset is an NFT.

  ```rust
  public fun is_nft<T>(tokenized_asset: &TokenizedAsset<T>): bool {}
  ```

- `is_ft`

  Use this function to confirm whether a tokenized asset is an FT.

  ```rust
  public fun is_ft<T>(tokenized_asset: &TokenizedAsset<T>): bool {}
  ```

- `icon_url`

  Use this function to retrieve the icon URL of an asset.

  ```rust
  public fun icon_url<T>(metadata: &AssetMetadata<T>): Option<Url> {}
  ```

- `metadata`

  Use this function to retrieve the populated metadata of a tokenized asset. The keys and values are displayed in a specific format.

  ```rust
  public fun metadata<T>(tokenized_asset: &TokenizedAsset<T>): String {}
  ```

- `metadata_keys`

  Use this function to retrieve the keys of the metadata of a tokenized asset.

  ```rust
  public fun metadata_keys<T>(tokenized_asset: &TokenizedAsset<T>): vector<String> {}
  ```

- `metadata_values`

  Use this function to retrieve the values of the metadata of a tokenized asset.

  ```rust
  public fun metadata_values<T>(tokenized_asset: &TokenizedAsset<T>): vector<String> {}
  ```

</TabItem>

<TabItem label="proxy" value="proxy">

The `proxy` module facilitates the invocation of functions within the `tokenized_asset` module without the need for a publisher to deploy a separate smart contract.

Publishers use this proxy to create a new asset, mint, split, join, and burn functions.

This proxy also supports the secure placement and unlocking of assets within a Kiosk, which is crucial for managing assets within defined policies, ensuring policy-compliant transactions. Additionally, the proxy enables publishers to create and configure a `TransferPolicy` for these assets, defining rules and parameters governing asset transfers according to their requirements. See [Kiosk](../../../standards/kiosk.mdx) and [Transfer Policy](../../../standards/kiosk/transfer-policy.mdx) for more information.

**Functions**

- `new_display`

  This function creates a new display object for a specified asset type. It accepts a `PlatformCap` as proof of permission, along with the specified fields and values for the display object. Upon execution, it returns the created display object, which can be later configured and adjusted using the [Display](https://move-book.com/programmability/display.html) API. See Display in The Move Book for more information.

  ```rust
  public fun new_display<T>(
          platform_cap: &PlatformCap,
          pub: &Publisher,
          keys: vector<String>,
          values: vector<String>,
          ctx: &mut TxContext
      ): Display<TokenizedAsset<T>> {}
  ```

- `new_asset_and_cap`

  This function creates a new representation of an asset, defines its crucial attributes, and then transfers the `AssetMetadata` to the one making the request, retaining the `AssetCap`. Doing so grants permission to the user who invokes the function and submits the request. This ensures that only the authorized caller can execute specific operations or methods associated with the asset. This is crucial for implementing access control mechanisms, ensuring that only designated entities can perform certain actions related to the created asset. Besides the transfer of objects, it also creates a `Display` object and shares it for future adjustments if needed.

  ```rust
  public fun new_asset_and_cap<T: drop>(
          platform_cap: &PlatformCap,
          pub: &Publisher,
          witness: T,
          total_supply: u64,
          symbol: ascii::String,
          name: String,
          description: String,
          icon_url: Option<Url>,
          burnable: bool,
          ctx: &mut TxContext
      ) {}
  ```

- `mint_and_transfer`

  This function mints a tokenized asset and transfers it to the designated receiver. The tokenized asset might be subject to the transfer policy, as it can only be utilized through a Kiosk. However, it retains the capability to use the underlying methods (`join` and `split`) to interact with other tokenized assets and make balance adjustments as needed.

  ```rust
  public fun mint_and_transfer<T>(
          cap: &mut AssetCap<T>,
          keys: vector<String>,
          values: vector<String>,
          value: u64,
          receiver: address,
          ctx: &mut TxContext
      ) {}
  ```

- `place_and_lock_in_kiosk`

  To be able to trade your tokenized asset, it is necessary to place the asset inside a Kiosk and subsequently lock it to ensure it remains within the defined policy.

  When you place an object inside a Kiosk but leave it unlocked, the stored object can be removed. This creates a vulnerability, as the object might be transferred without triggering the associated `TransferPolicy` rules. By locking the object inside the Kiosk, you enforce that the `TransferPolicy` must be followed before any transfer can occur. See [Transfer Policy](../../../standards/kiosk/transfer-policy.mdx) for more information.

  ```rust
  public fun place_and_lock_in_kiosk<T>(
          kiosk: &mut Kiosk,
          cap: &KioskOwnerCap,
          policy: &TransferPolicy<TokenizedAsset<T>>,
          item: TokenizedAsset<T>,
      ) {}
  ```

- `unlock_from_kiosk`

  This function unlocks the tokenized asset from the Kiosk. When the tokenized asset is unlocked and becomes a normal object again, it is no longer subject to the transfer policies of the Kiosk.

  If the transfer policy accepts item unlocking, users can unlock the item. Unlocking the item enables its free transfer and unrestricted usage of its methods (`split`, `join`, `burn`, and so on). The method `unlock_from_kiosk` is part of the `unlock` module and should only be used by the original owner of the item or by someone who purchased the item.

  When transfer policies do not allow a locked item to leave the Kiosk, you can bypass this restriction using the method `admin_unlock_from_kiosk` (which is callable with `PlatformCap`). See [Kiosk](../../../standards/kiosk.mdx) and [Transfer Policy](../../../standards/kiosk/transfer-policy.mdx) for more information.

  ```rust
  public fun unlock_from_kiosk<T>(
          kiosk: &mut Kiosk,
          cap: &KioskOwnerCap,
          policy: &TransferPolicy<TokenizedAsset<T>>,
          protected_tp: &ProtectedTP<TokenizedAsset<T>>,
          item_id: object::ID,
          ctx: &mut TxContext
      ): TokenizedAsset<T> {}
  ```

- `admin_unlock_from_kiosk`

  The `admin_unlock_from_kiosk` method serves as an administrative function within the system and requires `PlatformCap` as proof of authorization. It enables administrators to unlock items from a Kiosk even when the transfer policy does not permit standard user unlocking. This method provides a way to intervene in exceptional cases where users might have difficulties managing their assets due to specific policy constraints.

  ```rust
  public fun admin_unlock_from_kiosk<T>(
          _: &PlatformCap,
          kiosk: &mut Kiosk,
          cap: &KioskOwnerCap,
          policy: &TransferPolicy<TokenizedAsset<T>>,
          item_id: object::ID,
          ctx: &mut TxContext
      ): TokenizedAsset<T> {}
  ```

- `new_policy`

  This function creates a `TransferPolicy` and a `ProtectedTP` specific to a Tokenized Asset. Requires `PlatformCap` for proof of permission. Returns `TransferPolicy` and `TransferPolicyCap`, which are necessary for configuring rules, and also returns `ProtectedTP` specifically designed for the specified type. See [Transfer Policy](../../../standards/kiosk/transfer-policy.mdx) for more information.

  ```rust
  public fun new_policy<T>(
          _: &PlatformCap,
          pub: &Publisher,
          ctx: &mut TxContext
      ): (TransferPolicy<TokenizedAsset<T>>, TransferPolicyCap<TokenizedAsset<T>>, ProtectedTP<TokenizedAsset<T>>) {}
  ```

- `enforce_rule_no_discount`

  This function enforces a rule without any discount. It accepts the `ProtectedTP` as proof of `TransferPolicy` existence, along with a transfer request.

  ```rust
  public fun enforce_rule_no_discount<T: key + store, Rule: drop>(
          protected_tp: &ProtectedTP<T>,
          request: &mut TransferRequest<T>
      ) {}
  ```

</TabItem>

<TabItem label="unlock" value="unlock">

The `unlock` module grants permission to unlock tokenized assets from the Kiosk in alignment with the transfer policy rules.

</TabItem>

</Tabs>

## Example use

For a comprehensive understanding and practical implementation of how this works in a typical scenario, refer to the [asset-tokenization](https://github.com/MystenLabs/asset-tokenization) GitHub repository.

The repository contains a complete Move package and TypeScript setup to demonstrate how you can tokenize an asset.

### Deployment

These are the steps you need to follow to deploy the contracts and have an instance of your tokenized asset operational:

1. Install Sui:

   - To install the latest version of Sui, see [Install Sui](../../../guides/developer/getting-started/sui-install.mdx).

1. Install Node.js:

   - This project is designed for Node.js `v18` or later. Refer to official [Node.js](https://nodejs.org/en) guidance to install the correct version on your operating system, if necessary.

1. Install pnpm:

   ```sh
   $ npm install -g pnpm
   ```

1. Clone the GitHub repository:

   ```sh
   $ git clone https://github.com/MystenLabs/asset-tokenization.git
   ```

1. Install the required packages in your project directory's setup folder:

   ```sh
   $ cd setup && npm install
   ```

1. Update the `Move.toml` file:

   Within your project, locate the `Move.toml` file inside the `contracts/sources` directory. Update it to reflect the appropriate addresses for the `testnet` and `mainnet` environments. There is a possibility of changing package addresses for the published framework and Kiosk packages.

1. Bytecode manipulation:

   In the directory `setup/src`, there's a `manipulate.ts` file to change the addresses within the compiled Move bytecode. Specifically, within the `move_packages_compiled_genesis` and `move_packages_compiled_template` paths, it navigates to the last package in both directories and performs bytecode manipulation to accommodate the necessary address adjustments.

   Before publishing, you need to compile both packages (templates and genesis) and then handle the bytecode manipulation. Execute the following commands:

   ```sh
   $ cd ..
   $ sui move build --path ./contracts/packages/genesis
   $ sui move build --path ./contracts/packages/template
   $ cd setup && npm run call manipulate
   ```

   :::info

   You only need to run the bytecode manipulation command once, before initially publishing the `asset_tokenization` package.

   :::

1. Publish and configure the `.env` file:

   After compilation and bytecode manipulation, you must publish the `asset_tokenization` package on the Sui network. To do so, open the file `publishPackage.ts` located in the `setup/src/functions` directory and edit the code so that you publish the package on your preferred network:

   ```ts
   const provider = new SuiClient({
       url: getFullnodeUrl("testnet"),
   });
   ```

   After ensuring the configuration is properly set for the network you want to deploy to, save the file and run the following command in the terminal or console to execute the publication:

   ```sh
   $ npm run call publish
   ```

   Upon running this command, you should observe the effects displayed in your console, showcasing the impacts and details of the publication process.

   Go to the project's setup directory and create a `.env` file. This file includes only the `package id` as the first field. After running the previous command, copy the `package id` from the transaction effects in the console and paste it into the `.env` file.

   You can use the `.env.example` file as a template to populate the `.env` file and subsequently modify the fields accordingly. The `.env.example` file illustrates the structure and information necessary for the proper functioning of the application. See [How to Use `.env` Files](https://www.npmjs.com/package/dotenv#how-do-i-use-dotenv-with-import) for more information.

The code snippet from the `publishPackage.ts` file demonstrates the process:

```ts
...
  const tx = new Transaction();
  const [upgradeCap] = tx.publish({
    modules: [
      ...compiledModulesGenesis,
      ...compiledModulesTemplate.slice(
        compiledModulesTemplate.length - 1,
        compiledModulesTemplate.length
      ),
    ],
    dependencies: [
      normalizeSuiObjectId("0x1"),
      normalizeSuiObjectId("0x2"),
      normalizeSuiObjectId(packageId),
    ],
  });

  tx.transferObjects(
    [upgradeCap],
    tx.pure(signer.getPublicKey().toSuiAddress(), "address")
  );
...
```

As mentioned in the [Bytecode manipulation](#bytecode-manipulation) section, the modules that you need to publish are the template and the genesis, hence the reason you have 2 elements in the `modules` array. It's also important to include any dependencies defined in the `Move.toml` file of the involved packages. The `packageId` used previously is the address the `asset_tokenization` package has been deployed to.

## TypeScript

Now, you can begin interacting with the deployed smart contract and your tokenized asset.

In a terminal or console within the project's setup directory, utilize the following commands:

- **`create-tp`**

  First, create a `TransferPolicy` and a `ProtectedTP` with the following command:

  ```sh
  $ npm run call create-tp
  ```

  After executing the command, the console displays the effects of the transaction.

  By searching the transaction digest on a Sui network explorer, you can locate the created objects. Subsequently, select and save the `TransferPolicy ID` and the `ProtectedTP ID` from these objects into the respective fields within your `.env` file.

- **`add-rules`**

  In the project's file `transferPolicyRules.ts` located in the directory `setup/src/functions`, you can modify the code to include the desired rules for your transfer policy.

  Code snippet to be modified:

  ```rust
  // A demonstration of using all the available rule add/remove functions.
      // You can chain these commands.
      tpTx
          .addFloorPriceRule('1000')
          .addLockRule()
          .addRoyaltyRule(percentageToBasisPoints(10), 0)
          // .addPersonalKioskRule()
          // .removeFloorPriceRule()
          // .removeLockRule()
          // .removeRoyaltyRule()
          // .removePersonalKioskRule()
  ```

  By running the command `npm run call tp-rules`, the rules are added to your transfer policy.

  Now, investors can trade the fractions of your asset according to the rules you've set.

- **`select-kiosk`**

  You must place the tokenized assets within a kiosk if marketable assets are desired. Subsequently, you can list and sell them to other users. You must lock the objects in the kiosk to prevent any future unauthorized usage outside the defined policy that you set.

  Best practices recommend a single, comprehensive kiosk for all operations. However, this might not always be the case. Therefore, this project requires the use of only 1 personal kiosk to ensure consistency and better management, even if you own multiple kiosks.

  To enforce this rule, execute the command `npm run call select-kiosk`. This provides you with the specific kiosk ID to use for this project.

  Then, store the provided Kiosk ID in the appropriate field within your `.env` file.

- **`mint`**

  In the project's file `mint.ts`, found in the directory `setup/src/functions`, you can edit the code to mint the desired type (NFT/FT) and balance for your asset.

  As previously mentioned, if additional metadata is provided, the tokenized asset is treated as an NFT with a value of 1. However, if no extra metadata is provided, the tokenized asset is regarded as an FT, and you have the flexibility to select its balance, which can exceed 1.

  Here is an example from the code that needs modification:

  ```rust
  // example without metadata -> FT
  function getVecMapValues() {

    const keys : string[] = [];
    const values : string[] = [];

    return { keys, values };
  }
  ```

  or

  ```rust
  // example with metadata -> NFT
  function getVecMapValues() {
  	const keys = [
  	  "Piece",
  	  "Is it Amazing?",
  	  "In a scale from 1 to 10, how good?",
    ];
    const values = ["8/100", "Yes", "11"];

    return { keys, values };
  }
  ```

  Upon executing the command `npm run call mint`, a new tokenized asset is minted. You can save the object's `ID` in the `.env` file for future reference.

- **`lock`**

  Locking the objects within the kiosk is crucial to prevent any unauthorized usage beyond the established policy.

  Upon executing the command `npm run call lock`, your newly minted tokenized asset is secured within your kiosk.

  Before running the command, make sure that the field `TOKENIZED_ASSET` within your `.env` file is populated with the object you intend to lock.

- **`mint-lock`**

  Executing the command `npm run call mint-lock` performs both the mint and lock functions sequentially, ensuring the minted asset is created and immediately locked within the kiosk.

- **`list`**

  Now that your tokenized asset is placed and locked within your kiosk, you can proceed to list it for sale.

  In the project's file `listItem.ts`, found in the directory `setup/src/functions`, you can adjust the code to specify the desired asset for listing.

  Code snippet to be modified:

  ```rust
  const SALE_PRICE = '100000';
    kioskTx
      .list({
          itemId,
          itemType,
          price: SALE_PRICE,
      })
      .finalize();
  ```

  By running the command `npm run call list`, your tokenized asset is listed and made available for sale.

- **`purchase`**

  When a user intends to purchase an item, it needs to be listed for sale. After the user selects the item to buy, they are required to modify the following snippet of code found in the file `purchaseItem.ts`, located in the `setup/src/functions` directory.

  ```rust
  const item = {
      itemType: tokenizedAssetType,
      itemId: tokenized_asset ?? tokenizedAssetID,
      price: "100000",
      sellerKiosk: targetKioskId,
  };
  ```

  Apart from specifying the item and its type, the buyer must set the specific price and the seller's kiosk ID to execute the purchase transaction successfully, accomplished by running `npm run call purchase`.

- **`join`**

  When you execute the command `npm run call join`, 2 specified tokenized assets of the FT type are merged together. Before running the command, make sure that the fields `FT1` and `FT2` within your `.env` file are populated with the objects you intend to merge.

- **`burn`**

  When you intend to burn a tokenized asset, execute the command `npm run call burn`. Following this action, the specified asset is destroyed. Before running the command, make sure that the field `TOKENIZED_ASSET` within your `.env` file is populated with the object you intend to burn.

- **`get-balance`**

  By executing the command `npm run call get-balance`, you can retrieve the balance value associated with the specified tokenized asset.

- **`get-supply`**

  By executing the command `npm run call get-supply`, you can retrieve the value representing the current circulating supply of the asset.

- **`get-total-supply`**

  By executing the command `npm run call get-total-supply`, you can retrieve the value representing the current circulating supply of the asset.
