---
title: Sponsored Transactions
description: Sponsored transactions let you pay gas fees on behalf of another user, reducing onboarding friction for users who don't own SUI.
keywords: [sponsored transactions, gas station, sponsor a transaction, pay gas for another address, GasData, user onboarding, gas fees]
---

A transaction on Sui requires a gas payment to execute. The payment is a list of `0x2::coin::Coin<0x2::sui::SUI>` objects.

Sponsored transactions let you pay gas fees on behalf of another user. This reduces onboarding friction because users can execute transactions without owning SUI or understanding gas mechanics. As a sponsor, you provide the gas payment object for the transaction.

## Roles

A sponsored transaction involves three roles:

- **User:** The entity that wants to execute a transaction.

- **Gas station:** The service that provides gas payment objects for user transactions.

- **Sponsor:** The entity that funds the gas station.

The gas station and sponsor are often the same entity. For example, a Web3 gaming company might run its own gas station to offer free-to-play experiences during user acquisition. Alternatively, the company could use a third-party gas station service instead of maintaining its own.

This guide assumes you operate your own gas station.

## App-specific sponsorship

You sponsor transactions only for a specific set of applications.

- **User-initiated:** You examine the transaction to verify it's within your approved applications before providing gas payment.

- **Sponsor-initiated:** You propose a transaction (such as a rewards claim or promotional offer) and the user decides whether to execute it.

## Wildcard sponsorship

You sponsor any valid transaction with few restrictions.

- **Gasless wallets:** You agree to sponsor any valid transaction your users propose.

- **Rewards or discounts:** You offer a wildcard gas payment that executes any transaction within the budget.

## Data structure

The following code block describes the `TransactionData` structure for sponsored transactions and `GasObject`. You can view the [source code](https://github.com/MystenLabs/sui/blob/224a28ed9dece21a952547896bd5d794bdf8b562/crates/sui-types/src/transaction.rs) in the Sui GitHub repository.

**`TransactionData` structure**
```rust
#[derive(Debug, PartialEq, Eq, Hash, Clone, Serialize, Deserialize)]
pub struct TransactionDataV1 {
    pub kind: TransactionKind,
    pub sender: SuiAddress,
    pub gas_data: GasData,
    pub expiration: TransactionExpiration,
}
```

**`GasData` structure**
```rust
#[derive(Debug, PartialEq, Eq, Hash, Clone, Serialize, Deserialize)]
pub struct GasData {
    pub payment: Vec<ObjectRef>,
    pub owner: SuiAddress,
    pub price: u64,
    pub budget: u64,
}
```

## Create a user-initiated sponsored transaction

A user-initiated sponsored transaction involves the following steps:

1. A user initializes a `GasLessTransactionData` transaction.

1. The user sends `GasLessTransactionData` to the sponsor.

1. The sponsor validates the transaction, constructs `TransactionData` with gas fees, and then signs `TransactionData`.

1. The sponsor sends the signed `TransactionData` and the sponsor `Signature` back to the user.

1. The user verifies and then signs `TransactionData` and sends the dual-signed transaction to Sui network through a full node or the sponsor.

### `GasLessTransactionData`

`GasLessTransactionData` is `TransactionData` without `GasData`. It is not a `sui-core` data structure; it is only an interface between user and sponsor.

The following example constructs a `GasLessTransactionData`  object:

```rust
pub struct GasLessTransactionData {
    pub kind: TransactionKind,
    sender: SuiAddress,
    â€¦
}
```

## Create a sponsor-initiated sponsored transaction  

A sponsor-initiated sponsored transaction involves the following steps:

1. A sponsor constructs a `TransactionData` object that contains the transaction details and associated gas fee data. The sponsor signs it to generate a `Signature` before sending it to a user. You can send unsigned `TransactionData` via email, SMS, or an application interface.

1. The user checks the transaction and signs it to generate the second `Signature` for the transaction.

1. The user submits the dual-signed transaction to a Sui full node or sponsor to execute it.

You can use a sponsor-initiated sponsored transaction as an advertiser, or to incentivize specific user actions without requiring the user to pay for gas fees.

## Create sponsored transactions using a `GasData` object

To use a `GasData` object to sponsor the gas fees for a transaction, create a `GasData` object that covers the fees determined for the transaction. The user doesn't need to know how much the fee is or approve it.

A sponsor transaction using a `GasData` object involves the following steps:

1. The sponsor provides a `GasData` object to a user.

1. The user constructs `TransactionData` and signs it to generate a `Signature`.

1. The user sends the `TransactionData` and the `Signature` to the sponsor.

1. The sponsor confirms the `TransactionData` and then signs it.

1. The sponsor submits the dual-signed `TransactionData` to a full node to execute the transaction.

## Example API endpoints

```rust
// User-initiated: receive GaslessTransaction, return signed TransactionData
pub fn request_gas_and_signature(gasless_tx: GaslessTransaction) -> Result<SenderSignedData, Error>;

// Wildcard: return a GasData object for the user
pub fn request_gas(/* requirements */) -> Result<GasData, Error>;

// Submit a single-signed transaction, sponsor signs and executes
pub fn submit_sole_signed_transaction(sole_signed_data: SenderSignedData) -> Result<(Transaction, CertifiedTransactionEffects), Error>;

// Submit a dual-signed transaction for execution
pub fn submit_dual_signed_transaction(dual_signed_data: SenderSignedData) -> Result<(Transaction, CertifiedTransactionEffects), Error>;
```

## Risk considerations

Sponsored transactions involve multiple parties, which introduces additional risks.

### Client equivocation

Client equivocation occurs when multiple valid transactions that share at least one owned object (such as a gas coin) at the same version are submitted to the network simultaneously.

When a transaction is submitted, validators lock the owned objects at their current versions. Each validator accepts only one transaction per object version and rejects the others. Because validators might receive competing transactions in different orders, they might accept different transactions. If no single transaction receives acceptance from at least two-thirds of validators, the owned objects remain locked until the end of the epoch.

Client equivocation is rare and usually results from buggy client software. However, sponsored transactions introduce counterparty risks:

- A malicious user could lock the gas station's gas coin by submitting a competing transaction that uses an owned object from the gas station's signed transaction.

- A malicious gas station could similarly lock user-owned objects.

To mitigate these risks:

- Gas stations should monitor user behavior and flag anomalies.

- Both users and sponsors should consider the reputation of their counterparty.

- Both parties must sign the entire `TransactionData`, including `GasData`. This prevents a third party (such as a malicious full node) from intercepting partially signed data and causing equivocation.

### Censorship

If you submit a dual-signed transaction through the sponsor or gas station rather than directly to a full node, the sponsor might delay or withhold the transaction from the network.

To avoid this risk, submit transactions directly to a full node.