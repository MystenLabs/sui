---
title: Intent Signing
description: Intent signing provides a compact domain separator to data signed by both user and authority signatures. Data that each signature commits to is called an intent message, which all signatures on Sui must include. 
keywords: [ intent, signing, intent signatures, intent message, domain separators, compact structs, signing standard, compact domain separator, user signatures, authority signatures, proof of possession, generate proof of possession ]
---

An intent is a compact struct that serves as the domain separator for a message that a signature commits to. The data that the signature commits to is an intent message. All signatures in Sui must commit to an intent message rather than the message itself.

The intent signing standard provides a compact domain separator to the data being signed for both user signatures and authority signatures. It has several benefits:

- The intent scope is replaced by a `u8` representation instead of a Rust struct tag name string.

- In addition to the intent scope, you can commit other important domain separators as well (such as intent version and app ID).

- The data itself no longer needs to implement the `Signable` trait, it just needs to implement `Serialize`.

- All signatures can adopt the same intent message structure, including both user signatures (only to commit to `TransactionData`) and authority signature (commits to all internal intent scopes such as `TransactionEffects`, `ProofOfPossession`, and `SenderSignedTransaction`).

## Structs

The `IntentMessage` struct consists of the intent and the serialized data value.

```rust
pub struct IntentMessage<T> {
  pub intent: Intent,
  pub value: T,
}
```

To create an intent struct, include the `IntentScope` (type of message), `IntentVersion` (version the network supports), and `AppId` (application the signature refers to).

```rust
pub struct Intent {
  scope: IntentScope,
  version: IntentVersion,
  app_id: AppId,
}
```

For detailed field definitions, see the enum definitions in the source code:

<ImportContent source="crates/shared-crypto/src/intent.rs" mode="code" enumeration="IntentScope,IntentVersion,AppId,HashingIntentScope" />

The serialization of an `Intent` is a 3-byte array where each field is represented by a byte.

The serialization of an `IntentMessage<T>` is the 3 bytes of the intent concatenated with the BCS serialized message.

## User signature

To create a user signature, construct an intent message first, then create the signature over the 32-byte Blake2b hash of the BCS serialized value of the intent message of the transaction data (`intent || message`).

The following examples demonstrate this:

<Tabs groupId="language">

<TabItem value="rust" label="Rust">

```rust
let intent = Intent::default();
let intent_msg = IntentMessage::new(intent, data);
let signature = Signature::new_secure(&intent_msg, signer);
```

</TabItem>

<TabItem value="typescript" label="TypeScript">

```typescript
const intentMessage = messageWithIntent('TransactionData', transactionBytes);
const signature = await this.sign(intentMessage);
```

</TabItem>
</Tabs>

Under the hood, the `new_secure` method in Rust and the `signData` method in TypeScript do the following:

1.  Serialize the intent message as the 3-byte intent concatenated with the BCS serialized bytes of the transaction data.

1.  Apply Blake2b hash to get the 32-byte digest.

1.  Pass the digest to the signing API for each corresponding scheme of the signer. The supported signature schemes are pure Ed25519, ECDSA Secp256k1, and ECDSA Secp256r1. See [Sui Signatures](/concepts/transactions/transaction-auth.mdx#signature-requirements) for requirements of each scheme.

## Authority signature

The authority signature is created using the protocol key. The data that it commits to is also an intent message `intent || message`. See all available intent scopes [in the source code](https://github.com/MystenLabs/sui/blob/0dc1a38f800fc2d8fabe11477fdef702058cf00d/crates/sui-types/src/intent.rs#L66).

### Generating proof of possession for an authority

When an authority requests to join the network, the protocol public key and its proof of possession (PoP) are required. PoP is required to prevent [rogue key attack](https://crypto.stanford.edu/~dabo/pubs/papers/BLSmultisig.html).

The proof of possession is a BLS signature created using the authority protocol private key, committed over the following message: `intent || pubkey || address || epoch`. The values are as follows:

- `intent`: Serialized to `[5, 0, 0]` representing an intent with scope as `Proof of Possession`, `version` as `V0`, and `app_id` as `Sui`.

- `pubkey`: The serialized public key bytes of the authority BLS protocol key.

- `address`: The account address associated with the authority account key.

- `epoch`: Serialized to `[0, 0, 0, 0, 0, 0, 0, 0]`.

To generate a proof of possession in Rust, see the implementation at `fn generate_proof_of_possession`. For test vectors, see `fn test_proof_of_possession`.