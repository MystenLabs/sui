---
title: Package Management System
description: Learn how to use the Move package manager system.
keywords: [ move, move reference, package management, package manager, move packages, move package management ]
pagination_prev: null
---

## Move packages

A Move package is a collection of Move modules that is published as a single
object. Packages can depend on other packages, and can be upgraded over time.

This document describes how the package manager works and how you can use it.

NEW: Version TODO introduced major changes to the Move package system. This
document describes the new system; see TODO for the documentation on the old
system, and TODO for a description of the differences and how to migrate to
the new system.

## Package-related files

This section gives a brief overview of the files that the package system uses;
the details of the file formats are below.

Package authors configure their packages by providing a manifest file (called
`Move.toml`) in the root of the package directory. This file contains metadata
about the package (such as its name) as well as the list of dependencies.

NEW: the old system wasn't as clear about when it would repin, it repinned most
of the time

When you build your Move package for the first time, the package system uses
the information in the manifest file to find the source code for the
dependencies. It stores the exact versions of the dependencies into a lockfile
(called `Move.lock`); this process is called pinning. For example, the manifest
may specify a dependency on a branch of a git repository, but the package
system will pin that dependency to a specific commit.

You should commit the `Move.lock` file to source control so that your
collaborators, CI jobs, and future users who want to verify the source code are
all using the same dependency versions. The package system will only repin your
dependencies if your manifest file changes or if you run the `sui move
update-deps` command.

NEW: in the old system, the `Published.toml` information was stored in `Move.lock`,
NEW: the old system didn't have ephemeral publication

When you publish or upgrade your package on a persistent network like `mainnet`
or `testnet`, the package system will create or update a publication file,
called `Published.toml`. This file contains information about publications to
persistent networks, such as their on-chain addresses and upgrade capabilities.
You should commit the publication file to source control so that other packages
can depend on your package. See TODO below for details of the publication file
format.

If you wish to publish your package to an ephemeral network like `localnet` or
`devnet`, you can use the `test-publish` command; this will read dependency
addresses from an ephemeral publication file (typically called
`Pub.<env>.toml`), and will write the package's published address back to that
file. See TODO below for details of the ephemeral publication file format.

Normal publication files and ephemeral publication files contain different
information: a normal publication file only contains addresses for your package
(not your dependencies), but it contains records for each network it has been
published to; ephemeral publication files may contain entries for dependencies
as well as the root package, but only contains publication information for a
single network.

You should not commit ephemeral publication files to source control - they
contain information that is only relevant in a local development environment.
If you do want to maintain non-ephemeral publications on a network other than
mainnet or testnet, you can add a custom environment to your manifest; see the
section on environments.

## Dependencies

To add a dependency on another project, you can add a line to the `[dependencies]` section of your manifest. For
example, to depend on the mvr package `@potatoes/ascii`, you would write:

```toml
[package]
name = "example"

[dependencies]
ascii = { r.mvr = "@potatoes/ascii" }
```

You can then refer to modules in the `ascii` package in your Move source code:

```move
module example::example_module;

use ascii::ascii;
use ascii::char;
```

### Dependency types

There are four types of dependencies that you can use: Move registry, local, git, and system.

The preferred way to depend on another package is using the Move registry, also
called `mvr` (pronounced "mover"). The Move registry is an on-chain database
linking published packages with their source code. To depend on a package with
mvr name `@example/package`, add `example = { r.mvr = "@example/package" }` to your
`[dependencies]` section.

Local dependencies are useful when you are want to depend on another package in
the same repository. For example, if your repository contains Move packages in
directories `packages/a` and `packages/b` and you want package `a` to depend on
package `b`, then you would add `b = { local = "../b" }` to
`packages/a/Move.toml`.

Git dependencies can be used to depend on packages stored in git repositories.
A git dependency must include the repository URL, the subdirectory inside the
repository that contains the package, and a revision (branch, tag, or
40-character commit hash[^short-sha]). For example, to add a dependency to the
usdc package, you could add the following to your manifest[^toml-tables]:

```toml
[dependencies]
usdc = { git = "https://github.com/circlefin/stablecoin-sui.git", subdir = "packages/usdc", rev = "master" }
```

[^toml-tables]: Manifest files are written in TOML, which also allows you to expand inline tables. The above is equivalent to:
  ```toml
  [dependencies.usdc]
  git = "https://github.com/circlefin/stablecoin-sui.git"
  subdir = "packages/usdc"
  rev = "master"
  ```

[^short-sha]: Although you can use a shortened commit hash, doing so requires
downloading the entire git history, so it is much less efficient than including the full 40-character hash.

NEW: system dependencies don't exist in the old system, and implicit dependencies work differently

There are a handful of packages that are built into Sui; the `system`
dependency type can be used to depend on these packages. The available system
packages are `std`, `sui`, `sui_system`, `bridge`, and `deepbook`. However:

 - The `std` and `sui` packages are implicitly included unless you write
   `implicit-dependencies = false` in your `[package]` section, so you should
   not need to explicitly include them.

 - The `deepbook` system package is for the deprecated DeepBook version 2; new
   applications should use DeepBook version 3 by adding `deepbook = {mvr = "@deepbook/core"}`

To include a system dependency, write `{ system = "<name>" }`. For example, to use `sui_system`,
you would add `sui_system = { system = "sui_system" }` to your `[dependencies]` section.

### Additional dependency fields

There are additional fields that can be used with any of the four dependency
types: `override`, `modes`, and `rename-from`.

NEW: rename-from doesn't exist in the old system

The `rename-from` field is used for depending on multiple packages that have
the same name. By default, the package system checks that the name you give to
a dependency is the same as the name that the dependency gives itself. However,
the `rename-from` field lets you change the name you use. For example, if `@a/math` and `@b/math`
both refer to packages named `math`, you could depend on both of them by writing

```toml
[dependencies]
math_a = { r.mvr = "@a/math", rename-from = "math" }
math_b = { r.mvr = "@b/math", rename-from = "math" }
```

Then your Move code could refer to both of them:

```move
use math_a::signed;
use math_b::muldiv;
```

The `override` flag is used for combining packages that depend on different
versions of the same package. The Move package management system requires that
there is only one version of each package in use within a package. For example,
suppose that your package `a` wants to depend on packages `b` and `c`, but that
`b` depends on version 1 of `d`, and `c` depends on version `2` of `d`. The
package system will not allow this by default, because running code in package
`a` would require both versions 1 and 2 of `d`.

By adding `override = true` to a dependency, you force all of your dependencies
to use the specified version of the dependency. In the above example, you could
add an override dependency on `d` version 2, which would cause `b` to use
version 2 of `d` instead of version 1.

You are only allowed to override packages to newer versions; in the example you
could not add an override dependency on version 1 of `d` because it would force
`c` to downgrade.

The `modes` field lets you leave out a dependency if the compiler is invoked
with a different mode. If no `modes` field is provided, the dependency is
included in all modes. For example, to include the `ascii` dependency for
testing only, you would write `ascii = { r.mvr = "@potatoes/ascii", modes =
["test"] }`; this dependency will be included whenever you run `sui move test`
or pass `-m test` to any `sui move` command.

NOTE: there is not currently a way to have different dependencies in different
modes, only to include or omit a dependency based on the mode.

## Environments

NEW: the old package system only maintains different publication addresses for
different chain IDs; most of the features in this section are new

Move packages are commonly published on both `mainnet` and `testnet`, and often
there are different versions published to each of the networks. The Move
package system allows you to manage multiple deployments using environments.

Building packages is always done relative to a build environment. The
environment determines which dependency packages to use, which addresses to
use, and other information that changes from network to network. By default, the
command line uses your active CLI environment to choose the build environment,
but this can be overridden with the `-e <env>` option.

By default, the available environments are `mainnet` and `testnet`, but you can
add additional environments by including an `[environments]` section in your manifest.
For example, if you wanted to maintain a public deployment of your package on `devnet`,
you could add a `devnet` entry to your manifest:

```toml
[environments]
devnet = "aba3e445"
```

The right-hand side of the entry is the chain identifier for the network; you
can find the chain ID using `sui client chain-identifier`. The chain identifier
is used to ensure dependencies agree on the meaning of the environment name, and
to reset package addresses if the network is wiped and restarted.

NOTE: you should only include an environment in your manifest if you expect
other packages to link against your package on that network. You will usually
not want to include local networks in your manifest, since they are typically
short-lived and private. Instead, you should consider using the `test-publish`
command to publish your package and its dependencies on a local network. The
`test-publish` command gives you much more flexibility to manage your deployment.

Environments may have the same chain ID, and this can be useful if you wish to
maintain multiple deployments of your package on the same network. For example,
if you want to maintain an alpha and a beta deployment of your package on testnet,
you could add separate environments:

```toml
[environments]
testnet_alpha = "4c78adac"
testnet_beta = "4c78adac"
```

This will cause the package system to maintain separate published addresses for
the two environments in `Published.toml`, and allow you to specify different
dependencies for the different package versions.

Dependencies can be replaced in different environments using the
`[dep-replacements.<env>]` section of the manifest. For example, if you want to
use different branches of the `codec` library for mainnet and testnet, you could write

```toml
[dependencies]
codec = { git = "https://github.com/sui-potatoes/app.git", subdir = "packages/codec", rev = "codec@testnet-v2" }

[dep-replacements.testnet]
codec = { git = "https://github.com/sui-potatoes/app.git", subdir = "packages/codec", rev = "codec@mainnet-v2" }
```

This is easier to achieve if you are using `mvr`, which automatically resolves the mainnet
or testnet version depending on the build environment:

```toml
[dependencies]
codec = { r.mvr = "@potatoes/codec" }
```

There are additional fields that you can provide for dependencies in the
`dep-replacements` section that only make sense for a specific environment:
`use-environment`, `published-at`, and `original-id`.

The `use-environment` field indicates which of the dependency's environments
should be used. For example, if you want to depend on the `testnet_beta`
environment, of a dependency for your `testnet` environment, you could add
`use-environment = "testnet_beta"` to the dependency in the
`[dep-replacements.testnet]` section.

The `published-at` and `original-id` fields are only useful in the case where a
dependency has not properly published their `Published.toml` file (for example,
many legacy packages only include the address for a single environment). In
this case, you can override the addresses that your package uses for the
dependency.

The `published-at` field should contain the address of the package version that
you want to use; the `original-id` field should contain the address of the
first version of the package (this is used by the package system to determine
whether two packages are different versions of the same package or are
different packages altogether). If you include either of these fields, you must
include both of them.

## Package-related commands

### Building and Testing (`sui move build`, `sui move test`)

Whenever you run `sui move build` or `sui move test`, the system will ensure
that you have all dependencies cached in your `~/.move` directory. It will first
check whether the lockfile is up-to-date, and if it is not, it will repin all
of the dependencies for your build environment. It will then check whether the
packages are cached, and if not it will download them.

Since the system always fetches after pinning, you never need to go to the
network unless a dependency needs to be repinned because the manifest changed
or you ran `update-deps`.

### Updating dependencies (`sui move update-deps`)

Run `sui move update-deps` to repin all of your dependencies. This will not
change your manifest file, it will only redownload the latest versions that
are compatible with what you have written.

### Publication and upgrading (`sui client publish`, `sui client upgrade`)

During normal publication and upgrade (`sui client publish` or `sui client
upgrade`), the system rechecks that the dependencies are published on the given
network and that the relevant chain IDs are consistent. The system also ensures
that the additional on-chain linkage requirements are satisfied. For example,
on-chain packages can have extra dependencies in their linkage that they don't
actually use, so the system needs to include the on-chain linkages.

The system updates the publication file (`Published.toml`) to include the
updated publication information. The publication file contains an entry for
each environment that has a published version of the package. The entry
contains the published address, original id (the address of the first version
of the package), the version number, the upgrade capability, and information
about the build configuration that can be used for source validation. Here
is an example publication file:

```toml
[published.mainnet]
chain-id = "TODO"
published-at = "TODO"
original-id = "TODO"
version = 2
toolchain-version = "sui-1.62.1"
build-config = "TODO"
upgrade-capability = "TODO"

[published.testnet]
chain-id = "TODO"
published-at = "TODO"
original-id = "TODO"
version = 3
toolchain-version = "sui-1.62.4"
build-config = "TODO"
upgrade-capability = "TODO"
```

You can also publish or upgrade using the `sui client ptb` command; see TODO for details.

### Ephemeral publication (`sui client test-publish`)

The package manager supports ephemeral publication of a package and its
dependencies for testing, for example, on localnet. The ephemeral publish
command works like a normal publish, except that the system reads the
publication addresses for packages from and writes them to a separate file.

The format of an ephemeral publication file is as follows:

```toml
# generated by move
# this file contains metadata from ephemeral publications
# this file should not be committed to source control

build-env = "mainnet"
chain-id = "localnet chain ID"

[[published]]
source = { root = true }
published-at = "..."
original-id = "..."
upgrade-cap = "..."

[[published]]
source = { git = "...", rev = "...", path = "..." }
published-at = "0x000000000000000000000000000000000000000000000000000000000000cccc"
original-id = "0x000000000000000000000000000000000000000000000000000000000000cc00"
upgrade-cap = "0x000000000000000000000000000000000000000000000000000000000011cc00"

[[published]]
source = { local = "../foo" }
published-at = "0x0000000000000000000000000000000000000000000000000000000000001234"
original-id = "0x0000000000000000000000000000000000000000000000000000000000005678"
upgrade-cap = "0x000000000000000000000000000000000000000000000000000000000022cc00"
```

The entries are identified by the `source` field; these fields are pinned
dependencies, so they may be different from the dependencies written in your
manifest file. They should match the `source` fields in the lockfile however.

If an entry for a dependency is missing, the `test-publish` command will
attempt to take the published address for the dependency from the build
environment. This will produce an error if the dependency is not published on
the ephemeral environment (TODO: write the exact error message, and maybe make
it better - people will probably google this).

NOTE: In the future we plan to have the `test-publish` tool automatically
publish unpublished dependencies as well but this functionality is not
currently available.

The command `sui client test-publish <pubfile> --build-env <env>` builds the root package for the `<env>` environment and then publishes it to a chain using the addresses from the ephemeral publication file `<pubfile>`.

If `<pubfile>` is omitted, it defaults to `Pub.<env-name>.toml` where `<env-name>` is the name of the active CLI environment, irrespective of the environments defined in the manifest. This file contains the addresses to use for publication.

If `--build-env <env>` is omitted, it defaults to the `build-env` name of the file at `<file>`. If that is missing, the system errors. The build environment determines how the system resolves dependencies for the package.

If `--build-env <env>` is present and different from the `build-env` in the file, the system fails.

If `<file>` exists and `chain-id` doesn't match, the system doesn't fail immediately, but if you have dependencies are published on a network with a different chain ID, the publication will fail.

### Adding to the Move Registry (mvr)

Once you have published your package, you should consider adding it to the Move
registry so that others can easily depend on it. See TODO for details.

## Interacting with Legacy Packages

TODO

----

## Example manifest files

This section provides sample manifest files for you to use as templates in your project.

For a basic project that only depends on `sui` and `std`, the minimal lockfile is

```toml
[package]
name = "example"
```

For a package that has a mvr dependency and a git dependency (with different
mainnet and testnet branches):

TODO: usdc doesn't actually have different tags; find a package that does

```toml
[package]
name = "example"

[dependencies]
ascii = { r.mvr = "@potatoes/ascii" }
usdc = { git = "https://github.com/circlefin/stablecoin-sui.git", subdir = "packages/usdc", rev = "releases/testnet" }

[dep-replacements.mainnet]
usdc = { git = "https://github.com/circlefin/stablecoin-sui.git", subdir = "packages/usdc", rev = "releases/mainnet" }
```

For a package that defines a `testnet_alpha` environment:

```toml
[package]
name = "example"

[environments]
testnet_alpha = "4c78adac"

[dependencies]
ascii = { r.mvr = "@potatoes/ascii" }
usdc = { git = "https://github.com/circlefin/stablecoin-sui.git", subdir = "packages/usdc", rev = "releases/testnet" }

[dep-replacements.mainnet]
usdc = { git = "https://github.com/circlefin/stablecoin-sui.git", subdir = "packages/usdc", rev = "releases/testnet" }

[dep-replacements.testnet_alpha]
ascii = { use-environment = "ascii" }
usdc = { use-environment = "testnet" }
```
