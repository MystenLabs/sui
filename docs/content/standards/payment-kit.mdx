---
title: Payment Kit Standard
description: The Sui Payment Kit is a robust, open-source payment processing toolkit that provides secure payment verification, receipt management and duplicate prevention for applications built on the Sui blockchain.
sidebar_label: Payment Kit
keywords:
  [
    payment processing,
    payment verification,
    payment receipts,
    duplicate prevention,
    payment registry,
    ephemeral payments,
    multi-coin support,
    payment kit,
    payment standard,
    sui payments,
  ]
pagination_prev: null
---

The Sui Payment Kit is a Move smart contract framework that provides secure, flexible payment processing capabilities on the Sui blockchain. The kit offers both persistent and ephemeral payment options, event-driven architecture and comprehensive duplicate prevention mechanisms.

The Payment Kit standardizes payment processing on Sui, enabling developers to build robust payment flows without reimplementing common payment verification and receipt management logic. Applications using the Payment Kit benefit from battle-tested security patterns and consistent payment handling across the ecosystem.

Source code: [github.com/MystenLabs/sui-payment-kit](https://github.com/MystenLabs/sui-payment-kit)

## Key features

The Payment Kit provides the following core capabilities:

- **Secure payment processing**: Validates payment amounts and transfers coins safely.
- **Payment registries**: Optional persistent storage for payment receipts with duplicate detection.
- **Flexible receipt management**: Generates receipts for payment tracking and verification.
- **Event-driven architecture**: Emits events for off-chain tracking and integration.
- **Multi-coin support**: Works with any Sui coin type.

## Architecture components

The Payment Kit consists of the following main components:

### Payment processing core

Handles coin transfers, payment validation and receipt generation. The core validates that:

- Payment amounts match expected values
- Coins have sufficient balance
- Transfers complete successfully
- Receipts contain accurate payment information

### Registry system

Optional persistent storage that tracks payment history and prevents duplicate payments. Registries provide:

- Payment record storage with composite keys
- Configurable expiration policies for payment records
- Withdrawal capabilities for accumulated funds
- Administrative controls via capabilities

## Core concepts

### Payment modes

The Payment Kit supports two payment processing modes:

**Registry payments**: Process payments through a `PaymentRegistry` with duplicate prevention and persistent receipts. Use this mode when:

- You need to prevent duplicate payments
- Payment history must be tracked
- Compliance or auditing requires payment records
- Funds should accumulate in a managed registry

**Ephemeral payments**: Process one-time payments without persistent storage. Use this mode when:

- Duplicate prevention is not enforced

### Duplicate prevention

Duplicate prevention is enforced when processing payments via a `PaymentRegistry`. The system uses a composite `PaymentKey` derived from:

- **Nonce**: Unique identifier for each payment `(UUIDv4)`
- **Amount**: Payment value in coin units
- **Coin type**: The specific coin type
- **Receiver address**: Destination address for the payment

This composite key ensures that the same payment cannot be processed twice, even if individual components (like amount or receiver) are reused across different payments.

### Payment receipts

Every processed payment generates a `PaymentReceipt` object containing:

- Payment nonce for reference
- Amount paid
- Coin type used
- Receiver address
- Timestamp of payment
- Registry information (for registry payments - not applicable to ephemeral payments)

Receipts serve as proof of payment and can be used for off-chain verification, accounting, or integration with other systems.

## Working with payment registries

### Creating a registry

To create a new payment registry, you need to provide a `name` which is simply a acsii based string that is used to derive an address for the registry. In addition to a name, the package `Namespace` object must also be provided. Namespaces provide a higher-order organizational structure for managing multiple payment registries.

#### Namespace objects

`mainnet: 0xccd3e4c7802921991cd9ce488c4ca0b51334ba75483702744242284ccf3ae7c2`

`testnet: 0xa5016862fdccba7cc576b56cc5a391eda6775200aaa03a6b3c97d512312878db`

```move
module sui::payment_kit;

public fun create_registry(
    namespace: &mut Namespace,
    name: String,
    ctx: &mut TxContext
)
```

This function creates a `PaymentRegistry` and a `RegistryAdminCap` for administrative control. The `RegistryAdminCap` is initially owned by the creator and can be shared or transferred as needed.

### Sharing a registry

After creating a registry, you can make it a shared object for public use:

```move
module sui::payment_kit;

public fun share(registry: PaymentRegistry)
```

Shared registries allow any address to process payments through them, while administrative functions remain protected by the `RegistryAdminCap`.

### Processing registry payments

Process payments through a registry with duplicate prevention:

```move
module sui::payment_kit;

public fun process_registry_payment<T>(
    registry: &mut PaymentRegistry,
    nonce: String,
    payment_amount: u64,
    coin: Coin<T>,
    receiver: Option<address>,
    clock: &Clock,
    ctx: &mut TxContext
)
```

**Parameters:**

- `registry`: Mutable reference to the payment registry
- `nonce`: Unique payment identifier (prevents duplicates)
- `payment_amount`: Expected payment amount in coin units
- `coin`: Payment coin object
- `receiver`: Optional receiver address (if `None`, funds stay in registry)
- `clock`: Sui clock object for timestamping
- `ctx`: Transaction context

The function:

1. Verifies the payment amount matches the coin value
2. Checks for duplicate payments using the composite key
3. Records the payment in the registry
4. Transfers funds to receiver or retains in registry (based on configuration)
5. Generates and returns a `PaymentReceipt`
6. Emits a payment event

**Error conditions:**

- `EDuplicatePayment`: Payment with same composite key already exists
- `EPaymentAmountMismatch`: Coin value doesn't match expected amount

### Managing payment records

Delete expired payment records to free storage:

```move
module sui::payment_kit;

public fun delete_payment_record<T>(
    registry: &mut PaymentRegistry,
    payment_key: PaymentKey<T>,
    ctx: &mut TxContext
)
```

Records can only be deleted after they expire based on the registry's configured expiration duration. Create a `PaymentKey` using the `create_payment_key` function with the original payment parameters.

### Configuring registries

Registry administrators can update configuration settings using the `RegistryAdminCap`:

**Set expiration duration:**

```move
module sui::payment_kit;

public fun set_config_epoch_expiration_duration(
    registry: &mut PaymentRegistry,
    cap: &RegistryAdminCap,
    epoch_expiration_duration: u64,
    ctx: &mut TxContext
)
```

**Set Registry to receive funds:**

```move
module sui::payment_kit;

public fun set_config_registry_managed_funds(
    registry: &mut PaymentRegistry,
    cap: &RegistryAdminCap,
    registry_managed_funds: bool,
    ctx: &mut TxContext
)
```

When `registry_managed_funds` is `true`, payments accumulate in the registry for later withdrawal. When `false`, payments transfer immediately to receivers.

### Withdrawing from registry

If a Registry is set to manage funds, an administrator can withdraw accumulated funds:

```move
module sui::payment_kit;

public fun withdraw_from_registry<T>(
    registry: &mut PaymentRegistry,
    cap: &RegistryAdminCap,
    ctx: &mut TxContext
)
```

This function requires the `RegistryAdminCap` and returns all accumulated coins of type `T` from the registry. Only use this when the registry is configured to retain funds (controlled by the `registry_managed_funds` configuration setting).

## Processing ephemeral payments

For scenarios that don't require duplicate prevention or persistent records, use ephemeral payments:

```move
module sui::payment_kit;

public fun process_ephemeral_payment<T>(
    nonce: String,
    payment_amount: u64,
    coin: Coin<T>,
    receiver: address,
    clock: &Clock,
    ctx: &mut TxContext
)
```

Ephemeral payments:

- Do not check for duplicates
- Do not store payment records on-chain
- Transfer funds immediately to the receiver
- Generate receipts for the transaction
- Emit payment events for off-chain tracking
- Have lower gas costs than registry payments

This mode is ideal for:

- Duplicate prevention is not required
- Applications with external payment tracking systems

## Configuration system

The Payment Kit uses a type-safe configuration system supporting multiple value types:

### Supported value types

The `Value` enum supports the following types:

- `U64(u64)`: Unsigned 64-bit integers
- `Address(address)`: Sui addresses
- `String(string::String)`: UTF-8 strings
- `AsciiString(ascii::String)`: ASCII strings
- `Bool(bool)`: Boolean values
- `Bytes(vector<u8>)`: Arbitrary byte vectors
- `Type(TypeName)`: Move type names

### Creating configuration values

```move
module sui::config;

// Create typed values
public(package) fun new_u64(value: u64): Value
public(package) fun new_address(value: address): Value
public(package) fun new_string(value: string::String): Value
public(package) fun new_ascii_string(value: ascii::String): Value
public(package) fun new_bool(value: bool): Value
public(package) fun new_bytes(value: vector<u8>): Value
public(package) fun new_type(value: TypeName): Value
```

### Converting configuration values

```move
module sui::config;

// Convert to typed values
public(package) fun as_u64(value: Value): u64
public(package) fun as_address(value: Value): address
public(package) fun as_string(value: Value): string::String
public(package) fun as_ascii_string(value: Value): ascii::String
public(package) fun as_bool(value: Value): bool
public(package) fun as_bytes(value: Value): vector<u8>
public(package) fun as_type(value: Value): TypeName
```

Configuration functions are package-level access only, ensuring type safety and preventing external modification.

## Key structures

### Namespace

Represents the higher-order namespace for organizing payment registries:

```move
public struct Namespace has key, store {
    id: UID,
    // Internal fields for registry management
}
```

### PaymentRegistry

Tracks payments and receipts with duplicate prevention:

```move
public struct PaymentRegistry has key {
    id: UID,
    // Configuration and payment records
}
```

### RegistryAdminCap

Provides administrative capabilities for a specific registry:

```move
public struct RegistryAdminCap has key, store {
    id: UID,
    // Registry reference
}
```

### PaymentReceipt

Contains details of a processed payment:

```move
public struct PaymentReceipt has key, store {
    id: UID,
    nonce: String,
    amount: u64,
    receiver: address,
    timestamp: u64,
    // Additional receipt information
}
```

### PaymentKey

Unique key for identifying payment records:

```move
public struct PaymentKey<phantom T> has copy, drop, store {
    // Composite key components
}
```

Create payment keys using:

```move
module sui::payment_kit;

public fun create_payment_key<T>(
    nonce: String,
    payment_amount: u64,
    receiver: address
): PaymentKey<T>
```

### PaymentRecord

Internal structure storing payment record information:

```move
public struct PaymentRecord has store {
    // Payment metadata and expiration
}
```

## Events

The Payment Kit emits events for off-chain tracking and integration. Payment processing functions emit events containing:

- Payment nonce
- Payment amount
- Coin type
- Receiver address
- Timestamp
- Registry information (for registry payments)

Use these events to:

- Track payment history off-chain
- Trigger external workflows
- Update application state
- Generate reports and analytics
- Integrate with accounting systems

## Error codes

The Payment Kit defines the following error conditions:

- **Duplicate payment detection**: Payment with the same composite key already processed
- **Payment amount mismatch**: Coin value doesn't match expected payment amount
- **Payment record not found**: Attempted to access non-existent payment record
- **Payment record not expired**: Attempted to delete a record before expiration
- **Unauthorized admin**: Operation requires `RegistryAdminCap`
- **Registry already exists**: Attempted to create duplicate registry in namespace
- **Invalid registry name**: Registry name doesn't meet requirements

## Related links

<RelatedLink to="/concepts/sui-move-concepts/derived-objects.mdx" />
