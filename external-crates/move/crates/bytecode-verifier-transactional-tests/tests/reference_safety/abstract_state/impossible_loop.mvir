// recursive types are not possible currently in Move, but this mimics the field extensions
// we might see with one, if using functions

//# publish

module 0x2.loopy {

struct List has copy, drop {
    dummy: bool,
}

struct Node has copy, drop {
    val: u8,
    next: Self.List,
}

node(l: &mut Self.List): &mut Self.Node {
label l0:
    abort 0;
}

is_end(l: &Self.List): bool {
label l0:
   abort 0;
}


t(cond: bool, s:  Self.List): Self.List {
    let cur: &mut Self.List;
label l0:
    cur = &mut s;
label loop_cond:
    jump_if_false (move(cond)) loop_end;
label loop_body:
    // we don't see `Node::next` in the abstract state, only .*
    cur = &mut (Self.node(move(cur))).Node::next;
    cond = Self.is_end(freeze(copy(cur)));
    jump loop_cond;
label loop_end:
    return *move(cur);
}

}

//# view-abstract-state 0x2::loopy::t
