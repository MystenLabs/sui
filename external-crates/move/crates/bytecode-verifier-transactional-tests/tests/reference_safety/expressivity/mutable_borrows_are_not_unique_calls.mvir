// mutable borrows are not unique

//# publish
module 0x4.call {

    struct S has copy, drop { f: u64 }

    borrow_f(s: &mut Self.S): &mut u64 {
    label b0:
        return &mut move(s).S::f;
    }

    create(s: &mut Self.S) {
        let call: &mut u64;
        let f: &mut u64;
    label b0:
        // we can create multiple mutable references, even with a call, as long as the argument
        // to the call does not have any extensions at the time of the call (and as long as it does
        // not overlap with any other arguments)

        // if we swap the call with the field borrow, this will error
        call = Self.borrow_f(copy(s));
        f = &mut copy(s).S::f;
        return;
    }

}

//# publish
module 0x5.call_and_write_invalid {

    struct S has copy, drop { f: u64 }

    borrow_f(s: &mut Self.S): &mut u64 {
    label b0:
        return &mut move(s).S::f;
    }

    write(s: &mut Self.S) {
        let call: &mut u64;
        let f: &mut u64;
    label b0:
        // While mutable references are not unique, and we can create all sorts of overlaps, that
        // does not mean that we can write to all of them.
        // We cannot write to either call or f since we do not know the relationship between them.
        // While it is "safe" in this case, we do not look at the type layout for that information.
        // It could be the case that f extends call, and that call extends f.
        call = Self.borrow_f(copy(s));
        f = &mut copy(s).S::f;
        *copy(call) = 0;
        *copy(f) = 0;
        return;
    }

}

//# publish
module 0x6.call_and_write_valid {

    struct S has copy, drop { f: u64 }

    borrow_f(s: &mut Self.S): &mut u64 {
    label b0:
        return &mut move(s).S::f;
    }

    write(s: &mut Self.S) {
        let call: &mut u64;
        let f: &mut u64;
    label b0:
        // If however we free the call's return value before borrowing f, this is valid.
        call = Self.borrow_f(copy(s));
        *move(call) = 0; // the move frees the value
        f = &mut copy(s).S::f;
        *copy(f) = 0;
        return;
    }

}
