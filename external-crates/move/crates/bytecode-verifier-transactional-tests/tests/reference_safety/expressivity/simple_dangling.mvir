// simple tests that the verifier stops the creation of a dangling reference

//# publish
module 0x2.field {
    struct S has copy, drop { f: u64 }
    t(s: &mut Self.S) {
        let f: &u64;
    label b0:
        f = &copy(s).S::f;
        *move(s) = S { f: 0 };
        return;
    }
}

//# publish
module 0x3.nested_field {
    struct S has copy, drop { f: u64 }
    struct P has copy, drop { s: Self.S }
    t(p: &mut Self.P) {
        let s: &mut Self.S;
        let f: &u64;
    label b0:
        s = &mut copy(p).P::s;
        f = &copy(s).S::f;
        *move(p) = P { s: S { f: 0 } };
        return;
    }
}

//# publish
module 0x4.vector {
    t(v: &mut vector<u64>) {
        let r: &mut u64;
    label b0:
        r = vec_mut_borrow<u64>(copy(v), 0);
        *move(v) = vec_pack_0<u64>();
        return;
    }
}

//# publish
module 0x5.simple_call {
    f(r: &mut u64): &u64 {
    label b0:
        return freeze(move(r));
    }

    t() {
        let a: u64;
        let m: &mut u64;
        let i: &u64;
    label b0:
        a = 0;
        m = &mut a;
        i = Self.f(copy(m));
        *copy(m) = 0;
        return;
    }
}



//# publish
module 0x5.field_call {
    struct S has copy, drop { f: u64 }

    f(r: &mut Self.S): &u64 {
    label b0:
        return &move(r).S::f;
    }

    t(s: &mut Self.S) {
        let f: &u64;
    label b0:
        f = Self.f(copy(s));
        *copy(s) = S { f: 0 };
        return;
    }
}
