//# publish
module 0x42.M1 {
    struct S<T: copy + drop> has copy, drop { t: T }

    // it would be bad if this worked because T could be (e.g.) a coin
    // should get flagged w/ constraint not satisfied--T does not have copy
    public bad_sig<T>(v: vector<Self.S<T>>): vector<Self.S<T>> {
    label b0:
        return copy(v);
    }
}

//# publish
module 0x42.M2 {
    struct S<T: drop> has drop { t: T }

    // it would be bad if this worked because T could be (e.g.) a hot potato
    public bad_sig<T>(v: vector<Self.S<T>>) {
    label b0:
        return;
    }
}

//# publish
module 0x42.M3 {
    struct S<T: copy> { t: T }

    public bad_sig<T>(s: vector<Self.S<T>>) { // should get flagged w/ constraint not satisfied
    label b0:
        return;
    }

    public call(): vector<Self.S<u64>> {
    let x: vector<Self.S<u64>>;
    label b0:
        x = vec_pack_0<Self.S<u64>>();
        Self.bad_sig(&x);
        return move(x);
    }
}

//# publish
module 0x42.M4 {
    struct S<T: copy> { t: T }

    public bad_sig<T>(s: vector<Self.S<T>>) { // should get flagged w/ constraint not satisfied
    label b0:
        return;
    }

    public call(): vector<Self.S<signer>> {
    let x: vector<Self.S<signer>>;
    label b0:
        x = vec_pack_0<Self.S<signer>>();
        Self.bad_sig(&x);
        return move(x);
    }
}
