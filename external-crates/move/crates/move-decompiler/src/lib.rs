// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

pub mod ast;
pub mod decompiler;
pub mod output;
pub mod pretty_printer;
mod refinement;
mod structuring;
pub mod testing;
pub mod translate;

use move_model_2::{
    compiled_model as CM,
    model::{self as M, Model},
    source_kind::SourceKind,
};

use pretty_simple::{Doc, ToDoc};

use std::{
    collections::BTreeMap,
    path::PathBuf,
};

//--------------------------------------------------------------------------------------------------
// Output Generation for Decompilation from Compiled Modules
//--------------------------------------------------------------------------------------------------

/// Generate Move source code from a list of compiled Move module files (.mv)
/// and write the output to the specified directory.
/// The output directory will contain subdirectories for each package,
/// with the decompiled Move source files.
/// # Arguments
/// * `input_files` - A slice of PathBufs representing the input .mv files.
/// * `output` - A Path representing the output directory.
/// # Returns
/// * `anyhow::Result<()>` - Ok(()) if successful, or an error if something goes wrong.
pub fn generate_from_files(input_files: &[PathBuf], output: &PathBuf) -> anyhow::Result<()> {
    let module_bytes = input_files
        .iter()
        .map(|path| std::fs::read_to_string(path))
        .collect::<Result<Vec<_>, _>>()?;
    let modules = module_bytes
        .iter()
        .map(|bytes| {
            move_binary_format::file_format::CompiledModule::deserialize_with_defaults(
                bytes.as_bytes(),
            )
        })
        .collect::<Result<Vec<_>, _>>()?;
    let model = CM::Model::from_compiled(&BTreeMap::new(), modules);
    generate_from_model(model, output)
}

pub fn generate_from_model<S: SourceKind>(input: Model<S>, output: &PathBuf) -> anyhow::Result<()> {
    let decompiled = crate::translate::model(input)?;

    let crate::ast::Decompiled { model, packages } = decompiled;

    println!("Packages\n----------------------------------");
    println!(
        "- {:#?}",
        model
            .packages()
            .map(|p| (p.name(), p.address()))
            .collect::<Vec<_>>()
    );

    println!("Modules\n----------------------------------");
    for pkg in packages {
        let name = pkg
            .name
            .map(|name| name.as_str().to_owned())
            .unwrap_or_else(|| format!("anon_{}", pkg.address));

        // Ensure the package directory exists and is empty: output/pkg_name
        let pkg_dir = output.join(&name);
        std::fs::create_dir_all(&pkg_dir)?;
        std::fs::remove_dir(&pkg_dir)?;
        std::fs::create_dir_all(&pkg_dir)?;

        let Some(model_pkg) = model.maybe_package(&pkg.address) else {
            anyhow::bail!("Package with address {} not found in model", pkg.address);
        };

        // Iterate without moving the map/vec
        for (module_name, module) in &pkg.modules {
            let path = pkg_dir.join(format!("{module_name}.move"));
            // If generate_output returns a Result, use `?`; otherwise drop it
            generate_module(model_pkg, &path, &name, module)?;
        }
    }

    Ok(())
}

fn generate_module<S: SourceKind>(
    pkg: M::Package<'_, S>,
    path: &PathBuf,
    pkg_name: &str,
    module: &crate::ast::Module,
) -> anyhow::Result<()> {
    use Doc as D;

    let Some(model_mod) = pkg.maybe_module(module.name) else {
        anyhow::bail!("Module {} not found in package {}", module.name, pkg_name);
    };

    let crate::ast::Module { name, functions } = module;

    let mut doc = D::text("// Auto-generated by Move decompiler")
        .concat(D::line())
        .concat(D::line());

    doc = doc
        .concat(D::text("module"))
        .concat_space(D::text(pkg_name))
        .concat(D::text("::"))
        .concat(D::text(name.as_str()))
        .concat(D::text(";"))
        .concat(D::line())
        .concat(D::line());

    doc = doc
        .concat(D::text("// -- structs -- "))
        .concat(D::line())
        .concat(D::line());

    let structs = {
        let mut doc = D::nil();
        for s in model_mod.structs() {
            let s_doc = s.to_doc();
            doc = doc.concat(s_doc).concat(D::line()).concat(D::line());
        }
        doc
    };
    doc = doc.concat(structs);

    doc = doc
        .concat(D::text("// -- enums -- "))
        .concat(D::line())
        .concat(D::line());

    let enums = {
        let mut doc = D::nil();
        for e in model_mod.enums() {
            let e_doc = e.to_doc();
            doc = doc.concat(e_doc).concat(D::line()).concat(D::line());
        }
        doc
    };
    doc = doc.concat(enums);

    doc = doc
        .concat(D::text("// -- functions -- "))
        .concat(D::line())
        .concat(D::line());

    let functions = {
        let mut doc = D::nil();
        for (name, fun) in functions {
            let Some(model_fun) = model_mod.maybe_function(*name) else {
                anyhow::bail!("Function {} not found in module {}", name, module.name);
            };
            let f_doc = generate_function(&model_fun, fun);
            doc = doc.concat(f_doc).concat(D::line()).concat(D::line());
        }
        doc
    };
    doc = doc.concat(functions);

    let output = doc.render(100);
    println!("- {}", path.display());
    std::fs::write(path, output)?;
    Ok(())
}

fn generate_function<S: SourceKind>(
    model_fun: &M::Function<'_, S>,
    fun: &crate::ast::Function,
) -> Doc {
    // TODO: Docs, Attributes
    let header =
        move_model_2::pretty_printer::fun_header(model_fun, /* use_param_names */ false);

    let crate::ast::Function { name: _, code } = fun;
    let exp_doc = code.to_doc();

    header
        .concat_space(Doc::text("{"))
        .concat(Doc::nest(Doc::line().concat(exp_doc), 4))
        .concat(Doc::line())
        .concat(Doc::text("}"))
}
