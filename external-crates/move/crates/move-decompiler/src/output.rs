// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

use move_model_2::{
    model::{self as M, Model},
    source_kind::SourceKind,
};

use pretty_simple::{Doc, ToDoc};

use std::path::Path;

pub fn generate_output<S: SourceKind>(input: Model<S>, output: &Path) -> anyhow::Result<()> {
    let decompiled = crate::translate::model(input)?;

    let crate::ast::Decompiled { model, packages } = decompiled;

    println!("model packages");
    println!(
        "{:#?}",
        model
            .packages()
            .map(|p| (p.name(), p.address()))
            .collect::<Vec<_>>()
    );
    println!("GENERATING OUTPUT");

    for pkg in packages {
        let name = pkg
            .name
            .map(|name| name.as_str().to_owned())
            .unwrap_or_else(|| format!("anon_{}", pkg.address));

        println!("package: {} @ {}", name, pkg.address);
        // Ensure the package directory exists and is empty: output/pkg_name
        let pkg_dir = output.join(&name);
        std::fs::create_dir_all(&pkg_dir)?;
        std::fs::remove_dir(&pkg_dir)?;
        std::fs::create_dir_all(&pkg_dir)?;
        println!("dir: {}", pkg_dir.display());

        let Some(model_pkg) = model.maybe_package(&pkg.address) else {
            anyhow::bail!("Package with address {} not found in model", pkg.address);
        };

        // Iterate without moving the map/vec
        for (module_name, module) in &pkg.modules {
            let path = pkg_dir.join(format!("{module_name}.move"));
            // If generate_output returns a Result, use `?`; otherwise drop it
            generate_module(model_pkg, &path, &name, module)?;
        }
    }

    Ok(())
}

fn generate_module<S: SourceKind>(
    pkg: M::Package<'_, S>,
    path: &Path,
    pkg_name: &str,
    module: &crate::ast::Module,
) -> anyhow::Result<()> {
    use Doc as D;

    let Some(model_mod) = pkg.maybe_module(module.name) else {
        anyhow::bail!("Module {} not found in package {}", module.name, pkg_name);
    };

    let crate::ast::Module { name, functions } = module;

    let mut doc = D::text("// Auto-generated by Move decompiler")
        .concat(D::line())
        .concat(D::line());

    doc = doc
        .concat(D::text("module"))
        .concat_space(D::text(pkg_name))
        .concat(D::text("::"))
        .concat(D::text(name.as_str()))
        .concat(D::text(";"))
        .concat(D::line())
        .concat(D::line());

    doc = doc
        .concat(D::text("// -- structs -- "))
        .concat(D::line())
        .concat(D::line());

    let structs = {
        let mut doc = D::nil();
        for s in model_mod.structs() {
            let s_doc = s.to_doc();
            doc = doc.concat(s_doc).concat(D::line()).concat(D::line());
        }
        doc
    };
    doc = doc.concat(structs);

    doc = doc
        .concat(D::text("// -- enums -- "))
        .concat(D::line())
        .concat(D::line());

    let enums = {
        let mut doc = D::nil();
        for e in model_mod.enums() {
            let e_doc = e.to_doc();
            doc = doc.concat(e_doc).concat(D::line()).concat(D::line());
        }
        doc
    };
    doc = doc.concat(enums);

    doc = doc
        .concat(D::text("// -- functions -- "))
        .concat(D::line())
        .concat(D::line());

    let functions = {
        let mut doc = D::nil();
        for (name, fun) in functions {
            let Some(model_fun) = model_mod.maybe_function(*name) else {
                anyhow::bail!("Function {} not found in module {}", name, module.name);
            };
            let f_doc = generate_function(&model_fun, fun);
            doc = doc.concat(f_doc).concat(D::line()).concat(D::line());
        }
        doc
    };
    doc = doc.concat(functions);

    let output = doc.render(100);
    std::fs::write(path, output)?;
    Ok(())
}

fn generate_function<S: SourceKind>(
    model_fun: &M::Function<'_, S>,
    fun: &crate::ast::Function,
) -> Doc {
    // TODO: Docs, Attributes
    let header =
        move_model_2::pretty_printer::fun_header(model_fun, /* use_param_names */ false);

    let crate::ast::Function { name: _, code } = fun;
    let exp_doc = code.to_doc();

    header
        .concat_space(Doc::text("{"))
        .concat(Doc::nest(Doc::line().concat(exp_doc), 4))
        .concat(Doc::line())
        .concat(Doc::text("}"))
}
