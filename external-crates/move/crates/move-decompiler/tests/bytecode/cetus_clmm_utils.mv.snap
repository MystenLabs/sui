---
source: crates/move-decompiler/tests/tests.rs
---
// Auto-generated by Move decompiler

module b40b95dfee63de4d308b5b3118d1f127950d15184cad3ee762bba7594f26dd40::cetus_clmm_utils;

// -- structs -- 

public struct SwapSafeBeforeEvent has copy, drop { coin_a: u64, coin_b: u64 }

public struct SwapSafeBeforeSwapEvent
has copy, drop {
    coin_a: u64,
    coin_b: u64,
    a2b: bool,
    by_amount_in: bool,
    amount: u64,
    amount_limit: u64,
    sqrt_price_limit: u128,
}

public struct SwapSafeAfterEvent
has copy, drop {
    amount: u64,
    amount_limit: u64,
    by_amount_in: bool,
    a2b: bool,
    price: u64,
    amount_limit_tolerance: u64,
    coin_a_decimals: u8,
    coin_b_decimals: u8,
    coin_a_back: u64,
    coin_b_back: u64,
}

public struct SwapSafeComputeEvent has copy, drop { a: u128, b: u128, c: u128, d: u128, e: u128, f: u128, g: u64 }

// -- constants -- 

const C0: u128 = 18446744073709551616u128;

const C1: u64 = 2000u64;

const C2: u64 = 1u64;

const C3: u64 = 2u64;

const C4: u64 = 3u64;

const C5: u64 = 4u64;

const C6: u64 = 100000000u64;

const C7: u64 = 10000u64;

// -- functions -- 

public fun add_liquidity<T,T>(l0: &0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::config::GlobalConfig, l1: &mut 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::pool::PoolT0, T1, l2: &mut 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::position::Position, l3: &mut 0x2::coin::CoinT0, l4: &mut 0x2::coin::CoinT1, l5: u128, l6: &0x2::clock::Clock, l7: &mut 0x2::tx_context::TxContext) {
    {
        let l10 = 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::pool::add_liquidity(l0, l1, l2, l5, l6);
        let (reg_7, reg_8) = 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::pool::add_liquidity_pay_amount(&l10);
        let l9 = reg_8;
        let l8 = reg_7;
        0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::pool::repay_add_liquidity(l0, l1, 0x2::coin::into_balance(0x2::coin::split(l3, l8, l7)), 0x2::coin::into_balance(0x2::coin::split(l4, l9, l7)), l10);
        return
    }
}

public fun add_liquidity_reverse<T,T>(l0: &0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::config::GlobalConfig, l1: &mut 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::pool::PoolT1, T0, l2: &mut 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::position::Position, l3: &mut 0x2::coin::CoinT0, l4: &mut 0x2::coin::CoinT1, l5: u128, l6: &0x2::clock::Clock, l7: &mut 0x2::tx_context::TxContext) {
    {
        let l10 = 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::pool::add_liquidity(l0, l1, l2, l5, l6);
        let (reg_7, reg_8) = 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::pool::add_liquidity_pay_amount(&l10);
        let l8 = reg_8;
        let l9 = reg_7;
        0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::pool::repay_add_liquidity(l0, l1, 0x2::coin::into_balance(0x2::coin::split(l4, l9, l7)), 0x2::coin::into_balance(0x2::coin::split(l3, l8, l7)), l10);
        return
    }
}

public fun get_liquidity_for_amounts(l0: u128, l1: u128, l2: u128, l3: u64, l4: u64): u128 {
    {
        if (l1 > l2) {
            let l2 = l1;
            let l1 = l2;
        };
        if (l0 <= l1) {
            let l7 = 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::clmm_math::get_liquidity_from_a(l1, l2, l3, false);
        } else {
            if (l0 < l2) {
                let l8 = 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::clmm_math::get_liquidity_from_a(l0, l2, l3, false);
                let l9 = 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::clmm_math::get_liquidity_from_b(l1, l0, l4, false);
                if (l8 < l9) {
                    let l5 = l8;
                } else {
                    l5 = l9;
                };
                let l6 = l5;
            } else {
                l6 = 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::clmm_math::get_liquidity_from_a(l1, l2, l4, false);
            };
            l7 = l6;
        };
        return l7
    }
}

public fun get_pool_price_amount_ratio<T,T>(l0: &0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::pool::PoolT0, T1): ( u128, u128) {
    {
        let l1 = 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::pool::liquidity(l0);
        let l2 = 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::pool::current_sqrt_price(l0);
        let (reg_6, reg_7) = 0xb40b95dfee63de4d308b5b3118d1f127950d15184cad3ee762bba7594f26dd40::cetus_clmm_utils::get_price_amount_ratio(l1, l2);
        return (reg_6, reg_7)
    }
}

public fun get_price_amount_ratio(l0: u128, l1: u128): ( u128, u128) {
    {
        let l2 = 0xb40b95dfee63de4d308b5b3118d1f127950d15184cad3ee762bba7594f26dd40::cetus_clmm_utils::mul_div_u128(l0, C0, l1);
        let l3 = 0xb40b95dfee63de4d308b5b3118d1f127950d15184cad3ee762bba7594f26dd40::cetus_clmm_utils::mul_div_u128(l0, l1, C0);
        return (l2, l3)
    }
}

public fun mul_div_u128(l0: u128, l1: u128, l2: u128): u128 {
    if (l2 != 0u128) {
        return l0 as u256 * l1 as u256 / l2 as u256 as u128
    } else {
        abort C1
    }
}

public fun pow_negtive(l0: u64, l1: u8, l2: u8): u64 {
    abort 0u64
}

public fun swap<T,T>(l0: &0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::config::GlobalConfig, l1: &mut 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::pool::PoolT0, T1, l2: 0x2::coin::CoinT0, l3: 0x2::coin::CoinT1, l4: bool, l5: bool, l6: u64, l7: u128, l8: &0x2::clock::Clock, l9: &mut 0x2::tx_context::TxContext): ( 0x2::coin::CoinT0, 0x2::coin::CoinT1) {
    {
        let (reg_7, reg_8, reg_9) = 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::pool::flash_swap(l0, l1, l4, l5, l6, l7, l8);
        let l14 = reg_9;
        let l19 = reg_8;
        let l18 = reg_7;
        let l11 = 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::pool::swap_pay_amount(&l14);
        if (l4) {
            let l10 = 0x2::balance::value(&l19);
        } else {
            l10 = 0x2::balance::value(&l18);
        };
        let l15 = l11;
        if (l4) {
            let l13 = 0x2::balance::zero();
            let l12 = 0x2::coin::into_balance(0x2::coin::split(&mut l2, l15, l9));
        } else {
            l13 = 0x2::coin::into_balance(0x2::coin::split(&mut l3, l15, l9));
            l12 = 0x2::balance::zero();
        };
        let l17 = l13;
        let l16 = l12;
        0x2::coin::join(&mut l2, 0x2::coin::from_balance(l18, l9));
        0x2::coin::join(&mut l3, 0x2::coin::from_balance(l19, l9));
        0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::pool::repay_flash_swap(l0, l1, l16, l17, l14);
        return (l2, l3)
    }
}

public fun swap_exact<T,T>(l0: &0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::config::GlobalConfig, l1: &mut 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::pool::PoolT0, T1, l2: 0x2::coin::CoinT0, l3: 0x2::coin::CoinT1, l4: bool, l5: bool, l6: u64, l7: &0x2::clock::Clock, l8: &mut 0x2::tx_context::TxContext): ( 0x2::coin::CoinT0, 0x2::coin::CoinT1) {
    {
        let l16 = l0;
        let l15 = l1;
        let l14 = l2;
        let l13 = l3;
        let l12 = l4;
        let l11 = l5;
        let l10 = l6;
        if (l4) {
            let l9 = 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::tick_math::min_sqrt_price() + 1u128;
        } else {
            l9 = 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::tick_math::max_sqrt_price() - 1u128;
        };
        let (reg_24, reg_25) = 0xb40b95dfee63de4d308b5b3118d1f127950d15184cad3ee762bba7594f26dd40::cetus_clmm_utils::swap(l16, l15, l14, l13, l12, l11, l10, l9, l7, l8);
        return (reg_24, reg_25)
    }
}

public fun swap_exact_limit<T,T>(l0: &0x9ec6f17e19c5e64c8872779a635235497fd6c71f7b5c23b07f652b02a240c84a::global_storage::GlobalStorage, l1: address, l2: &0x2::coin::CoinMetadataT0, l3: &0x2::coin::CoinMetadataT1, l4: &0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::config::GlobalConfig, l5: &mut 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::pool::PoolT0, T1, l6: 0x2::coin::CoinT0, l7: 0x2::coin::CoinT1, l8: bool, l9: bool, l10: u64, l11: u64, l12: &0x2::clock::Clock, l13: &mut 0x2::tx_context::TxContext): ( 0x2::coin::CoinT0, 0x2::coin::CoinT1) {
    abort 0u64
}

public fun swap_exact_limit_reverse<T,T>(l0: &0x9ec6f17e19c5e64c8872779a635235497fd6c71f7b5c23b07f652b02a240c84a::global_storage::GlobalStorage, l1: address, l2: &0x2::coin::CoinMetadataT0, l3: &0x2::coin::CoinMetadataT1, l4: &0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::config::GlobalConfig, l5: &mut 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::pool::PoolT1, T0, l6: 0x2::coin::CoinT0, l7: 0x2::coin::CoinT1, l8: bool, l9: bool, l10: u64, l11: u64, l12: &0x2::clock::Clock, l13: &mut 0x2::tx_context::TxContext): ( 0x2::coin::CoinT0, 0x2::coin::CoinT1) {
    abort 0u64
}

public fun swap_exact_reverse<T,T>(l0: &0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::config::GlobalConfig, l1: &mut 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::pool::PoolT1, T0, l2: 0x2::coin::CoinT0, l3: 0x2::coin::CoinT1, l4: bool, l5: bool, l6: u64, l7: &0x2::clock::Clock, l8: &mut 0x2::tx_context::TxContext): ( 0x2::coin::CoinT0, 0x2::coin::CoinT1) {
    {
        let l16 = l0;
        let l15 = l1;
        let l14 = l3;
        let l13 = l2;
        let l12 = !(l4);
        let l11 = l5;
        let l10 = l6;
        if (!(l4)) {
            let l9 = 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::tick_math::min_sqrt_price() + 1u128;
        } else {
            l9 = 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::tick_math::max_sqrt_price() - 1u128;
        };
        let (reg_26, reg_27) = 0xb40b95dfee63de4d308b5b3118d1f127950d15184cad3ee762bba7594f26dd40::cetus_clmm_utils::swap(l16, l15, l14, l13, l12, l11, l10, l9, l7, l8);
        let l17 = reg_27;
        let l18 = reg_26;
        return (l17, l18)
    }
}

public fun swap_exact_safe<T,T>(l0: &0x9ec6f17e19c5e64c8872779a635235497fd6c71f7b5c23b07f652b02a240c84a::global_storage::GlobalStorage, l1: address, l2: u8, l3: u8, l4: &0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::config::GlobalConfig, l5: &mut 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::pool::PoolT0, T1, l6: 0x2::coin::CoinT0, l7: 0x2::coin::CoinT1, l8: bool, l9: bool, l10: u64, l11: u64, l12: &0x2::clock::Clock, l13: &mut 0x2::tx_context::TxContext): ( 0x2::coin::CoinT0, 0x2::coin::CoinT1) {
    {
        let (reg_4, reg_5) = 0x9ec6f17e19c5e64c8872779a635235497fd6c71f7b5c23b07f652b02a240c84a::price_oracle::get_price(l0, l1, 0x1::type_name::get(), 0x1::type_name::get());
        let l26 = reg_4;
        if (l9) {
            if (l8) {
                if (l3 >= l2) {
                    let l23 = C7 as u128 - l11 as u128 * l10 as u128 * l26 as u128 * 0x2::math::pow(10u64, l3 - l2) as u128 / C7 as u128 / C6 as u128 as u64;
                } else {
                    l23 = C7 as u128 - l11 as u128 * l10 as u128 * l26 as u128 / C6 as u128 / C7 as u128 / 0x2::math::pow(10u64, l2 - l3) as u128 as u64;
                }
            } else {
                if (l2 > l3) {
                    l23 = C7 as u128 - l11 as u128 * l10 as u128 * C6 as u128 * 0x2::math::pow(10u64, l2 - l3) as u128 / l26 as u128 / C7 as u128 as u64;
                } else {
                    l23 = C7 as u128 - l11 as u128 * l10 as u128 * C6 as u128 / C7 as u128 / 0x2::math::pow(10u64, l3 - l2) as u128 / l26 as u128 as u64;
                }
            }
        } else {
            if (l8) {
                if (l2 >= l3) {
                    l23 = C7 as u128 + l11 as u128 * l10 as u128 * 0x2::math::pow(10u64, l2 - l3) as u128 * C6 as u128 / l26 as u128 / C7 as u128 as u64;
                } else {
                    l23 = C7 as u128 + l11 as u128 * l10 as u128 * C6 as u128 / l26 as u128 / C7 as u128 / 0x2::math::pow(10u64, l3 - l2) as u128 as u64;
                }
            } else {
                if (l3 >= l2) {
                    l23 = C7 as u128 + l11 as u128 * l10 as u128 * 0x2::math::pow(10u64, l3 - l2) as u128 * l26 as u128 / C6 as u128 / C7 as u128 as u64;
                } else {
                    l23 = C7 as u128 + l11 as u128 * l10 as u128 * l26 as u128 / C7 as u128 / C6 as u128 / 0x2::math::pow(10u64, l2 - l3) as u128 as u64;
                }
            }
        };
        0x2::event::emit(SwapSafeBeforeEvent { coin_a: 0x2::coin::value(&l6), coin_b: 0x2::coin::value(&l7) });
        let l22 = l4;
        let l21 = l5;
        let l20 = l6;
        let l19 = l7;
        let l18 = l8;
        let l17 = l9;
        let l16 = l10;
        let l15 = l23;
        if (l8) {
            let l14 = 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::tick_math::min_sqrt_price() + 1u128;
        } else {
            l14 = 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::tick_math::max_sqrt_price() - 1u128;
        };
        let (reg_253, reg_254) = 0xb40b95dfee63de4d308b5b3118d1f127950d15184cad3ee762bba7594f26dd40::cetus_clmm_utils::swap_safe(l22, l21, l20, l19, l18, l17, l16, l15, l14, l12, l13);
        let l25 = reg_254;
        let l24 = reg_253;
        0x2::event::emit(SwapSafeAfterEvent { amount: l10, amount_limit: l23, by_amount_in: l9, a2b: l8, price: l26, amount_limit_tolerance: l11, coin_a_decimals: l2, coin_b_decimals: l3, coin_a_back: 0x2::coin::value(&l24), coin_b_back: 0x2::coin::value(&l25) });
        return (l24, l25)
    }
}

public fun swap_exact_safe_reverse<T,T>(l0: &0x9ec6f17e19c5e64c8872779a635235497fd6c71f7b5c23b07f652b02a240c84a::global_storage::GlobalStorage, l1: address, l2: u8, l3: u8, l4: &0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::config::GlobalConfig, l5: &mut 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::pool::PoolT1, T0, l6: 0x2::coin::CoinT0, l7: 0x2::coin::CoinT1, l8: bool, l9: bool, l10: u64, l11: u64, l12: &0x2::clock::Clock, l13: &mut 0x2::tx_context::TxContext): ( 0x2::coin::CoinT0, 0x2::coin::CoinT1) {
    {
        let (reg_4, reg_5) = 0x9ec6f17e19c5e64c8872779a635235497fd6c71f7b5c23b07f652b02a240c84a::price_oracle::get_price(l0, l1, 0x1::type_name::get(), 0x1::type_name::get());
        let l26 = reg_4;
        if (l9) {
            if (!(l8)) {
                if (l3 >= l2) {
                    let l23 = C7 as u128 - l11 as u128 * l10 as u128 * 0x2::math::pow(10u64, l3 - l2) as u128 * l26 as u128 / C6 as u128 / C7 as u128 as u64;
                } else {
                    l23 = C7 as u128 - l11 as u128 * l10 as u128 * l26 as u128 / C6 as u128 / C7 as u128 / 0x2::math::pow(10u64, l2 - l3) as u128 as u64;
                }
            } else {
                if (l2 >= l3) {
                    l23 = C7 as u128 - l11 as u128 * l10 as u128 * 0x2::math::pow(10u64, l2 - l3) as u128 * C6 as u128 / l26 as u128 / C7 as u128 as u64;
                } else {
                    l23 = C7 as u128 - l11 as u128 * l10 as u128 * C6 as u128 / l26 as u128 / C7 as u128 / 0x2::math::pow(10u64, l3 - l2) as u128 as u64;
                }
            }
        } else {
            if (!(l8)) {
                if (l2 >= l3) {
                    l23 = C7 as u128 + l11 as u128 * l10 as u128 * 0x2::math::pow(10u64, l2 - l3) as u128 * C6 as u128 / l26 as u128 / C7 as u128 as u64;
                } else {
                    l23 = C7 as u128 + l11 as u128 * l10 as u128 * C6 as u128 / l26 as u128 / C7 as u128 / 0x2::math::pow(10u64, l3 - l2) as u128 as u64;
                }
            } else {
                if (l3 >= l2) {
                    l23 = C7 as u128 + l11 as u128 * l10 as u128 * 0x2::math::pow(10u64, l3 - l2) as u128 * l26 as u128 / C6 as u128 / C7 as u128 as u64;
                } else {
                    l23 = C7 as u128 + l11 as u128 * l10 as u128 * l26 as u128 / C6 as u128 / 0x2::math::pow(10u64, l2 - l3) as u128 / C7 as u128 as u64;
                }
            }
        };
        0x2::event::emit(SwapSafeBeforeEvent { coin_a: 0x2::coin::value(&l6), coin_b: 0x2::coin::value(&l7) });
        let l22 = l4;
        let l21 = l5;
        let l20 = l7;
        let l19 = l6;
        let l18 = !(l8);
        let l17 = l9;
        let l16 = l10;
        let l15 = l23;
        if (!(l8)) {
            let l14 = 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::tick_math::min_sqrt_price() + 1u128;
        } else {
            l14 = 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::tick_math::max_sqrt_price() - 1u128;
        };
        let (reg_257, reg_258) = 0xb40b95dfee63de4d308b5b3118d1f127950d15184cad3ee762bba7594f26dd40::cetus_clmm_utils::swap_safe(l22, l21, l20, l19, l18, l17, l16, l15, l14, l12, l13);
        let l24 = reg_258;
        let l25 = reg_257;
        0x2::event::emit(SwapSafeAfterEvent { amount: l10, amount_limit: l23, by_amount_in: l9, a2b: l8, price: l26, amount_limit_tolerance: l11, coin_a_decimals: l2, coin_b_decimals: l3, coin_a_back: 0x2::coin::value(&l24), coin_b_back: 0x2::coin::value(&l25) });
        return (l24, l25)
    }
}

public fun swap_safe<T,T>(l0: &0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::config::GlobalConfig, l1: &mut 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::pool::PoolT0, T1, l2: 0x2::coin::CoinT0, l3: 0x2::coin::CoinT1, l4: bool, l5: bool, l6: u64, l7: u64, l8: u128, l9: &0x2::clock::Clock, l10: &mut 0x2::tx_context::TxContext): ( 0x2::coin::CoinT0, 0x2::coin::CoinT1) {
    {
        let (reg_7, reg_8, reg_9) = 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::pool::flash_swap(l0, l1, l4, l5, l6, l8, l9);
        let l16 = reg_9;
        let l21 = reg_8;
        let l20 = reg_7;
        let l12 = 0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb::pool::swap_pay_amount(&l16);
        if (l4) {
            let l11 = 0x2::balance::value(&l21);
        } else {
            l11 = 0x2::balance::value(&l20);
        };
        let l15 = l11;
        let l17 = l12;
        if (l5) {
            if (l17 == l6) {
                if (l15 >= l7) {
                    
                } else {
                    abort C3
                }
            } else {
                abort C2
            }
        } else {
            if (l15 == l6) {
                if (l17 <= l7) {
                    
                } else {
                    abort C5
                }
            } else {
                abort C4
            }
        }
    }
}
