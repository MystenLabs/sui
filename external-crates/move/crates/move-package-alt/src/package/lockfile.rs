// Copyright (c) The Diem Core Contributors
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

use std::{
    collections::BTreeMap,
    ffi::OsString,
    fmt,
    fs::read_to_string,
    path::{Path, PathBuf},
};

use derive_where::derive_where;
use serde::{Deserialize, Serialize};
use serde_spanned::Spanned;
use toml_edit::{
    DocumentMut, InlineTable, Item, KeyMut, Table, Value,
    visit_mut::{VisitMut, visit_table_like_kv_mut, visit_table_mut},
};

use crate::{
    dependency::{DependencySet, PinnedDependencyInfo, UnpinnedDependencyInfo, pin},
    errors::{Located, LockfileError, PackageError, PackageResult, with_file},
    flavor::MoveFlavor,
};

use super::{EnvironmentName, PackageName, manifest::Manifest};
use move_core_types::identifier::Identifier;

type PackageID = String;

#[derive(fmt::Debug, Serialize, Deserialize)]
#[derive_where(Clone, Default)]
#[serde(bound = "")]
pub struct Lockfile<F: MoveFlavor + fmt::Debug> {
    pinned: BTreeMap<EnvironmentName, DependencyInfo<F>>,
    #[serde(default)]
    published: BTreeMap<EnvironmentName, Publication<F>>,
}

#[derive(fmt::Debug, Serialize, Deserialize)]
#[derive_where(Clone)]
#[serde(bound = "")]
pub struct Publication<F: MoveFlavor + fmt::Debug> {
    #[serde(flatten)]
    metadata: F::PublishedMetadata,
    dependencies: BTreeMap<PackageName, PinnedDependencyInfo<F>>,
}

/// The `pinned.<environment>` section of the lockfile
#[derive(fmt::Debug, Serialize, Deserialize)]
#[derive_where(Clone)]
#[serde(bound = "")]
pub struct DependencyInfo<F: MoveFlavor + fmt::Debug> {
    /// A map between a package id (generated by the graph builder) and  the package dependency
    /// info
    #[serde(flatten)]
    pub data: BTreeMap<PackageID, DepInfo<F>>,
}

#[derive(fmt::Debug, Serialize, Deserialize)]
#[derive_where(Clone)]
#[serde(bound = "")]
pub struct DepInfo<F: MoveFlavor + fmt::Debug> {
    /// Metadata about the package's source
    pub source: PinnedDependencyInfo<F>,
    /// Contains the package's manifest digest. This is used to verify if a manifest has changed
    /// and re-pinning is required.
    pub manifest_digest: String,
    /// The package's dependencies, a map from the package name to the package id.
    pub deps: BTreeMap<PackageName, PackageID>,
}

impl<F: MoveFlavor + fmt::Debug> Lockfile<F> {
    /// Read `Move.lock` and all `Move.<env>.lock` files from the directory at `path`.
    /// Returns a new empty [Lockfile] if `path` doesn't contain a `Move.lock`.
    pub fn read_from_dir(path: impl AsRef<Path>) -> PackageResult<Self> {
        // Parse `Move.lock`
        let lockfile_name = path.as_ref().join("Move.lock");
        if !lockfile_name.exists() {
            return Ok(Self::default());
        };

        let (result, file_id) = with_file(lockfile_name, toml_edit::de::from_str::<Self>)?;

        let Ok(mut lockfiles) = result else {
            return Err(result.unwrap_err().into());
        };

        // Add in `Move.<env>.lock` files
        let dir = std::fs::read_dir(path)?;
        for entry in dir {
            let Ok(file) = entry else { continue };

            let Some(env_name) = lockname_to_env_name(file.file_name()) else {
                continue;
            };

            let (metadata, file_id) =
                with_file(file.path(), toml_edit::de::from_str::<Publication<F>>)?;

            let Ok(metadata) = metadata else {
                return Err(metadata.unwrap_err().into());
            };

            let old_entry = lockfiles.published.insert(env_name.clone(), metadata);
            if old_entry.is_some() {
                return Err(PackageError::Generic("Move.lock and Move.{env_name}.lock both contain publication information for {env_name}".to_string()));
            }
        }

        Ok(lockfiles)
    }

    /// Serialize [self] into `Move.lock` and `Move.<env>.lock`.
    ///
    /// The [PublishedMetadata] in `self.published.<env>` are partitioned: if `env` is in [envs]
    /// then it is saved to `Move.lock` (and `Move.<env>.lock` is deleted), otherwise the metadata
    /// is stored in `Move.<env>.lock`.
    pub fn write_to(
        &self,
        path: impl AsRef<Path>,
        envs: BTreeMap<EnvironmentName, F::EnvironmentID>,
    ) -> PackageResult<()> {
        let mut output: Lockfile<F> = self.clone();
        let (pubs, locals): (BTreeMap<_, _>, BTreeMap<_, _>) = output
            .published
            .into_iter()
            .partition(|(env_name, metadata)| envs.contains_key(env_name));
        output.published = pubs;

        std::fs::write(path.as_ref().join("Move.lock"), output.render_as_toml())?;

        for (chain, metadata) in locals {
            std::fs::write(
                path.as_ref().join(format!("Move.{}.lock", chain)),
                metadata.render(),
            )?;
        }

        for chain in output.published.keys() {
            let _ = std::fs::remove_file(path.as_ref().join(format!("Move.{}.lock", chain)));
        }

        Ok(())
    }

    /// Pretty-print [self] as a TOML document
    pub fn render_as_toml(&self) -> String {
        let mut toml = toml_edit::ser::to_document(self).expect("toml serialization succeeds");

        expand_toml(&mut toml);
        for (_, chain) in toml["pinned"].as_table_like_mut().unwrap().iter_mut() {
            for (_, item) in chain.as_table_like_mut().unwrap().iter_mut() {
                flatten_toml(item);
            }
        }

        for (_, chain) in toml["published"].as_table_like_mut().unwrap().iter_mut() {
            flatten_toml(chain.get_mut("dependencies").unwrap());
        }

        toml.decor_mut()
            .set_prefix("# Generated by move; do not edit\n# This file should be checked in.\n\n");

        toml.to_string()
    }

    /// Return the published metadata for all environments.
    fn published(&self) -> &BTreeMap<EnvironmentName, Publication<F>> {
        &self.published
    }

    /// Return the published metadata for a specific environment.
    pub fn published_for_env(&self, env: &EnvironmentName) -> Option<Publication<F>> {
        self.published.get(env).cloned()
    }

    /// Return the pinned dependencies for the given environment, if it exists in the lockfile.
    pub fn pinned_deps_for_env(&self, env: &EnvironmentName) -> Option<&DependencyInfo<F>> {
        self.pinned.get(env)
    }

    /// Return a map that has an environment as key and the dependencies for that environment.
    pub fn pinned_deps(&self) -> &BTreeMap<EnvironmentName, DependencyInfo<F>> {
        &self.pinned
    }
}

impl<F: MoveFlavor + fmt::Debug> Publication<F> {
    /// Pretty-print [self] as TOML
    fn render(&self) -> String {
        let mut toml = toml_edit::ser::to_document(self).expect("toml serialization succeeds");
        expand_toml(&mut toml);
        flatten_toml(&mut toml["dependencies"]);

        toml.decor_mut().set_prefix(
            "# Generated by move; do not edit\n# This file should not be checked in\n\n",
        );
        toml.to_string()
    }
}

/// Replace every inline table in [toml] with an implicit standard table (implicit tables are not
/// included if they have no keys directly inside them)
fn expand_toml(toml: &mut DocumentMut) {
    struct Expander;

    impl VisitMut for Expander {
        fn visit_table_mut(&mut self, table: &mut Table) {
            table.set_implicit(true);
            visit_table_mut(self, table);
        }

        fn visit_table_like_kv_mut(&mut self, mut key: KeyMut<'_>, node: &mut Item) {
            if let Item::Value(Value::InlineTable(inline_table)) = node {
                let inline_table = std::mem::replace(inline_table, InlineTable::new());
                let table = inline_table.into_table();
                key.fmt();
                *node = Item::Table(table);
            }
            visit_table_like_kv_mut(self, key, node);
        }
    }

    let mut visitor = Expander;
    visitor.visit_document_mut(toml);
}

/// Replace every table in [toml] with a non-implicit inline table.
fn flatten_toml(toml: &mut Item) {
    struct Inliner;

    impl VisitMut for Inliner {
        fn visit_table_mut(&mut self, table: &mut Table) {
            table.set_implicit(false);
            visit_table_mut(self, table);
        }

        fn visit_table_like_kv_mut(&mut self, mut key: KeyMut<'_>, node: &mut Item) {
            if let Item::Table(table) = node {
                let table = std::mem::replace(table, Table::new());
                let inline_table = table.into_inline_table();
                key.fmt();
                *node = Item::Value(Value::InlineTable(inline_table));
            }
        }
    }

    let mut visitor = Inliner;
    visitor.visit_item_mut(toml);
}

/// Given a filename of the form `Move.<env>.lock`, returns `<env>`.
fn lockname_to_env_name(filename: OsString) -> Option<String> {
    let Ok(filename) = filename.into_string() else {
        return None;
    };

    let prefix = "Move.";
    let suffix = ".lock";

    if filename.starts_with(prefix) && filename.ends_with(suffix) {
        let start_index = prefix.len();
        let end_index = filename.len() - suffix.len();

        if start_index < end_index {
            return Some(filename[start_index..end_index].to_string());
        }
    }

    None
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_lockname_to_env_name() {
        assert_eq!(
            lockname_to_env_name(OsString::from("Move.test.lock")),
            Some("test".to_string())
        );
        assert_eq!(
            lockname_to_env_name(OsString::from("Move.3vcga23.lock")),
            Some("3vcga23".to_string())
        );
        assert_eq!(
            lockname_to_env_name(OsString::from("Mve.test.lock.lock")),
            None
        );

        assert_eq!(lockname_to_env_name(OsString::from("Move.lock")), None);
        assert_eq!(lockname_to_env_name(OsString::from("Move.test.loc")), None);
        assert_eq!(lockname_to_env_name(OsString::from("Move.testloc")), None);
        assert_eq!(lockname_to_env_name(OsString::from("Move.test")), None);
    }
}
