use derive_where::derive_where;
use serde::{Deserialize, Serialize};
use std::{collections::BTreeMap, path::PathBuf};

use crate::flavor::MoveFlavor;

use super::{
    EnvironmentID, EnvironmentName, GitSha, LocalDepInfo, OnChainDepInfo, PackageName,
    PublishAddresses,
    toml_format::{expand_toml, flatten_toml},
};

/// An identifier for a node in the package graph, used to index into the
/// `[pinned.<environment>]` table
pub type PackageID = String;

/// The serialized lockfile format
// TODO: remove Debug and Clone
#[derive(Debug, Default, Clone, Serialize, Deserialize)]
pub struct ParsedLockfile {
    #[serde(default)]
    pub pinned: BTreeMap<EnvironmentName, BTreeMap<PackageID, Pin>>,
}

pub type BuildConfig = BTreeMap<String, String>;

/// A serialized entry in the `[pinned.<environment>.<package-id>]` table of the lockfile
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename = "kabob-case")]
pub struct Pin {
    /// Metadata about the package's source
    pub source: LockfileDependencyInfo,

    /// The stored `published-at` and `original-id` overrides (from the `published-at` and
    /// `original-id` fields in the manifest
    pub address_override: Option<PublishAddresses>,

    /// The environment that should be used for the dependency (as defined in the dependency's
    /// manifest but specified in the depender's manifest).
    ///
    /// E.g. if `a/Move.toml` contains
    /// ```toml
    /// environments.mainnet = "1234"
    /// dep-replacements.mainnet.b = { ..., use-environment="foo" }
    /// ```
    ///
    /// then use_environment for the `b` dependency would be `foo`
    pub use_environment: Option<EnvironmentName>,

    /// Contains the package's manifest digest. This is used to verify if a manifest has changed
    /// and re-pinning is required.
    pub manifest_digest: String,

    /// The package's dependencies, a map from the package name to the package id.
    pub deps: BTreeMap<PackageName, PackageID>,
}

/// A serialized pinned dependency in a lockfile
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(untagged)]
pub enum LockfileDependencyInfo {
    Local(LocalDepInfo),
    OnChain(OnChainDepInfo),
    Git(LockfileGitDepInfo),
    Root(RootDepInfo),
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct RootDepInfo {
    pub root: bool,
}

/// A serialized lockfile dependency of the form `{git = "...", rev = "...", subdir = "..."}`
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct LockfileGitDepInfo {
    /// The repository containing the dependency
    #[serde(rename = "git")]
    pub repo: String,

    /// The git commit or branch for the dependency.
    pub rev: GitSha,

    /// The path within the repository
    #[serde(rename = "subdir")]
    pub path: PathBuf,
}

impl ParsedLockfile {
    /// Pretty-print `self` as a TOML document
    pub fn render_as_toml(&self) -> String {
        let mut toml = toml_edit::ser::to_document(self).expect("toml serialization succeeds");

        expand_toml(&mut toml);
        for (_, chain) in toml["pinned"].as_table_like_mut().unwrap().iter_mut() {
            for (_, item) in chain.as_table_like_mut().unwrap().iter_mut() {
                flatten_toml(item);
            }
        }

        for (_, chain) in toml["published"].as_table_like_mut().unwrap().iter_mut() {
            flatten_toml(chain.get_mut("dependencies").unwrap());
        }

        toml.decor_mut()
            .set_prefix("# Generated by move; do not edit\n# This file should be checked in.\n\n");

        toml.to_string()
    }
}

// TODO
#[cfg(test)]
mod tests {
    use test_log::test;

    #[test]
    fn parse() {
        todo!();
    }

    #[test]
    fn print() {
        todo!();
    }
}
