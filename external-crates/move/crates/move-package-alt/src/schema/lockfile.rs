use derive_where::derive_where;
use serde::{Deserialize, Serialize};
use std::{collections::BTreeMap, path::PathBuf};
use toml_edit::{
    DocumentMut, InlineTable, Item, KeyMut, Table, Value,
    visit_mut::{self, VisitMut},
};

use crate::flavor::MoveFlavor;

use super::{
    EnvironmentID, EnvironmentName, GitSha, LocalDepInfo, OnChainDepInfo, PackageName,
    PublishAddresses,
};

/// An identifier for a node in the package graph, used to index into the
/// `[pinned.<environment>]` table
pub type PackageID = String;

/// The serialized lockfile format
// TODO: remove Debug and Clone
#[derive(Debug, Serialize, Deserialize)]
#[derive_where(Default, Clone)]
#[serde(bound = "")]
pub struct ParsedLockfile<F: MoveFlavor> {
    #[serde(rename = "move")]
    pub header: MoveHeader,

    #[serde(default)]
    pub pinned: BTreeMap<EnvironmentName, BTreeMap<PackageID, Pin>>,

    #[serde(default)]
    pub published: BTreeMap<EnvironmentName, Publication<F>>,
}

pub type BuildConfig = BTreeMap<String, String>;

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct MoveHeader {
    pub version: Constant4,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default)]
#[serde(into = "u8", try_from = "u8")]
pub struct Constant4;

/// A serialized entry in the `[published.<environment>]` table of the lockfile
#[derive(Debug, Serialize, Deserialize)]
#[derive_where(Clone)]
#[serde(rename_all = "kebab-case")]
pub struct Publication<F: MoveFlavor> {
    #[serde(flatten)]
    pub addresses: PublishAddresses,
    pub chain_id: EnvironmentID,
    pub toolchain_version: String,
    #[serde(default)]
    pub build_config: BuildConfig,

    #[serde(flatten)]
    pub metadata: F::PublishedMetadata,
}

/// A serialized entry in the `[pinned.<environment>.<package-id>]` table of the lockfile
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename = "kabob-case")]
pub struct Pin {
    /// Metadata about the package's source
    pub source: LockfileDependencyInfo,

    /// The stored `published-at` and `original-id` overrides (from the `published-at` and
    /// `original-id` fields in the manifest
    pub address_override: Option<PublishAddresses>,

    /// The environment that should be used for the dependency (as defined in the dependency's
    /// manifest but specified in the depender's manifest).
    ///
    /// E.g. if `a/Move.toml` contains
    /// ```toml
    /// environments.mainnet = "1234"
    /// dep-replacements.mainnet.b = { ..., use-environment="foo" }
    /// ```
    ///
    /// then use_environment for the `b` dependency would be `foo`
    pub use_environment: Option<EnvironmentName>,

    /// Contains the package's manifest digest. This is used to verify if a manifest has changed
    /// and re-pinning is required.
    pub manifest_digest: String,

    /// The package's dependencies, a map from the package name to the package id.
    pub deps: BTreeMap<PackageName, PackageID>,
}

/// A serialized pinned dependency in a lockfile
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(untagged)]
pub enum LockfileDependencyInfo {
    Local(LocalDepInfo),
    OnChain(OnChainDepInfo),
    Git(LockfileGitDepInfo),
    Root(RootDepInfo),
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct RootDepInfo {
    pub root: bool,
}

/// A serialized lockfile dependency of the form `{git = "...", rev = "...", subdir = "..."}`
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct LockfileGitDepInfo {
    /// The repository containing the dependency
    #[serde(rename = "git")]
    pub repo: String,

    /// The path within the repository
    #[serde(rename = "subdir")]
    pub path: PathBuf,

    /// The git commit or branch for the dependency.
    pub rev: GitSha,
}

impl<F: MoveFlavor> ParsedLockfile<F> {
    /// Pretty-print `self` as a TOML document
    pub fn render_as_toml(&self) -> String {
        let mut toml = toml_edit::ser::to_document(self).expect("toml serialization succeeds");

        expand_toml(&mut toml);
        for (_, chain) in toml["pinned"].as_table_like_mut().unwrap().iter_mut() {
            for (_, item) in chain.as_table_like_mut().unwrap().iter_mut() {
                flatten_toml(item);
            }
        }

        for (_, chain) in toml["published"].as_table_like_mut().unwrap().iter_mut() {
            flatten_toml(chain.get_mut("dependencies").unwrap());
        }

        toml.decor_mut()
            .set_prefix("# Generated by move; do not edit\n# This file should be checked in.\n\n");

        toml.to_string()
    }
}

impl<F: MoveFlavor> Publication<F> {
    /// Pretty-print `self` as TOML
    pub fn render_as_toml(&self) -> String {
        let mut toml = toml_edit::ser::to_document(self).expect("toml serialization succeeds");
        expand_toml(&mut toml);
        flatten_toml(&mut toml["dependencies"]);

        toml.decor_mut().set_prefix(
            "# Generated by move; do not edit\n# This file should not be checked in\n\n",
        );
        toml.to_string()
    }
}

impl TryFrom<u8> for Constant4 {
    type Error = &'static str;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        if value != 4 {
            Err("expected version 4")
        } else {
            Ok(Constant4)
        }
    }
}

impl From<Constant4> for u8 {
    fn from(_: Constant4) -> Self {
        4
    }
}

/// Replace every inline table in [toml] with an implicit standard table (implicit tables are not
/// included if they have no keys directly inside them)
pub fn expand_toml(toml: &mut DocumentMut) {
    struct Expander;

    impl VisitMut for Expander {
        fn visit_table_mut(&mut self, table: &mut Table) {
            table.set_implicit(true);
            visit_mut::visit_table_mut(self, table);
        }

        fn visit_table_like_kv_mut(&mut self, mut key: KeyMut<'_>, node: &mut Item) {
            if let Item::Value(Value::InlineTable(inline_table)) = node {
                let inline_table = std::mem::replace(inline_table, InlineTable::new());
                let table = inline_table.into_table();
                key.fmt();
                *node = Item::Table(table);
            }
            visit_mut::visit_table_like_kv_mut(self, key, node);
        }
    }

    let mut visitor = Expander;
    visitor.visit_document_mut(toml);
}

/// Replace every table in [toml] with a non-implicit inline table.
pub fn flatten_toml(toml: &mut Item) {
    struct Inliner;

    impl VisitMut for Inliner {
        fn visit_table_mut(&mut self, table: &mut Table) {
            table.set_implicit(false);
            visit_mut::visit_table_mut(self, table);
        }

        fn visit_table_like_kv_mut(&mut self, mut key: KeyMut<'_>, node: &mut Item) {
            if let Item::Table(table) = node {
                let table = std::mem::replace(table, Table::new());
                let inline_table = table.into_inline_table();
                key.fmt();
                *node = Item::Value(Value::InlineTable(inline_table));
            }
        }
    }

    let mut visitor = Inliner;
    visitor.visit_item_mut(toml);
}

// TODO
#[cfg(test)]
mod tests {
    use indoc::indoc;
    use test_log::test;
    use tracing::debug;

    use crate::flavor::Vanilla;

    use super::ParsedLockfile;

    /// Parsing and then printing a well-formatted lockfile produces the original
    /// (this serves as an example output as well as a test)
    #[test]
    fn parse_then_render() {
        let lockfile = indoc!(
            r###"
            # Generated by move; do not edit
            # This file should be checked in.

            [move]
            version = 4

            [pinned.mainnet.Foo_0]
            source = { git = "...", subdir = "...", rev = "da39a3ee5e6b4b0d3255bfef95601890afd80709" }
            manifest_digest = "..."
            deps = { std = "MoveStdlib", sui = "Sui" }

            [pinned.mainnet.Foo_1]
            source = { git = "...", subdir = "...", rev = "da39a3ee5e6b4b0d3255bfef95601890afd80709" }
            manifest_digest = "..."
            deps = { std = "MoveStdlib", sui = "Sui" }

            [pinned.mainnet.MoveStdlib]
            source = { git = "...", subdir = "...", rev = "da39a3ee5e6b4b0d3255bfef95601890afd80709" }
            manifest_digest = "..."
            deps = {}

            [pinned.mainnet.Sui]
            source = { git = "...", subdir = "...", rev = "da39a3ee5e6b4b0d3255bfef95601890afd80709" }
            manifest_digest = "..."
            deps = { std = "MoveStdlib" }

            [pinned.testnet.MoveStdlib]
            source = { git = "...", subdir = "...", rev = "da39a3ee5e6b4b0d3255bfef95601890afd80709" }
            manifest_digest = "..."
            deps = {}

            [pinned.testnet.example]
            source = { local = "." }
            manifest_digest = "..."
            deps = { bar = "bar", foo = "Foo_0", non = "Foo_1", std = "MoveStdlib", sui = "Sui" }
            "###
        );

        let parsed: ParsedLockfile<Vanilla> = toml_edit::de::from_str(lockfile).unwrap();
        let rendered = parsed.render_as_toml();
        debug!("Original lockfile:\n---\n{lockfile}\n---");
        debug!("Rendered lockfile:\n---\n{rendered}\n---");
        assert_eq!(rendered, lockfile);
    }
}
