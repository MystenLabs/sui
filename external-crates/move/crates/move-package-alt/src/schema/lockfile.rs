use derive_where::derive_where;
use serde::{Deserialize, Serialize};
use std::{collections::BTreeMap, path::PathBuf};
use toml_edit::{
    DocumentMut, InlineTable, Item, KeyMut, Table, Value,
    visit_mut::{self, VisitMut},
};

use crate::flavor::MoveFlavor;

use super::{
    EnvironmentID, EnvironmentName, GitSha, LocalDepInfo, OnChainDepInfo, PackageName,
    PublishAddresses,
};

/// An identifier for a node in the package graph, used to index into the
/// `[pinned.<environment>]` table
pub type PackageID = String;

/// The serialized lockfile format
// TODO: remove Debug and Clone
#[derive(Debug, Serialize, Deserialize)]
#[derive_where(Default, Clone)]
#[serde(bound = "")]
pub struct ParsedLockfile<F: MoveFlavor> {
    #[serde(default)]
    pub pinned: BTreeMap<EnvironmentName, BTreeMap<PackageID, Pin>>,

    #[serde(default)]
    pub published: BTreeMap<EnvironmentName, Publication<F>>,
}

pub type BuildConfig = toml::Value;

/// A serialized entry in the `[published.<environment>]` table of the lockfile
#[derive(Debug, Serialize, Deserialize)]
#[derive_where(Clone)]
#[serde(rename_all = "kebab-case")]
pub struct Publication<F: MoveFlavor> {
    #[serde(flatten)]
    pub addresses: PublishAddresses,
    pub chain_id: EnvironmentID,
    pub toolchain_version: String,
    pub build_config: BuildConfig,

    #[serde(flatten)]
    pub metadata: F::PublishedMetadata,
}

/// A serialized entry in the `[pinned.<environment>.<package-id>]` table of the lockfile
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename = "kabob-case")]
pub struct Pin {
    /// Metadata about the package's source
    pub source: LockfileDependencyInfo,

    /// The environment that should be used for the dependency (as defined in the dependency's
    /// manifest but specified in the depender's manifest).
    ///
    /// E.g. if `a/Move.toml` contains
    /// ```toml
    /// environments.mainnet = "1234"
    /// dep-replacements.mainnet.b = { ..., use-environment="foo" }
    /// ```
    ///
    /// then use_environment for the `b` dependency would be `foo`
    pub use_environment: Option<EnvironmentName>,

    /// Contains the package's manifest digest. This is used to verify if a manifest has changed
    /// and re-pinning is required.
    pub manifest_digest: String,

    /// The package's dependencies, a map from the package name to the package id.
    pub deps: BTreeMap<PackageName, PackageID>,
}

/// A serialized pinned dependency in a lockfile
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
#[serde(untagged)]
pub enum LockfileDependencyInfo {
    Local(LocalDepInfo),
    OnChain(OnChainDepInfo),
    Git(LockfileGitDepInfo),
}

/// A serialized lockfile dependency of the form `{git = "...", rev = "...", subdir = "..."}`
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct LockfileGitDepInfo {
    /// The repository containing the dependency
    #[serde(rename = "git")]
    pub repo: String,

    /// The git commit or branch for the dependency.
    pub rev: GitSha,

    /// The path within the repository
    #[serde(rename = "subdir")]
    pub path: PathBuf,
}

impl<F: MoveFlavor> ParsedLockfile<F> {
    /// Pretty-print `self` as a TOML document
    pub fn render_as_toml(&self) -> String {
        let mut toml = toml_edit::ser::to_document(self).expect("toml serialization succeeds");

        expand_toml(&mut toml);
        for (_, chain) in toml["pinned"].as_table_like_mut().unwrap().iter_mut() {
            for (_, item) in chain.as_table_like_mut().unwrap().iter_mut() {
                flatten_toml(item);
            }
        }

        for (_, chain) in toml["published"].as_table_like_mut().unwrap().iter_mut() {
            flatten_toml(chain.get_mut("dependencies").unwrap());
        }

        toml.decor_mut()
            .set_prefix("# Generated by move; do not edit\n# This file should be checked in.\n\n");

        toml.to_string()
    }
}

impl<F: MoveFlavor> Publication<F> {
    /// Pretty-print `self` as TOML
    pub fn render_as_toml(&self) -> String {
        let mut toml = toml_edit::ser::to_document(self).expect("toml serialization succeeds");
        expand_toml(&mut toml);
        flatten_toml(&mut toml["dependencies"]);

        toml.decor_mut().set_prefix(
            "# Generated by move; do not edit\n# This file should not be checked in\n\n",
        );
        toml.to_string()
    }
}

/// Replace every inline table in [toml] with an implicit standard table (implicit tables are not
/// included if they have no keys directly inside them)
pub fn expand_toml(toml: &mut DocumentMut) {
    struct Expander;

    impl VisitMut for Expander {
        fn visit_table_mut(&mut self, table: &mut Table) {
            table.set_implicit(true);
            visit_mut::visit_table_mut(self, table);
        }

        fn visit_table_like_kv_mut(&mut self, mut key: KeyMut<'_>, node: &mut Item) {
            if let Item::Value(Value::InlineTable(inline_table)) = node {
                let inline_table = std::mem::replace(inline_table, InlineTable::new());
                let table = inline_table.into_table();
                key.fmt();
                *node = Item::Table(table);
            }
            visit_mut::visit_table_like_kv_mut(self, key, node);
        }
    }

    let mut visitor = Expander;
    visitor.visit_document_mut(toml);
}

/// Replace every table in [toml] with a non-implicit inline table.
pub fn flatten_toml(toml: &mut Item) {
    struct Inliner;

    impl VisitMut for Inliner {
        fn visit_table_mut(&mut self, table: &mut Table) {
            table.set_implicit(false);
            visit_mut::visit_table_mut(self, table);
        }

        fn visit_table_like_kv_mut(&mut self, mut key: KeyMut<'_>, node: &mut Item) {
            if let Item::Table(table) = node {
                let table = std::mem::replace(table, Table::new());
                let inline_table = table.into_inline_table();
                key.fmt();
                *node = Item::Value(Value::InlineTable(inline_table));
            }
        }
    }

    let mut visitor = Inliner;
    visitor.visit_item_mut(toml);
}

// TODO
#[cfg(test)]
mod tests {}
