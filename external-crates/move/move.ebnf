
/* Module */

/* A module is a sequence of module members enclosed in braces or terminated by a semicolon. */
module ::= module_header module_body

/* A module header is a module keyword followed by an address literal or identifier followed by a double colon and an identifier. */
module_header ::= "module" (hex_numeric_literal | identifier) "::" module_identifier

/* A module body is a sequence of module members enclosed in braces or terminated by a semicolon. */
module_body ::= ("{" (module_member)* "}") | ";" (module_member)*

/* Module Members */

/* A module member is a struct definition, enum definition, const definition, fun definition, or friend declaration. */
module_member ::= struct_definition | enum_definition | const_definition | fun_definition | friend_declaration

/* A const definition is a const keyword followed by a const identifier, a colon, a built-in type, an equals sign, and a literal. */
const_definition ::= "const" const_identifier ":" built_in_type "=" (literal | const_expression ) ";"

/*
 * A friend declaration is a friend keyword followed by an address literal or identifier followed by a double colon and an identifier.
 *
 * friend 0x0::mod;
 * friend pkg::mod;
 */
friend_declaration ::= "friend" (hex_numeric_literal | identifier) "::" identifier ";"

/* Module: struct and enum */

/* A struct definition is a public keyword followed by a struct keyword followed by a struct identifier followed by a struct or enum type parameters followed by an optional abilities followed by a struct body. */
struct_definition ::= "public" "struct" struct_or_enum_identifier struct_or_enum_type_parameters? ("has" abilities)? named_fields | positional_fields ("has" abilities ";")?

/* Regular struct body is enclosed in braces and consists of a sequence of struct members separated by commas. */
named_fields ::= "{" (struct_field ("," struct_field)*)? "}"

/* Struct field is a field identifier followed by a colon and a type. */
struct_field ::= field_identifier ":" built_in_type

/* Positional struct body is enclosed in parentheses and consists of a sequence of types separated by commas. */
positional_fields ::= "(" built_in_type ("," built_in_type)* ")"

/* An enum */
enum_definition ::= "public" "enum" struct_or_enum_identifier struct_or_enum_type_parameters? ("has" abilities)? enum_variants ("has" abilities ";")?

/* An enum must contain at least one variant. */
enum_variants ::= "{" enum_variant ("," enum_variant)* "}"

/* An enum variant is an identifier followed by an optional positional fields or optional named fields. */
enum_variant ::= field_identifier positional_fields | identifier named_fields

/* Module: function */

/* A function definition consists of the function signature followed by the function body for non-native functions. */
/* A native definition does not feature a body and ends with a semicolon. */
function_definition ::= function_signature (function_body | ";")

/* A function signature consists of the function identifier, optional type parameters, optional function parameters, and optional return type. */
function_signature ::= "fun" function_identifier function_type_parameters? function_parameters return_type?

/* Function parameters is a sequence of function parameters separated by commas. */
function_parameters ::= "(" (function_parameter ("," function_parameter)*)? ")"

/* A function parameter is a mutability, a local variable name, and a type. */
function_parameter ::= mut? local_identifier ":" type

/* A return type is a single type or a tuple of types with at least one element. */
return_type ::= ":" ("(" type ("," type)* ")") | type

/* A function body is an expression block. */
function_body ::= "{" "}"

/* Identifiers */

/*
 * Address identifiers start with any allowed symbol but not a digit.
 * a_0
 * _Argument_1
 * A
 * _0
 * _
 */
address_identifier ::= (lowercase_letter | uppercase_letter | underscore) (lowercase_letter | uppercase_letter | digit | underscore)*

/* Module identifiers must start with a letter. */
module_identifier ::= (uppercase_letter | lowercase_letter) (lowercase_letter | digit | underscore)*

/* Struct identifiers must start with an uppercase letter followed by any number of lowercase letters, digits, and underscores. */
struct_or_enum_identifier ::= uppercase_letter (lowercase_letter | digit | underscore)*

/* Const identifiers must start with an uppercase letter followed by any number of lowercase letters, digits, and underscores. */
/* Convention: regular constants are named with `ALL_UPPERCASE`, while for error constants `EPascalCase` is used */
const_identifier ::= uppercase_letter (lowercase_letter | digit | underscore)*

/* Local identifiers must start with a lowercase letter. */
local_identifier ::= (lowercase_letter | underscore) (lowercase_letter | digit | underscore)*

/* Field identifiers start with any allowed symbol but not a digit. */
field_identifier ::= (lowercase_letter | uppercase_letter | underscore) (lowercase_letter | uppercase_letter | digit | underscore)*

/* TODO: Function identifiers must start with a lowercase letter. */
function_identifier ::= field_identifier

/* Generics and Type Parameters */

/* A type parameter is a sequence of type parameters with optional ability constraints. */
type_parameter ::= identifier (":" ability_constraint)?

/* Phantom type parameter is a parameter prefixed with `phantom`, these type parameters can only be used in type definitions. */
/* Type parameter must be declared phantom if it is not used in any struct fields. */
phantom_type_parameter ::= "phantom" type_parameter

/* Generalization of type parameters for structs and enums. */
struct_or_enum_type_parameter ::= type_parameter | phantom_type_parameter

/* Generalization of type parameters for structs and enums. */
struct_or_enum_type_parameters ::= "<" (struct_or_enum_type_parameter ("," struct_or_enum_type_parameter)*)? ">"

/* A type parameter list is a sequence of type parameters separated by commas. */
function_type_parameters ::= "<" (type_parameter ("," type_parameter)*)? ">"

/* Types */

/* Currently, only unsigned integers are supported. */
integer_type ::= "u8" | "u16" | "u32" | "u64" | "u128" | "u256"

/* An element type is either a built-in type or a custom type. */
element_type ::= built_in_type | struct_or_enum_identifier

/* An address type */
address_type ::= "address"

/* A built-in type is a vector type, integer type, or boolean type. */
built_in_type ::= integer_type | boolean_type | built_in_vector_type | address_type

/* A built-in vector type is a vector of elements. */
built_in_vector_type ::= "vector" "<" built_in_type ">"

/* A vector type is a vector of elements. */
vector_type ::= "vector" "<" element_type ">"

/* A generalization of types: includes all built-in types, vector types, and struct or enum identifiers. */
type ::= built_in_type | vector_type | struct_or_enum_identifier

/* Literals */

/* A boolean is either true or false. */
boolean_literal ::= "true" | "false"

/* A vector literal is a sequence of elements separated by commas. */
vector_literal ::= "vector" ("<" element_type ">")? "[" (literal ("," literal)*)? "]"

/* A numeric literal is a sequence of digits (cannot start with 0) followed by an optional integer type. */
numeric_literal ::= ("0" | non_zero_digit+) (integer_type)?

/* A hex numeric literal is a sequence of hex digits (0-9, a-f, A-F) starting with 0x. */
hex_numeric_literal ::= "0x" (hex_digit+)

/* An address literal is a either a sequence of @ followed by a hex numeric literal up to 64 characters. */
address_literal ::= "@" (("0" | non_zero_digit)+) | "@" hex_numeric_literal

/* A literal is a boolean literal, vector literal, numeric literal, hex numeric literal, or address literal. */
literal ::= boolean_literal | vector_literal | numeric_literal | hex_numeric_literal | address_literal

/* Expressions */

/*
 * Const expression is a block of simple arithmetic and bitwise operations which
 * can either use const identifiers or literals.
 */
const_expression ::= "{" "}"

/* Other */

/* Move type ability */
ability ::= "key" | "store" | "copy" | "drop"

/* Abilities are a sequence of abilities separated by commas. Used in struct and enum declarations. */
abilities ::= ability ("," ability)*

/* Ability constraint is a sequence of abilities separated by plus signs. Used in type parameters. */
ability_constraint ::= ability ("+" ability)*

/* A mutability is marked with the mut keyword. */
mut ::= "mut"

/* Utility non-terminals */

digit ::= "0".."9"
hex_digit ::= "0".."9" | "a".."f" | "A".."F"
non_zero_digit ::= "1".."9"

underscore ::= "_"
uppercase_letter ::= "A".."Z"
lowercase_letter ::= "a".."Z"
