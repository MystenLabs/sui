#################################################################
# helpers to parse stats and time log files.
# Log files are generated by running a fullnode with the proper flags.
# This module then parse those files to generate python objects for transactions.
# The objects can then be saved in a file (pickle) for later use.
# Alernatively, the objects can be used directly and files generated in any format desired.
#

from collections import defaultdict
import csv
from glob import glob
from os import path
from pathlib import Path
from transaction_model import Transaction, TransactionType, ExecutionResult, GasInfo

#
# Temporary map to help build transactions. digest => Transaction
#
txn_to_build = defaultdict(Transaction)


def parse_line(line):
    """Parse a single line"""
    # get the digest and create an entry in the map
    line_parts = line.split(':', 1)
    digest = line_parts[0].strip()
    # TODO: Look into generating an output more friendly to parsing...
    process_line(digest, line_parts[1].strip())


def process_line(digest, line):
    """
    Identify and process the line in input, we have 4 types of lines:
    1- transaction type
    2- native functions
    3- gas info
    4- transaction effects
    """
    (key, idx) = get_line_type(line)
    txn = txn_to_build[digest]
    if txn.digest is None:
        txn.digest = digest
    # transaction type
    if key == 'genesis':
        pass
    elif key == 'consensus_commit_prologue':
        pass
    elif key == 'change_epoch':
        pass
    elif key == 'pr_tr':
        (value, idx) = get_value(line, idx)
        txn.txn_type = TransactionType.PROGRAMMABLE_TRANSACTION
        txn.programmable_transaction = process_programmable(line, idx)
    # natives
    elif key == 'natives':
        process_natives(txn, line, idx)
    # gas
    elif key == 'b':
        if txn.programmable_transaction:
            txn.programmable_transaction.gas_info = process_gas(line, idx)
        else:
            # it may be too much to print the error as it may not matter much
            # Anyway uncomment if interested
            # print(f"ERROR: missing transaction {digest}")
            pass
    # effects
    elif key == 'err':
        (value, idx) = get_value(line, idx)
        txn.error = ExecutionResult(value)
        process_effects(txn, line, idx)
    else:
        raise Exception(f"Unrecognized line type: '{line}'")
    return


def get_line_type(line):
    """Call after the digest to identify the type of line we are processing"""
    idx = 0
    while idx < len(line) - 1:
        c = line[idx]
        if c.isspace() or c == ',':
            idx += 1
            continue
        return get_key(line, idx)
    raise Exception(f"Unrecognized line type: '{line}'")


def get_key(line, start):
    """Get the key in `line` from `start`"""
    idx = start
    key = ""
    for idx in range(idx, len(line)):
        c = line[idx]
        if c.isidentifier():
            key += c
        else:
            break
    return key, idx


def get_value(line, start):
    """Get a value as an integer or an address. Called after a key"""
    idx = start
    value = ""
    for idx in range(idx, len(line)):
        c = line[idx]
        if c.isspace() or c == '=':
            continue
        elif c == '0' and idx + 1 < len(line) and line[idx + 1] == 'x':
            (value, idx) = get_address(line, idx + 2)
            return value, idx
        elif c.isnumeric():
            value += c
        else:
            break
    return int(value), idx


def get_address(line, start):
    """Get an address value"""
    idx = start
    for idx in range(idx, len(line)):
        c = line[idx]
        if c.isspace():
            break
    return line[start:idx], idx


def get_pair(line, start):
    """"Get a pair of integers"""
    idx = start
    first = 0
    second = 0
    value = ""
    for idx in range(idx, len(line)):
        c = line[idx]
        if c.isspace() or c == '=' or c == '(':
            continue
        elif c == ')':
            second = int(value)
            idx += 1
            break
        elif c.isnumeric():
            value += c
        elif c == ',':
            first = int(value)
            value = ""
        else:
            break
    return (first, second), idx


def process_programmable(line, idx):
    """Parse a programmable transaction line"""
    prog_txn = ProgrammableTransaction()
    pub = 0
    pub_bytes = 0
    while idx < len(line) - 1:
        c = line[idx]
        if c.isspace() or c == ',':
            idx += 1
            continue
        (key, idx) = get_key(line, idx)
        if key == "pub":
            (value, idx) = get_value(line, idx)
            pub = value
        elif key == "p_b":
            (value, idx) = get_value(line, idx)
            pub_bytes = value
        elif key == "sp":
            (value, idx) = get_value(line, idx)
            prog_txn.splits = value
        elif key == "me":
            (value, idx) = get_value(line, idx)
            prog_txn.merge = value
        elif key == "m_v":
            (value, idx) = get_value(line, idx)
            prog_txn.make_move_vec = value
        elif key == "tr":
            (value, idx) = get_value(line, idx)
            prog_txn.transfer = value
        elif key == "pgs":
            (values, idx) = get_values(line, idx)
            prog_txn.move_calls.packages = values
        elif key == "mds":
            (values, idx) = get_values(line, idx)
            prog_txn.move_calls.modules = values
        elif key == "fns":
            (values, idx) = get_values(line, idx)
            prog_txn.move_calls.functions = values
        else:
            raise Exception(f"Unrecognized programmable transaction key: '{key}' in line: '{line}'")
    prog_txn.publish = (pub, pub_bytes)

    return prog_txn


def process_natives(txn, line, idx):
    """Parse natives information line"""
    natives = txn.natives
    while idx < len(line) - 1:
        c = line[idx]
        if c.isspace() or c == ',' or c == '[' or c == ':':
            idx += 1
            continue
        (native, idx) = get_key(line, idx)
        (count_cost, idx) = get_pair(line, idx)
        natives[native] = count_cost


def process_gas(line, idx):
    """Parse a gas stats line"""
    gas_info = GasInfo()
    (value, idx) = get_value(line, idx)
    gas_info.budget = value
    computation_cost = 0
    computation_cost_rounded = 0
    while idx < len(line) - 1:
        c = line[idx]
        if c.isspace() or c == ',':
            idx += 1
            continue
        (key, idx) = get_key(line, idx)
        (value, idx) = get_value(line, idx)
        if key == "p":
            gas_info.gas_price = value
        elif key == "c_c":
            computation_cost = value
        elif key == "s_c":
            gas_info.storage_cost = value
        elif key == "s_r":
            gas_info.storage_rebate = value
        elif key == "n_r_s_f":
            gas_info.non_refundable_storage_fee = value
        elif key == "ins":
            gas_info.instruction_count = value
        elif key == "st_h":
            gas_info.stack_height = value
        elif key == "st_s":
            gas_info.stack_size = value
        elif key == "gas":
            gas_info.gas_used = value
        elif key == "c_c_r":
            computation_cost_rounded = value
        else:
            raise Exception(f"Unrecognized gas info key: '{key}' in line: '{line}'")
    gas_info.add_computation_cost(computation_cost)
    gas_info.add_computation_cost_rounded(computation_cost_rounded)
    return gas_info


def process_effects(txn, line, idx):
    """Parse a transaction effects/results line"""
    while idx < len(line) - 1:
        c = line[idx]
        if c.isspace() or c == ',':
            idx += 1
            continue
        (key, idx) = get_key(line, idx)
        (value, idx) = get_value(line, idx)
        if key == "o_s":
            txn.shared_objects = value
        elif key == "o_c":
            txn.created = value
        elif key == "o_m":
            txn.mutated = value
        elif key == "o_u":
            txn.unwrapped = value
        elif key == "o_d":
            txn.deleted = value
        elif key == "o_u_d":
            txn.unwrapped_deleted = value
        elif key == "o_w":
            txn.wrapped = value
        elif key == "sgn":
            txn.signer = value
        else:
            raise Exception(f"Unrecognized gas info key: '{key}' in line: '{line}'")


def get_values(line, idx):
    """Get an array of key/value pairs starting from `[` until `]`"""
    # read values in '[...]'
    key_value = {}
    while idx < len(line):
        c = line[idx]
        idx += 1
        if c.isspace() or c == ',' or c == '['  or c == '=':
            continue
        elif c == ']':
            break
        else:
            key = c
            while idx < len(line):
                c = line[idx]
                idx += 1
                if c == '=':
                    break
                key += c
            key = key.strip()
            (value, idx) = get_value(line, idx)
            key_value[key] = value

    return key_value, idx


def parse_times(rel_path):
    """
    Load transactions times from the csv files that match `rel_path` from current working directory
    """
    files_path = path.join(Path.cwd(), rel_path)
    times_files = glob(files_path)
    for file_name in times_files:
        print(f"reading {file_name}")
        i = 0
        with open(file_name, newline='') as csvfile:
            reader = csv.reader(csvfile)
            count = 0
            for row in reader:
                count += 1
                digest = row[0]
                t =  int(row[1]) / 1000000
                if digest in txn_to_build:
                    txn_to_build[digest].times.append(t)
                else:
                    # it may be too much to print next as it may not be an error
                    # but simply the fact stats and times logs are generated at
                    # different times. Anyway uncomment if interested
                    # print(f"ERROR: missing transaction {digest}")
                    pass
        print(f"{file_name} {count} transactions read")

    print("done with txn time logs")
    print(f"total transactions read: {len(txn_to_build)}")


def parse_stats(filter):
    """Parse stats files, create and populate gas_stats"""
    files_path = path.join(Path.cwd(), filter)
    stats_files = glob(files_path)
    # limit parsing as needed by defining the lines to read
    for file_name in stats_files:
        check = 1
        lines = 0
        start = 200000000
        stop =  500000000
        step = 1000000

        print(f"parse stats file {file_name}")
        file = open(file_name)
        while True:
            # show progess or you may sit there wondering if anything is happening
            if check % step == 0:
                lines = lines + step
                print(f"parsed {lines:,} lines")
                if lines >= stop:
                    break
            line = file.readline()
            check = check + 1
            if check < start:
                continue
            if not line:
                break
            parse_line(line)
    print("done with stats files")
    print(f"total transactions read: {len(txn_to_build)}")


#######################################################################
# Entry point for loading all data about transactions
#
def load_data(stats_path, times_path, programmable_transactions, system_transactions):
    """Load all transactions from log files in path"""
    global txn_to_build
    txn_to_build = defaultdict(Transaction)

    parse_stats(stats_path)
    parse_times(times_path)

    txns = {digest: txn for digest, txn in txn_to_build.items() if txn.is_valid() and txn.is_programmable()}
    print(f"transactions left: {len(txn_to_build)}")
    txn_to_build = None # kill temporary map

    invalid = 0
    print(f"total transactions: {len(txns)}")
    for txn in txns.values():
        if not txn.is_valid():
            invalid += 1
            continue
        elif txn.is_system():
            system_transactions.append(txn)
        elif txn.is_programmable():
            programmable_transactions.append(txn)
        else:
            raise Exception(f"Unknown transaction: {txn}")

    txn_to_build = None # kill temporary map
    print(f"invalid transactions: {invalid}")
    print(f"system transactions: {len(system_transactions)}")
    print(f"programmable transactions: {len(programmable_transactions)}")


#
# Pickle transaction results.
# Functions to save to a file and to load from a file.
#
import pickle

def save_transactions(txns, rel_path):
    file_name = path.join(Path.cwd(), rel_path)
    file = open(file_name, 'wb')
    pickle.dump(txns, file, pickle.HIGHEST_PROTOCOL)
    file.close()


def load_transactions(rel_path):
    file_name = path.join(Path.cwd(), rel_path)
    file = open(file_name, 'rb')
    obj = pickle.load(file)
    file.close()
    return obj


def load_files(files, txns):
    """
    Load transactions from a list of files.
    Files are searched in the current working directory according to the glob pattern provided.
    The loaded files are expected to return a list that is then appended to the txns list in input.
    """
    files_path = path.join(Path.cwd(), files)
    pickle_files = glob(files_path)
    for file_name in pickle_files:
        print(f"Reading: {file_name}")
        data = load_transactions(file_name)
        print(f"found {len(data)} transactions")
        txns.extend(data)
